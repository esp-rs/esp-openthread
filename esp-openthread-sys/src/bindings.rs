/* automatically generated by rust-bindgen 0.69.4 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const OT_LOG_LEVEL_NONE: u32 = 0;
pub const OT_LOG_LEVEL_CRIT: u32 = 1;
pub const OT_LOG_LEVEL_WARN: u32 = 2;
pub const OT_LOG_LEVEL_NOTE: u32 = 3;
pub const OT_LOG_LEVEL_INFO: u32 = 4;
pub const OT_LOG_LEVEL_DEBG: u32 = 5;
pub const OPENTHREAD_API_VERSION: u32 = 439;
pub const OT_UPTIME_STRING_SIZE: u32 = 24;
pub const OT_CHANGED_IP6_ADDRESS_ADDED: u32 = 1;
pub const OT_CHANGED_IP6_ADDRESS_REMOVED: u32 = 2;
pub const OT_CHANGED_THREAD_ROLE: u32 = 4;
pub const OT_CHANGED_THREAD_LL_ADDR: u32 = 8;
pub const OT_CHANGED_THREAD_ML_ADDR: u32 = 16;
pub const OT_CHANGED_THREAD_RLOC_ADDED: u32 = 32;
pub const OT_CHANGED_THREAD_RLOC_REMOVED: u32 = 64;
pub const OT_CHANGED_THREAD_PARTITION_ID: u32 = 128;
pub const OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER: u32 = 256;
pub const OT_CHANGED_THREAD_NETDATA: u32 = 512;
pub const OT_CHANGED_THREAD_CHILD_ADDED: u32 = 1024;
pub const OT_CHANGED_THREAD_CHILD_REMOVED: u32 = 2048;
pub const OT_CHANGED_IP6_MULTICAST_SUBSCRIBED: u32 = 4096;
pub const OT_CHANGED_IP6_MULTICAST_UNSUBSCRIBED: u32 = 8192;
pub const OT_CHANGED_THREAD_CHANNEL: u32 = 16384;
pub const OT_CHANGED_THREAD_PANID: u32 = 32768;
pub const OT_CHANGED_THREAD_NETWORK_NAME: u32 = 65536;
pub const OT_CHANGED_THREAD_EXT_PANID: u32 = 131072;
pub const OT_CHANGED_NETWORK_KEY: u32 = 262144;
pub const OT_CHANGED_PSKC: u32 = 524288;
pub const OT_CHANGED_SECURITY_POLICY: u32 = 1048576;
pub const OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL: u32 = 2097152;
pub const OT_CHANGED_SUPPORTED_CHANNEL_MASK: u32 = 4194304;
pub const OT_CHANGED_COMMISSIONER_STATE: u32 = 8388608;
pub const OT_CHANGED_THREAD_NETIF_STATE: u32 = 16777216;
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE: u32 = 33554432;
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_LOCAL: u32 = 67108864;
pub const OT_CHANGED_JOINER_STATE: u32 = 134217728;
pub const OT_CHANGED_ACTIVE_DATASET: u32 = 268435456;
pub const OT_CHANGED_PENDING_DATASET: u32 = 536870912;
pub const OT_CHANGED_NAT64_TRANSLATOR_STATE: u32 = 1073741824;
pub const OT_CHANGED_PARENT_LINK_QUALITY: u32 = 2147483648;
pub const OT_CRYPTO_SHA256_HASH_SIZE: u32 = 32;
pub const OT_CRYPTO_ECDSA_MAX_DER_SIZE: u32 = 125;
pub const OT_CRYPTO_ECDSA_PUBLIC_KEY_SIZE: u32 = 64;
pub const OT_CRYPTO_ECDSA_SIGNATURE_SIZE: u32 = 64;
pub const OT_CRYPTO_PBDKF2_MAX_SALT_SIZE: u32 = 30;
pub const OT_PANID_BROADCAST: u32 = 65535;
pub const OT_EXT_ADDRESS_SIZE: u32 = 8;
pub const CSL_IE_HEADER_BYTES_LO: u32 = 4;
pub const CSL_IE_HEADER_BYTES_HI: u32 = 13;
pub const OT_MAC_KEY_SIZE: u32 = 16;
pub const OT_IP6_PREFIX_SIZE: u32 = 8;
pub const OT_IP6_PREFIX_BITSIZE: u32 = 64;
pub const OT_IP6_IID_SIZE: u32 = 8;
pub const OT_IP6_ADDRESS_SIZE: u32 = 16;
pub const OT_IP6_ADDRESS_BITSIZE: u32 = 128;
pub const OT_IP6_HEADER_SIZE: u32 = 40;
pub const OT_IP6_HEADER_PROTO_OFFSET: u32 = 6;
pub const OT_IP6_ADDRESS_STRING_SIZE: u32 = 40;
pub const OT_IP6_SOCK_ADDR_STRING_SIZE: u32 = 48;
pub const OT_IP6_PREFIX_STRING_SIZE: u32 = 45;
pub const OT_IP6_MAX_MLR_ADDRESSES: u32 = 15;
pub const OT_NETWORK_KEY_SIZE: u32 = 16;
pub const OT_NETWORK_NAME_MAX_SIZE: u32 = 16;
pub const OT_EXT_PAN_ID_SIZE: u32 = 8;
pub const OT_MESH_LOCAL_PREFIX_SIZE: u32 = 8;
pub const OT_PSKC_MAX_SIZE: u32 = 16;
pub const OT_CHANNEL_1_MASK: u32 = 2;
pub const OT_CHANNEL_2_MASK: u32 = 4;
pub const OT_CHANNEL_3_MASK: u32 = 8;
pub const OT_CHANNEL_4_MASK: u32 = 16;
pub const OT_CHANNEL_5_MASK: u32 = 32;
pub const OT_CHANNEL_6_MASK: u32 = 64;
pub const OT_CHANNEL_7_MASK: u32 = 128;
pub const OT_CHANNEL_8_MASK: u32 = 256;
pub const OT_CHANNEL_9_MASK: u32 = 512;
pub const OT_CHANNEL_10_MASK: u32 = 1024;
pub const OT_CHANNEL_11_MASK: u32 = 2048;
pub const OT_CHANNEL_12_MASK: u32 = 4096;
pub const OT_CHANNEL_13_MASK: u32 = 8192;
pub const OT_CHANNEL_14_MASK: u32 = 16384;
pub const OT_CHANNEL_15_MASK: u32 = 32768;
pub const OT_CHANNEL_16_MASK: u32 = 65536;
pub const OT_CHANNEL_17_MASK: u32 = 131072;
pub const OT_CHANNEL_18_MASK: u32 = 262144;
pub const OT_CHANNEL_19_MASK: u32 = 524288;
pub const OT_CHANNEL_20_MASK: u32 = 1048576;
pub const OT_CHANNEL_21_MASK: u32 = 2097152;
pub const OT_CHANNEL_22_MASK: u32 = 4194304;
pub const OT_CHANNEL_23_MASK: u32 = 8388608;
pub const OT_CHANNEL_24_MASK: u32 = 16777216;
pub const OT_CHANNEL_25_MASK: u32 = 33554432;
pub const OT_CHANNEL_26_MASK: u32 = 67108864;
pub const OT_OPERATIONAL_DATASET_MAX_LENGTH: u32 = 254;
pub const OT_JOINER_MAX_DISCERNER_LENGTH: u32 = 64;
pub const OT_COMMISSIONING_PASSPHRASE_MIN_SIZE: u32 = 6;
pub const OT_COMMISSIONING_PASSPHRASE_MAX_SIZE: u32 = 255;
pub const OT_PROVISIONING_URL_MAX_SIZE: u32 = 64;
pub const OT_STEERING_DATA_MAX_LENGTH: u32 = 16;
pub const OT_JOINER_MAX_PSKD_LENGTH: u32 = 32;
pub const OT_MAC_FILTER_FIXED_RSS_DISABLED: u32 = 127;
pub const OT_MAC_FILTER_ITERATOR_INIT: u32 = 0;
pub const OT_LINK_CSL_PERIOD_TEN_SYMBOLS_UNIT_IN_USEC: u32 = 160;
pub const OT_THREAD_VERSION_INVALID: u32 = 0;
pub const OT_THREAD_VERSION_1_1: u32 = 2;
pub const OT_THREAD_VERSION_1_2: u32 = 3;
pub const OT_THREAD_VERSION_1_3: u32 = 4;
pub const OT_THREAD_VERSION_1_3_1: u32 = 5;
pub const OT_THREAD_VERSION_1_4: u32 = 5;
pub const OT_NETWORK_BASE_TLV_MAX_LENGTH: u32 = 254;
pub const OT_NETWORK_MAX_ROUTER_ID: u32 = 62;
pub const OT_NEIGHBOR_INFO_ITERATOR_INIT: u32 = 0;
pub const OT_JOINER_ADVDATA_MAX_LENGTH: u32 = 64;
pub const OT_DURATION_STRING_SIZE: u32 = 21;
pub const OT_DNS_MAX_NAME_SIZE: u32 = 255;
pub const OT_DNS_MAX_LABEL_SIZE: u32 = 64;
pub const OT_DNS_TXT_KEY_MIN_LENGTH: u32 = 1;
pub const OT_DNS_TXT_KEY_MAX_LENGTH: u32 = 9;
pub const OT_DNS_TXT_KEY_ITER_MAX_LENGTH: u32 = 64;
pub const OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE: u32 = 1;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type wint_t = crate::c_types::c_uint;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type __blkcnt_t = crate::c_types::c_long;
pub type __blksize_t = crate::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::c_types::c_long;
pub type __pid_t = crate::c_types::c_int;
pub type __dev_t = crate::c_types::c_short;
pub type __uid_t = crate::c_types::c_ushort;
pub type __gid_t = crate::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::c_types::c_long;
pub type _fpos_t = crate::c_types::c_long;
pub type __size_t = crate::c_types::c_uint;
pub type _ssize_t = crate::c_types::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::c_types::c_void;
pub type __clock_t = crate::c_types::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = crate::c_types::c_ulong;
pub type __daddr_t = crate::c_types::c_long;
pub type __timer_t = crate::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::c_types::c_int;
pub type __nlink_t = crate::c_types::c_ushort;
pub type __suseconds_t = crate::c_types::c_long;
pub type __useconds_t = crate::c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::c_types::c_int,
    pub _maxwds: crate::c_types::c_int,
    pub _sign: crate::c_types::c_int,
    pub _wds: crate::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::c_types::c_int,
    pub __tm_min: crate::c_types::c_int,
    pub __tm_hour: crate::c_types::c_int,
    pub __tm_mday: crate::c_types::c_int,
    pub __tm_mon: crate::c_types::c_int,
    pub __tm_year: crate::c_types::c_int,
    pub __tm_wday: crate::c_types::c_int,
    pub __tm_yday: crate::c_types::c_int,
    pub __tm_isdst: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::c_types::c_uchar,
    pub _size: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *mut crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::c_types::c_uchar,
    pub _ur: crate::c_types::c_int,
    pub _ubuf: [crate::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::c_types::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::c_types::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::c_types::c_ushort; 3usize],
    pub _mult: [crate::c_types::c_ushort; 3usize],
    pub _add: crate::c_types::c_ushort,
    pub _rand_next: crate::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::c_types::c_char; 8usize],
    pub _getdate_err: crate::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: crate::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::c_types::c_int,
    pub _emergency: *mut crate::c_types::c_char,
    pub _reserved_0: crate::c_types::c_int,
    pub _reserved_1: crate::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::c_types::c_int,
    pub _cvtlen: crate::c_types::c_int,
    pub _cvtbuf: *mut crate::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::c_types::c_int)>,
    pub _reserved_6: *mut _atexit,
    pub _reserved_7: _atexit,
    pub _reserved_8: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::c_types::c_char,
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> crate::c_types::c_int,
        >,
        arg3: *mut _glue,
    ) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: crate::c_types::c_int,
    pub rem: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::c_types::c_long,
    pub rem: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::c_types::c_longlong,
    pub rem: crate::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::c_types::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::c_types::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::c_types::c_void,
        __base: *const crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn div(__numer: crate::c_types::c_int, __denom: crate::c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::c_types::c_char,
        arg2: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const *mut crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::c_types::c_long) -> crate::c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: crate::c_types::c_long, __denom: crate::c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::c_types::c_uint) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const crate::c_types::c_char, arg2: usize) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut crate::c_types::c_char, arg2: wchar_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const crate::c_types::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut crate::c_types::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut crate::c_types::c_void, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::c_types::c_char,
        resolved_path: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::c_types::c_long) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::c_types::c_long,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::c_types::c_int, arg2: *mut crate::c_types::c_void),
        >,
        __arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::c_types::c_uint) -> crate::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut crate::c_types::c_ushort) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::c_types::c_longlong) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::c_types::c_longlong,
        __denom: crate::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
        arg5: *mut crate::c_types::c_int,
        arg6: *mut crate::c_types::c_int,
        arg7: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut crate::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *const crate::c_types::c_void,
                arg3: *const crate::c_types::c_void,
            ) -> crate::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::c_types::c_char,
        arg2: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::c_types::c_int);
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
#[doc = " No error."]
pub const otError_OT_ERROR_NONE: otError = 0;
#[doc = " Operational failed."]
pub const otError_OT_ERROR_FAILED: otError = 1;
#[doc = " Message was dropped."]
pub const otError_OT_ERROR_DROP: otError = 2;
#[doc = " Insufficient buffers."]
pub const otError_OT_ERROR_NO_BUFS: otError = 3;
#[doc = " No route available."]
pub const otError_OT_ERROR_NO_ROUTE: otError = 4;
#[doc = " Service is busy and could not service the operation."]
pub const otError_OT_ERROR_BUSY: otError = 5;
#[doc = " Failed to parse message."]
pub const otError_OT_ERROR_PARSE: otError = 6;
#[doc = " Input arguments are invalid."]
pub const otError_OT_ERROR_INVALID_ARGS: otError = 7;
#[doc = " Security checks failed."]
pub const otError_OT_ERROR_SECURITY: otError = 8;
#[doc = " Address resolution requires an address query operation."]
pub const otError_OT_ERROR_ADDRESS_QUERY: otError = 9;
#[doc = " Address is not in the source match table."]
pub const otError_OT_ERROR_NO_ADDRESS: otError = 10;
#[doc = " Operation was aborted."]
pub const otError_OT_ERROR_ABORT: otError = 11;
#[doc = " Function or method is not implemented."]
pub const otError_OT_ERROR_NOT_IMPLEMENTED: otError = 12;
#[doc = " Cannot complete due to invalid state."]
pub const otError_OT_ERROR_INVALID_STATE: otError = 13;
#[doc = " No acknowledgment was received after macMaxFrameRetries (IEEE 802.15.4-2006)."]
pub const otError_OT_ERROR_NO_ACK: otError = 14;
#[doc = " A transmission could not take place due to activity on the channel, i.e., the CSMA-CA mechanism has failed\n (IEEE 802.15.4-2006)."]
pub const otError_OT_ERROR_CHANNEL_ACCESS_FAILURE: otError = 15;
#[doc = " Not currently attached to a Thread Partition."]
pub const otError_OT_ERROR_DETACHED: otError = 16;
#[doc = " FCS check failure while receiving."]
pub const otError_OT_ERROR_FCS: otError = 17;
#[doc = " No frame received."]
pub const otError_OT_ERROR_NO_FRAME_RECEIVED: otError = 18;
#[doc = " Received a frame from an unknown neighbor."]
pub const otError_OT_ERROR_UNKNOWN_NEIGHBOR: otError = 19;
#[doc = " Received a frame from an invalid source address."]
pub const otError_OT_ERROR_INVALID_SOURCE_ADDRESS: otError = 20;
#[doc = " Received a frame filtered by the address filter (allowlisted or denylisted)."]
pub const otError_OT_ERROR_ADDRESS_FILTERED: otError = 21;
#[doc = " Received a frame filtered by the destination address check."]
pub const otError_OT_ERROR_DESTINATION_ADDRESS_FILTERED: otError = 22;
#[doc = " The requested item could not be found."]
pub const otError_OT_ERROR_NOT_FOUND: otError = 23;
#[doc = " The operation is already in progress."]
pub const otError_OT_ERROR_ALREADY: otError = 24;
#[doc = " The creation of IPv6 address failed."]
pub const otError_OT_ERROR_IP6_ADDRESS_CREATION_FAILURE: otError = 26;
#[doc = " Operation prevented by mode flags"]
pub const otError_OT_ERROR_NOT_CAPABLE: otError = 27;
#[doc = " Coap response or acknowledgment or DNS, SNTP response not received."]
pub const otError_OT_ERROR_RESPONSE_TIMEOUT: otError = 28;
#[doc = " Received a duplicated frame."]
pub const otError_OT_ERROR_DUPLICATED: otError = 29;
#[doc = " Message is being dropped from reassembly list due to timeout."]
pub const otError_OT_ERROR_REASSEMBLY_TIMEOUT: otError = 30;
#[doc = " Message is not a TMF Message."]
pub const otError_OT_ERROR_NOT_TMF: otError = 31;
#[doc = " Received a non-lowpan data frame."]
pub const otError_OT_ERROR_NOT_LOWPAN_DATA_FRAME: otError = 32;
#[doc = " The link margin was too low."]
pub const otError_OT_ERROR_LINK_MARGIN_LOW: otError = 34;
#[doc = " Input (CLI) command is invalid."]
pub const otError_OT_ERROR_INVALID_COMMAND: otError = 35;
#[doc = " Special error code used to indicate success/error status is pending and not yet known.\n"]
pub const otError_OT_ERROR_PENDING: otError = 36;
#[doc = " Request rejected."]
pub const otError_OT_ERROR_REJECTED: otError = 37;
#[doc = " The number of defined errors."]
pub const otError_OT_NUM_ERRORS: otError = 38;
#[doc = " Generic error (should not use)."]
pub const otError_OT_ERROR_GENERIC: otError = 255;
#[doc = " Represents error codes used throughout OpenThread.\n"]
pub type otError = crate::c_types::c_uint;
extern "C" {
    #[doc = " Converts an otError enum into a string.\n\n @param[in]  aError     An otError enum.\n\n @returns  A string representation of an otError.\n"]
    pub fn otThreadErrorToString(aError: otError) -> *const crate::c_types::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " Represents the log level.\n"]
pub type otLogLevel = crate::c_types::c_int;
#[doc = "< OpenThread API"]
pub const otLogRegion_OT_LOG_REGION_API: otLogRegion = 1;
#[doc = "< MLE"]
pub const otLogRegion_OT_LOG_REGION_MLE: otLogRegion = 2;
#[doc = "< EID-to-RLOC mapping."]
pub const otLogRegion_OT_LOG_REGION_ARP: otLogRegion = 3;
#[doc = "< Network Data"]
pub const otLogRegion_OT_LOG_REGION_NET_DATA: otLogRegion = 4;
#[doc = "< ICMPv6"]
pub const otLogRegion_OT_LOG_REGION_ICMP: otLogRegion = 5;
#[doc = "< IPv6"]
pub const otLogRegion_OT_LOG_REGION_IP6: otLogRegion = 6;
#[doc = "< TCP"]
pub const otLogRegion_OT_LOG_REGION_TCP: otLogRegion = 7;
#[doc = "< IEEE 802.15.4 MAC"]
pub const otLogRegion_OT_LOG_REGION_MAC: otLogRegion = 8;
#[doc = "< Memory"]
pub const otLogRegion_OT_LOG_REGION_MEM: otLogRegion = 9;
#[doc = "< NCP"]
pub const otLogRegion_OT_LOG_REGION_NCP: otLogRegion = 10;
#[doc = "< Mesh Commissioning Protocol"]
pub const otLogRegion_OT_LOG_REGION_MESH_COP: otLogRegion = 11;
#[doc = "< Network Diagnostic"]
pub const otLogRegion_OT_LOG_REGION_NET_DIAG: otLogRegion = 12;
#[doc = "< Platform"]
pub const otLogRegion_OT_LOG_REGION_PLATFORM: otLogRegion = 13;
#[doc = "< CoAP"]
pub const otLogRegion_OT_LOG_REGION_COAP: otLogRegion = 14;
#[doc = "< CLI"]
pub const otLogRegion_OT_LOG_REGION_CLI: otLogRegion = 15;
#[doc = "< OpenThread Core"]
pub const otLogRegion_OT_LOG_REGION_CORE: otLogRegion = 16;
#[doc = "< Utility module"]
pub const otLogRegion_OT_LOG_REGION_UTIL: otLogRegion = 17;
#[doc = "< Backbone Router (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_BBR: otLogRegion = 18;
#[doc = "< Multicast Listener Registration (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_MLR: otLogRegion = 19;
#[doc = "< Domain Unicast Address (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_DUA: otLogRegion = 20;
#[doc = "< Border Router"]
pub const otLogRegion_OT_LOG_REGION_BR: otLogRegion = 21;
#[doc = "< Service Registration Protocol (SRP)"]
pub const otLogRegion_OT_LOG_REGION_SRP: otLogRegion = 22;
#[doc = "< DNS"]
pub const otLogRegion_OT_LOG_REGION_DNS: otLogRegion = 23;
#[doc = " Represents log regions.\n\n The support for log region is removed and instead each core module can define its own name to appended to the logs.\n However, the `otLogRegion` enumeration is still defined as before to help with platforms which we may be using it\n in their `otPlatLog()` implementation. The OT core will always emit all logs with `OT_LOG_REGION_CORE`.\n"]
pub type otLogRegion = crate::c_types::c_uint;
extern "C" {
    #[doc = " Outputs logs.\n\n Note that the support for log region is removed. The OT core will always emit all logs with `OT_LOG_REGION_CORE`\n as @p aLogRegion.\n\n @param[in]  aLogLevel   The log level.\n @param[in]  aLogRegion  The log region.\n @param[in]  aFormat     A pointer to the format string.\n @param[in]  ...         Arguments for the format specification.\n"]
    pub fn otPlatLog(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const crate::c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Handles OpenThread log level changes.\n\n This platform function is called whenever the OpenThread log level changes.\n This platform function is optional since an empty weak implementation has been provided.\n\n @note Only applicable when `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`.\n\n @param[in]  aLogLevel  The new OpenThread log level.\n"]
    pub fn otPlatLogHandleLevelChanged(aLogLevel: otLogLevel);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otInstance {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initializes the OpenThread library.\n\n Initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be\n called before any other calls to OpenThread.\n\n Is available and can only be used when support for multiple OpenThread instances is enabled.\n\n @param[in]     aInstanceBuffer      The buffer for OpenThread to use for allocating the otInstance structure.\n @param[in,out] aInstanceBufferSize  On input, the size of aInstanceBuffer. On output, if not enough space for\n                                     otInstance, the number of bytes required for otInstance.\n\n @returns  A pointer to the new OpenThread instance.\n\n @sa otInstanceFinalize\n"]
    pub fn otInstanceInit(
        aInstanceBuffer: *mut crate::c_types::c_void,
        aInstanceBufferSize: *mut usize,
    ) -> *mut otInstance;
}
extern "C" {
    #[doc = " Initializes the static single instance of the OpenThread library.\n\n Initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be\n called before any other calls to OpenThread.\n\n Is available and can only be used when support for multiple OpenThread instances is disabled.\n\n @returns A pointer to the single OpenThread instance.\n"]
    pub fn otInstanceInitSingle() -> *mut otInstance;
}
extern "C" {
    #[doc = " Initializes the OpenThread instance.\n\n This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be\n called before any other calls to OpenThread. This method utilizes static buffer to initialize the OpenThread\n instance.\n\n This function is available and can only be used when support for multiple OpenThread static instances is\n enabled (`OPENTHREAD_CONFIG_MULTIPLE_STATIC_INSTANCE_ENABLE`)\n\n @param[in] aIdx The index of the OpenThread instance to initialize.\n\n @returns  A pointer to the new OpenThread instance.\n"]
    pub fn otInstanceInitMultiple(aIdx: u8) -> *mut otInstance;
}
extern "C" {
    #[doc = " Gets the instance identifier.\n\n The instance identifier is set to a random value when the instance is constructed, and then its value will not\n change after initialization.\n\n @returns The instance identifier.\n"]
    pub fn otInstanceGetId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Indicates whether or not the instance is valid/initialized.\n\n The instance is considered valid if it is acquired and initialized using either `otInstanceInitSingle()` (in single\n instance case) or `otInstanceInit()` (in multi instance case). A subsequent call to `otInstanceFinalize()` causes\n the instance to be considered as uninitialized.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if the given instance is valid/initialized, FALSE otherwise.\n"]
    pub fn otInstanceIsInitialized(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Disables the OpenThread library.\n\n Call this function when OpenThread is no longer in use.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otInstanceFinalize(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Returns the current instance uptime (in msec).\n\n Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The uptime is given as number of milliseconds since OpenThread instance was initialized.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The uptime (number of milliseconds).\n"]
    pub fn otInstanceGetUptime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " Returns the current instance uptime as a human-readable string.\n\n Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The string follows the format \"<hh>:<mm>:<ss>.<mmmm>\" for hours, minutes, seconds and millisecond (if uptime is\n shorter than one day) or \"<dd>d.<hh>:<mm>:<ss>.<mmmm>\" (if longer than a day).\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[out] aBuffer   A pointer to a char array to output the string.\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_UPTIME_STRING_SIZE`.\n"]
    pub fn otInstanceGetUptimeAsString(
        aInstance: *mut otInstance,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
#[doc = " Represents a bit-field indicating specific state/configuration that has changed. See `OT_CHANGED_*`\n definitions.\n"]
pub type otChangedFlags = u32;
#[doc = " Pointer is called to notify certain configuration or state changes within OpenThread.\n\n @param[in]  aFlags    A bit-field indicating specific state that has changed.  See `OT_CHANGED_*` definitions.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otStateChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(aFlags: otChangedFlags, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Registers a callback to indicate when certain configuration or state changes within OpenThread.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called with certain configuration or state changes.\n @param[in]  aContext   A pointer to application-specific context.\n\n @retval OT_ERROR_NONE     Added the callback to the list of callbacks.\n @retval OT_ERROR_ALREADY  The callback was already registered.\n @retval OT_ERROR_NO_BUFS  Could not add the callback due to resource constraints.\n"]
    pub fn otSetStateChangedCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a callback to indicate when certain configuration or state changes within OpenThread.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aCallback   A pointer to a function that is called with certain configuration or state changes.\n @param[in]  aContext    A pointer to application-specific context.\n"]
    pub fn otRemoveStateChangeCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Triggers a platform reset.\n\n The reset process ensures that all the OpenThread state/info (stored in volatile memory) is erased. Note that the\n `otPlatformReset` does not erase any persistent state/info saved in non-volatile memory.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Triggers a platform reset to bootloader mode, if supported.\n\n Requires `OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE`.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE         Reset to bootloader successfully.\n @retval OT_ERROR_BUSY         Failed due to another operation is ongoing.\n @retval OT_ERROR_NOT_CAPABLE  Not capable of resetting to bootloader.\n"]
    pub fn otInstanceResetToBootloader(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Deletes all the settings stored on non-volatile memory, and then triggers a platform reset.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceFactoryReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Resets the internal states of the OpenThread radio stack.\n\n Callbacks and configurations are preserved.\n\n This API is only available under radio builds (`OPENTHREAD_RADIO = 1`).\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceResetRadioStack(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Erases all the OpenThread persistent info (network settings) stored on non-volatile memory.\n Erase is successful only if the device is in `disabled` state/role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           All persistent info/state was erased successfully.\n @retval OT_ERROR_INVALID_STATE  Device is not in `disabled` state/role.\n"]
    pub fn otInstanceErasePersistentInfo(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the OpenThread version string.\n\n @returns A pointer to the OpenThread version.\n"]
    pub fn otGetVersionString() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Gets the OpenThread radio version string.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the OpenThread radio version.\n"]
    pub fn otGetRadioVersionString(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessage {
    _unused: [u8; 0],
}
#[doc = "< Low priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_LOW: otMessagePriority = 0;
#[doc = "< Normal priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_NORMAL: otMessagePriority = 1;
#[doc = "< High priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_HIGH: otMessagePriority = 2;
#[doc = " Defines the OpenThread message priority levels.\n"]
pub type otMessagePriority = crate::c_types::c_uint;
#[doc = "< Message from Thread Netif."]
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_THREAD_NETIF: otMessageOrigin = 0;
#[doc = "< Message from a trusted source on host."]
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_HOST_TRUSTED: otMessageOrigin = 1;
#[doc = "< Message from an untrusted source on host."]
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_HOST_UNTRUSTED: otMessageOrigin = 2;
#[doc = " Defines the OpenThread message origins.\n"]
pub type otMessageOrigin = crate::c_types::c_uint;
#[doc = " Represents a message settings.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageSettings {
    #[doc = "< TRUE if the message should be secured at Layer 2."]
    pub mLinkSecurityEnabled: bool,
    #[doc = "< Priority level (MUST be a `OT_MESSAGE_PRIORITY_*` from `otMessagePriority`)."]
    pub mPriority: u8,
}
#[doc = " Represents link-specific information for messages received from the Thread radio.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otThreadLinkInfo {
    #[doc = "< Source PAN ID"]
    pub mPanId: u16,
    #[doc = "< 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< Received Signal Strength in dBm (averaged over fragments)"]
    pub mRss: i8,
    #[doc = "< Average Link Quality Indicator (averaged over fragments)"]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< The time sync sequence."]
    pub mTimeSyncSeq: u8,
    #[doc = "< The time offset to the Thread network time, in microseconds."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< Radio link type."]
    pub mRadioType: u8,
}
impl otThreadLinkInfo {
    #[inline]
    pub fn mLinkSecurity(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkSecurity(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDstPanIdBroadcast(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDstPanIdBroadcast(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkSecurity: bool,
        mIsDstPanIdBroadcast: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mLinkSecurity: u8 = unsafe { ::core::mem::transmute(mLinkSecurity) };
            mLinkSecurity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsDstPanIdBroadcast: u8 = unsafe { ::core::mem::transmute(mIsDstPanIdBroadcast) };
            mIsDstPanIdBroadcast as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Free an allocated message buffer.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageFree(aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Get the message length in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The message length in bytes.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n @sa otMessageSetLength\n"]
    pub fn otMessageGetLength(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message length in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aLength   A length in bytes.\n\n @retval OT_ERROR_NONE     Successfully set the message length.\n @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageSetLength(aMessage: *mut otMessage, aLength: u16) -> otError;
}
extern "C" {
    #[doc = " Get the message offset in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The message offset value.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageGetOffset(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message offset in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageSetOffset(aMessage: *mut otMessage, aOffset: u16);
}
extern "C" {
    #[doc = " Indicates whether or not link security is enabled for the message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @retval TRUE   If link security is enabled.\n @retval FALSE  If link security is not enabled.\n"]
    pub fn otMessageIsLinkSecurityEnabled(aMessage: *const otMessage) -> bool;
}
extern "C" {
    #[doc = " Indicates whether or not the message is allowed to be looped back to host.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @retval TRUE   If the message is allowed to be looped back to host.\n @retval FALSE  If the message is not allowed to be looped back to host.\n"]
    pub fn otMessageIsLoopbackToHostAllowed(aMessage: *const otMessage) -> bool;
}
extern "C" {
    #[doc = " Sets whether or not the message is allowed to be looped back to host.\n\n @param[in]  aMessage              A pointer to a message buffer.\n @param[in]  aAllowLoopbackToHost  Whether to allow the message to be looped back to host.\n"]
    pub fn otMessageSetLoopbackToHostAllowed(aMessage: *mut otMessage, aAllowLoopbackToHost: bool);
}
extern "C" {
    #[doc = " Indicates whether the given message may be looped back in a case of a multicast destination address.\n\n If @p aMessage is used along with an `otMessageInfo`, the `mMulticastLoop` field from `otMessageInfo` structure\n takes precedence and will be used instead of the the value set on @p aMessage.\n\n This API is mainly intended for use along with `otIp6Send()` which expects an already prepared IPv6 message.\n\n @param[in]  aMessage A pointer to the message.\n"]
    pub fn otMessageIsMulticastLoopEnabled(aMessage: *mut otMessage) -> bool;
}
extern "C" {
    #[doc = " Controls whether the given message may be looped back in a case of a multicast destination address.\n\n @param[in]  aMessage  A pointer to the message.\n @param[in]  aEnabled  The configuration value.\n"]
    pub fn otMessageSetMulticastLoopEnabled(aMessage: *mut otMessage, aEnabled: bool);
}
extern "C" {
    #[doc = " Gets the message origin.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The message origin.\n"]
    pub fn otMessageGetOrigin(aMessage: *const otMessage) -> otMessageOrigin;
}
extern "C" {
    #[doc = " Sets the message origin.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOrigin   The message origin.\n"]
    pub fn otMessageSetOrigin(aMessage: *mut otMessage, aOrigin: otMessageOrigin);
}
extern "C" {
    #[doc = " Sets/forces the message to be forwarded using direct transmission.\n Default setting for a new message is `false`.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aEnabled  If `true`, the message is forced to use direct transmission. If `false`, the message follows\n                       the normal procedure.\n"]
    pub fn otMessageSetDirectTransmission(aMessage: *mut otMessage, aEnabled: bool);
}
extern "C" {
    #[doc = " Returns the average RSS (received signal strength) associated with the message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The average RSS value (in dBm) or OT_RADIO_RSSI_INVALID if no average RSS is available.\n"]
    pub fn otMessageGetRss(aMessage: *const otMessage) -> i8;
}
extern "C" {
    #[doc = " Retrieves the link-specific information for a message received over Thread radio.\n\n @param[in] aMessage    The message from which to retrieve `otThreadLinkInfo`.\n @pram[out] aLinkInfo   A pointer to an `otThreadLinkInfo` to populate.\n\n @retval OT_ERROR_NONE       Successfully retrieved the link info, @p `aLinkInfo` is updated.\n @retval OT_ERROR_NOT_FOUND  Message origin is not `OT_MESSAGE_ORIGIN_THREAD_NETIF`.\n"]
    pub fn otMessageGetThreadLinkInfo(
        aMessage: *const otMessage,
        aLinkInfo: *mut otThreadLinkInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Append bytes to a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aBuf      A pointer to the data to append.\n @param[in]  aLength   Number of bytes to append.\n\n @retval OT_ERROR_NONE     Successfully appended to the message\n @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.\n\n @sa otMessageFree\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageAppend(
        aMessage: *mut otMessage,
        aBuf: *const crate::c_types::c_void,
        aLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Read bytes from a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n @param[in]  aBuf      A pointer to a buffer that message bytes are read to.\n @param[in]  aLength   Number of bytes to read.\n\n @returns The number of bytes read.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageWrite\n"]
    pub fn otMessageRead(
        aMessage: *const otMessage,
        aOffset: u16,
        aBuf: *mut crate::c_types::c_void,
        aLength: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Write bytes to a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n @param[in]  aBuf      A pointer to a buffer that message bytes are written from.\n @param[in]  aLength   Number of bytes to write.\n\n @returns The number of bytes written.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n"]
    pub fn otMessageWrite(
        aMessage: *mut otMessage,
        aOffset: u16,
        aBuf: *const crate::c_types::c_void,
        aLength: u16,
    ) -> crate::c_types::c_int;
}
#[doc = " Represents an OpenThread message queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageQueue {
    #[doc = "< Opaque data used by the implementation."]
    pub mData: *mut crate::c_types::c_void,
}
#[doc = " Represents information about a message queue.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageQueueInfo {
    #[doc = "< Number of messages in the queue."]
    pub mNumMessages: u16,
    #[doc = "< Number of data buffers used by messages in the queue."]
    pub mNumBuffers: u16,
    #[doc = "< Total number of bytes used by all messages in the queue."]
    pub mTotalBytes: u32,
}
#[doc = " Represents the message buffer information for different queues used by OpenThread stack.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBufferInfo {
    #[doc = "< The total number of buffers in the messages pool (0xffff if unknown)."]
    pub mTotalBuffers: u16,
    #[doc = "< The number of free buffers (0xffff if unknown)."]
    pub mFreeBuffers: u16,
    #[doc = " The maximum number of used buffers at the same time since OT stack initialization or last call to\n `otMessageResetBufferInfo()`.\n"]
    pub mMaxUsedBuffers: u16,
    #[doc = "< Info about 6LoWPAN send queue."]
    pub m6loSendQueue: otMessageQueueInfo,
    #[doc = "< Info about 6LoWPAN reassembly queue."]
    pub m6loReassemblyQueue: otMessageQueueInfo,
    #[doc = "< Info about IPv6 send queue."]
    pub mIp6Queue: otMessageQueueInfo,
    #[doc = "< Info about MPL send queue."]
    pub mMplQueue: otMessageQueueInfo,
    #[doc = "< Info about MLE delayed message queue."]
    pub mMleQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP/TMF send queue."]
    pub mCoapQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP secure send queue."]
    pub mCoapSecureQueue: otMessageQueueInfo,
    #[doc = "< Info about application CoAP send queue."]
    pub mApplicationCoapQueue: otMessageQueueInfo,
}
extern "C" {
    #[doc = " Initialize the message queue.\n\n MUST be called once and only once for a `otMessageQueue` instance before any other `otMessageQueue`\n functions. The behavior is undefined if other queue APIs are used with an `otMessageQueue` before it being\n initialized or if it is initialized more than once.\n\n @param[in]  aQueue     A pointer to a message queue.\n"]
    pub fn otMessageQueueInit(aQueue: *mut otMessageQueue);
}
extern "C" {
    #[doc = " Adds a message to the end of the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to add.\n"]
    pub fn otMessageQueueEnqueue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Adds a message at the head/front of the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to add.\n"]
    pub fn otMessageQueueEnqueueAtHead(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Removes a message from the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to remove.\n"]
    pub fn otMessageQueueDequeue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Returns a pointer to the message at the head of the queue.\n\n @param[in]  aQueue    A pointer to a message queue.\n\n @returns  A pointer to the message at the head of queue or NULL if queue is empty.\n"]
    pub fn otMessageQueueGetHead(aQueue: *mut otMessageQueue) -> *mut otMessage;
}
extern "C" {
    #[doc = " Returns a pointer to the next message in the queue by iterating forward (from head to tail).\n\n @param[in]  aQueue    A pointer to a message queue.\n @param[in]  aMessage  A pointer to current message buffer.\n\n @returns  A pointer to the next message in the queue after `aMessage` or NULL if `aMessage is the tail of queue.\n           NULL is returned if `aMessage` is not in the queue `aQueue`.\n"]
    pub fn otMessageQueueGetNext(
        aQueue: *mut otMessageQueue,
        aMessage: *const otMessage,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Get the Message Buffer information.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n @param[out]  aBufferInfo  A pointer where the message buffer information is written.\n"]
    pub fn otMessageGetBufferInfo(aInstance: *mut otInstance, aBufferInfo: *mut otBufferInfo);
}
extern "C" {
    #[doc = " Reset the Message Buffer information counter tracking the maximum number buffers in use at the same time.\n\n This resets `mMaxUsedBuffers` in `otBufferInfo`.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n"]
    pub fn otMessageResetBufferInfo(aInstance: *mut otInstance);
}
#[doc = "< Key Type: Raw Data."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_RAW: otCryptoKeyType = 0;
#[doc = "< Key Type: AES."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_AES: otCryptoKeyType = 1;
#[doc = "< Key Type: HMAC."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_HMAC: otCryptoKeyType = 2;
#[doc = "< Key Type: ECDSA."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_ECDSA: otCryptoKeyType = 3;
#[doc = " Defines the key types.\n"]
pub type otCryptoKeyType = crate::c_types::c_uint;
#[doc = "< Key Algorithm: Vendor Defined."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_VENDOR: otCryptoKeyAlgorithm = 0;
#[doc = "< Key Algorithm: AES ECB."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_AES_ECB: otCryptoKeyAlgorithm = 1;
#[doc = "< Key Algorithm: HMAC SHA-256."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_HMAC_SHA_256: otCryptoKeyAlgorithm = 2;
#[doc = "< Key Algorithm: ECDSA."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_ECDSA: otCryptoKeyAlgorithm = 3;
#[doc = " Defines the key algorithms.\n"]
pub type otCryptoKeyAlgorithm = crate::c_types::c_uint;
#[doc = "< Key Usage: Key Usage is empty."]
pub const OT_CRYPTO_KEY_USAGE_NONE: _bindgen_ty_1 = 0;
#[doc = "< Key Usage: Key can be exported."]
pub const OT_CRYPTO_KEY_USAGE_EXPORT: _bindgen_ty_1 = 1;
#[doc = "< Key Usage: Encryption (vendor defined)."]
pub const OT_CRYPTO_KEY_USAGE_ENCRYPT: _bindgen_ty_1 = 2;
#[doc = "< Key Usage: AES ECB."]
pub const OT_CRYPTO_KEY_USAGE_DECRYPT: _bindgen_ty_1 = 4;
#[doc = "< Key Usage: Sign Hash."]
pub const OT_CRYPTO_KEY_USAGE_SIGN_HASH: _bindgen_ty_1 = 8;
#[doc = "< Key Usage: Verify Hash."]
pub const OT_CRYPTO_KEY_USAGE_VERIFY_HASH: _bindgen_ty_1 = 16;
#[doc = " Defines the key usage flags.\n"]
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[doc = "< Key Persistence: Key is volatile."]
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_VOLATILE: otCryptoKeyStorage = 0;
#[doc = "< Key Persistence: Key is persistent."]
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_PERSISTENT: otCryptoKeyStorage = 1;
#[doc = " Defines the key storage types.\n"]
pub type otCryptoKeyStorage = crate::c_types::c_uint;
#[doc = " This datatype represents the key reference.\n"]
pub type otCryptoKeyRef = u32;
#[doc = " @struct otCryptoKey\n\n Represents the Key Material required for Crypto operations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoKey {
    #[doc = "< Pointer to the buffer containing key. NULL indicates to use `mKeyRef`."]
    pub mKey: *const u8,
    #[doc = "< The key length in bytes (applicable when `mKey` is not NULL)."]
    pub mKeyLength: u16,
    #[doc = "< The PSA key ref (requires `mKey` to be NULL)."]
    pub mKeyRef: u32,
}
#[doc = " @struct otCryptoContext\n\n Stores the context object for platform APIs.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoContext {
    #[doc = "< Pointer to the context."]
    pub mContext: *mut crate::c_types::c_void,
    #[doc = "< The length of the context in bytes."]
    pub mContextSize: u16,
}
#[doc = " @struct otPlatCryptoSha256Hash\n\n Represents a SHA-256 hash.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoSha256Hash {
    #[doc = "< Hash bytes."]
    pub m8: [u8; 32usize],
}
#[doc = " @struct otPlatCryptoEcdsaKeyPair\n\n Represents an ECDSA key pair (public and private keys).\n\n The key pair is stored using Distinguished Encoding Rules (DER) format (per RFC 5915).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaKeyPair {
    pub mDerBytes: [u8; 125usize],
    pub mDerLength: u8,
}
#[doc = " @struct otPlatCryptoEcdsaPublicKey\n\n Represents a ECDSA public key.\n\n The public key is stored as a byte sequence representation of an uncompressed curve point (RFC 6605 - sec 4).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaPublicKey {
    pub m8: [u8; 64usize],
}
#[doc = " @struct otPlatCryptoEcdsaSignature\n\n Represents an ECDSA signature.\n\n The signature is encoded as the concatenated binary representation of two MPIs `r` and `s` which are calculated\n during signing (RFC 6605 - section 4).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaSignature {
    pub m8: [u8; 64usize],
}
extern "C" {
    #[doc = " Initialize the Crypto module.\n"]
    pub fn otPlatCryptoInit();
}
extern "C" {
    #[doc = " Import a key into PSA ITS.\n\n @param[in,out] aKeyRef           Pointer to the key ref to be used for crypto operations.\n @param[in]     aKeyType          Key Type encoding for the key.\n @param[in]     aKeyAlgorithm     Key algorithm encoding for the key.\n @param[in]     aKeyUsage         Key Usage encoding for the key (combinations of `OT_CRYPTO_KEY_USAGE_*`).\n @param[in]     aKeyPersistence   Key Persistence for this key\n @param[in]     aKey              Actual key to be imported.\n @param[in]     aKeyLen           Length of the key to be imported.\n\n @retval OT_ERROR_NONE          Successfully imported the key.\n @retval OT_ERROR_FAILED        Failed to import the key.\n @retval OT_ERROR_INVALID_ARGS  @p aKey was set to NULL.\n\n @note If OT_CRYPTO_KEY_STORAGE_PERSISTENT is passed for aKeyPersistence then @p aKeyRef is input and platform\n       should use the given aKeyRef and MUST not change it.\n\n       If OT_CRYPTO_KEY_STORAGE_VOLATILE is passed for aKeyPersistence then @p aKeyRef is output, the initial\n       value does not matter and platform API MUST update it to return the new key ref.\n\n       This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoImportKey(
        aKeyRef: *mut otCryptoKeyRef,
        aKeyType: otCryptoKeyType,
        aKeyAlgorithm: otCryptoKeyAlgorithm,
        aKeyUsage: crate::c_types::c_int,
        aKeyPersistence: otCryptoKeyStorage,
        aKey: *const u8,
        aKeyLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Export a key stored in PSA ITS.\n\n @param[in]   aKeyRef           The key ref to be used for crypto operations.\n @param[out]  aBuffer           Pointer to the buffer where key needs to be exported.\n @param[in]   aBufferLen        Length of the buffer passed to store the exported key.\n @param[out]  aKeyLen           Pointer to return the length of the exported key.\n\n @retval OT_ERROR_NONE          Successfully exported  @p aKeyRef.\n @retval OT_ERROR_FAILED        Failed to export @p aKeyRef.\n @retval OT_ERROR_INVALID_ARGS  @p aBuffer was NULL\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoExportKey(
        aKeyRef: otCryptoKeyRef,
        aBuffer: *mut u8,
        aBufferLen: usize,
        aKeyLen: *mut usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Destroy a key stored in PSA ITS.\n\n @param[in]   aKeyRef          The key ref to be destroyed\n\n @retval OT_ERROR_NONE          Successfully destroyed the key.\n @retval OT_ERROR_FAILED        Failed to destroy the key.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoDestroyKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Check if the key ref passed has an associated key in PSA ITS.\n\n @param[in]  aKeyRef          The Key Ref to check.\n\n @retval TRUE                 There is an associated key with @p aKeyRef.\n @retval FALSE                There is no associated key with @p aKeyRef.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoHasKey(aKeyRef: otCryptoKeyRef) -> bool;
}
extern "C" {
    #[doc = " Initialize the HMAC operation.\n\n @param[in]  aContext          Context for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully initialized HMAC operation.\n @retval OT_ERROR_FAILED        Failed to initialize HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n @note The platform driver shall point the context to the correct object such as psa_mac_operation_t or\n       mbedtls_md_context_t.\n"]
    pub fn otPlatCryptoHmacSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HMAC operation.\n\n @param[in]  aContext          Context for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully uninitialized HMAC operation.\n @retval OT_ERROR_FAILED        Failed to uninitialized HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHmacSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start HMAC operation.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[in]  aKey               Key material to be used for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully started HMAC operation.\n @retval OT_ERROR_FAILED        Failed to start HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL\n"]
    pub fn otPlatCryptoHmacSha256Start(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Update the HMAC operation with new input.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[in]  aBuf               A pointer to the input buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully updated HMAC with new input operation.\n @retval OT_ERROR_FAILED        Failed to update HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoHmacSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const crate::c_types::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Complete the HMAC operation.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[out] aBuf               A pointer to the output buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully completed HMAC operation.\n @retval OT_ERROR_FAILED        Failed to complete HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoHmacSha256Finish(
        aContext: *mut otCryptoContext,
        aBuf: *mut u8,
        aBufLength: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialise the AES operation.\n\n @param[in]  aContext           Context for AES operation.\n\n @retval OT_ERROR_NONE          Successfully Initialised AES operation.\n @retval OT_ERROR_FAILED        Failed to Initialise AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n @retval OT_ERROR_NO_BUFS       Cannot allocate the context.\n\n @note The platform driver shall point the context to the correct object such as psa_key_id\n       or mbedtls_aes_context_t.\n"]
    pub fn otPlatCryptoAesInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Set the key for AES operation.\n\n @param[in]  aContext           Context for AES operation.\n @param[out] aKey               Key to use for AES operation.\n\n @retval OT_ERROR_NONE          Successfully set the key for AES operation.\n @retval OT_ERROR_FAILED        Failed to set the key for AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL\n"]
    pub fn otPlatCryptoAesSetKey(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Encrypt the given data.\n\n @param[in]  aContext           Context for AES operation.\n @param[in]  aInput             Pointer to the input buffer.\n @param[in]  aOutput            Pointer to the output buffer.\n\n @retval OT_ERROR_NONE          Successfully encrypted @p aInput.\n @retval OT_ERROR_FAILED        Failed to encrypt @p aInput.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey or @p aOutput were NULL\n"]
    pub fn otPlatCryptoAesEncrypt(
        aContext: *mut otCryptoContext,
        aInput: *const u8,
        aOutput: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Free the AES context.\n\n @param[in]  aContext           Context for AES operation.\n\n @retval OT_ERROR_NONE          Successfully freed AES context.\n @retval OT_ERROR_FAILED        Failed to free AES context.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoAesFree(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the HKDF context.\n\n @param[in]  aContext           Context for HKDF operation.\n\n @retval OT_ERROR_NONE          Successfully Initialised AES operation.\n @retval OT_ERROR_FAILED        Failed to Initialise AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n @note The platform driver shall point the context to the correct object such as psa_key_derivation_operation_t\n       or HmacSha256::Hash\n"]
    pub fn otPlatCryptoHkdfInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Expand step.\n\n @param[in]  aContext           Operation context for HKDF operation.\n @param[in]  aInfo              Pointer to the Info sequence.\n @param[in]  aInfoLength        Length of the Info sequence.\n @param[out] aOutputKey         Pointer to the output Key.\n @param[in]  aOutputKeyLength   Size of the output key buffer.\n\n @retval OT_ERROR_NONE          HKDF Expand was successful.\n @retval OT_ERROR_FAILED        HKDF Expand failed.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHkdfExpand(
        aContext: *mut otCryptoContext,
        aInfo: *const u8,
        aInfoLength: u16,
        aOutputKey: *mut u8,
        aOutputKeyLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Extract step.\n\n @param[in]  aContext           Operation context for HKDF operation.\n @param[in]  aSalt              Pointer to the Salt for HKDF.\n @param[in]  aSaltLength        Length of Salt.\n @param[in]  aInputKey          Pointer to the input key.\n\n @retval OT_ERROR_NONE          HKDF Extract was successful.\n @retval OT_ERROR_FAILED        HKDF Extract failed.\n"]
    pub fn otPlatCryptoHkdfExtract(
        aContext: *mut otCryptoContext,
        aSalt: *const u8,
        aSaltLength: u16,
        aInputKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HKDF context.\n\n @param[in]  aContext           Context for HKDF operation.\n\n @retval OT_ERROR_NONE          Successfully un-initialised HKDF operation.\n @retval OT_ERROR_FAILED        Failed to un-initialised HKDF operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHkdfDeinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully initialised SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to initialise SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n\n @note The platform driver shall point the context to the correct object such as psa_hash_operation_t\n       or mbedtls_sha256_context."]
    pub fn otPlatCryptoSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully un-initialised SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to un-initialised SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully started SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to start SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoSha256Start(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Update SHA-256 operation with new input.\n\n @param[in]  aContext           Context for SHA-256 operation.\n @param[in]  aBuf               A pointer to the input buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully updated SHA-256 with new input operation.\n @retval OT_ERROR_FAILED        Failed to update SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const crate::c_types::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Finish SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n @param[in]  aHash              A pointer to the output buffer, where hash needs to be stored.\n @param[in]  aHashSize          The length of @p aHash in bytes.\n\n @retval OT_ERROR_NONE          Successfully completed the SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to complete SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aHash was NULL\n"]
    pub fn otPlatCryptoSha256Finish(
        aContext: *mut otCryptoContext,
        aHash: *mut u8,
        aHashSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialize cryptographically-secure pseudorandom number generator (CSPRNG).\n"]
    pub fn otPlatCryptoRandomInit();
}
extern "C" {
    #[doc = " Deinitialize cryptographically-secure pseudorandom number generator (CSPRNG).\n"]
    pub fn otPlatCryptoRandomDeinit();
}
extern "C" {
    #[doc = " Fills a given buffer with cryptographically secure random bytes.\n\n @param[out] aBuffer            A pointer to a buffer to fill with the random bytes.\n @param[in]  aSize              Size of buffer (number of bytes to fill).\n\n @retval OT_ERROR_NONE          Successfully filled buffer with random values.\n @retval OT_ERROR_FAILED        Operation failed.\n"]
    pub fn otPlatCryptoRandomGet(aBuffer: *mut u8, aSize: u16) -> otError;
}
extern "C" {
    #[doc = " Generate and populate the output buffer with a new ECDSA key-pair.\n\n @param[out] aKeyPair           A pointer to an ECDSA key-pair structure to store the generated key-pair.\n\n @retval OT_ERROR_NONE          A new key-pair was generated successfully.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.\n @retval OT_ERROR_NOT_CAPABLE   Feature not supported.\n @retval OT_ERROR_FAILED        Failed to generate key-pair.\n"]
    pub fn otPlatCryptoEcdsaGenerateKey(aKeyPair: *mut otPlatCryptoEcdsaKeyPair) -> otError;
}
extern "C" {
    #[doc = " Get the associated public key from the input context.\n\n @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.\n @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.\n\n @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n"]
    pub fn otPlatCryptoEcdsaGetPublicKey(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Calculate the ECDSA signature for a hashed message using the private key from the input context.\n\n Uses the deterministic digital signature generation procedure from RFC 6979.\n\n @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation\n                                is stored.\n @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.\n\n @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n"]
    pub fn otPlatCryptoEcdsaSign(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Use the key from the input context to verify the ECDSA signature of a hashed message.\n\n @param[in]  aPublicKey         A pointer to an ECDSA public key structure where the public key for signature\n                                verification is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification\n                                is stored.\n @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is\n                                stored.\n\n @retval OT_ERROR_NONE          The signature was verified successfully.\n @retval OT_ERROR_SECURITY      The signature is invalid.\n @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.\n"]
    pub fn otPlatCryptoEcdsaVerify(
        aPublicKey: *const otPlatCryptoEcdsaPublicKey,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Calculate the ECDSA signature for a hashed message using the Key reference passed.\n\n Uses the deterministic digital signature generation procedure from RFC 6979.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation\n                                is stored.\n @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.\n\n @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaSignUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the associated public key from the key reference passed.\n\n The public key is stored differently depending on the crypto backend library being used\n (OPENTHREAD_CONFIG_CRYPTO_LIB).\n\n This API must make sure to return the public key as a byte sequence representation of an\n uncompressed curve point (RFC 6605 - sec 4)\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.\n\n @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaExportPublicKey(
        aKeyRef: otCryptoKeyRef,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Generate and import a new ECDSA key-pair at reference passed.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n\n @retval OT_ERROR_NONE          A new key-pair was generated successfully.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.\n @retval OT_ERROR_NOT_CAPABLE   Feature not supported.\n @retval OT_ERROR_FAILED        Failed to generate key-pair.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaGenerateAndImportKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Use the keyref to verify the ECDSA signature of a hashed message.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification\n                                is stored.\n @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is\n                                stored.\n\n @retval OT_ERROR_NONE          The signature was verified successfully.\n @retval OT_ERROR_SECURITY      The signature is invalid.\n @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaVerifyUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform PKCS#5 PBKDF2 using CMAC (AES-CMAC-PRF-128).\n\n @param[in]     aPassword          Password to use when generating key.\n @param[in]     aPasswordLen       Length of password.\n @param[in]     aSalt              Salt to use when generating key.\n @param[in]     aSaltLen           Length of salt.\n @param[in]     aIterationCounter  Iteration count.\n @param[in]     aKeyLen            Length of generated key in bytes.\n @param[out]    aKey               A pointer to the generated key.\n\n @retval OT_ERROR_NONE          A new key-pair was generated successfully.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.\n @retval OT_ERROR_NOT_CAPABLE   Feature not supported.\n @retval OT_ERROR_FAILED        Failed to generate key."]
    pub fn otPlatCryptoPbkdf2GenerateKey(
        aPassword: *const u8,
        aPasswordLen: u16,
        aSalt: *const u8,
        aSaltLen: u16,
        aIterationCounter: u32,
        aKeyLen: u16,
        aKey: *mut u8,
    ) -> otError;
}
#[doc = "< aMaxPHYPacketSize (IEEE 802.15.4-2006)"]
pub const OT_RADIO_FRAME_MAX_SIZE: _bindgen_ty_2 = 127;
#[doc = "< Minimal size of frame FCS + CONTROL"]
pub const OT_RADIO_FRAME_MIN_SIZE: _bindgen_ty_2 = 3;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_SYMBOLS_PER_OCTET: _bindgen_ty_2 = 2;
#[doc = "< 2.4 GHz IEEE 802.15.4 (bits per second)"]
pub const OT_RADIO_BIT_RATE: _bindgen_ty_2 = 250000;
#[doc = "< Number of bits per octet"]
pub const OT_RADIO_BITS_PER_OCTET: _bindgen_ty_2 = 8;
#[doc = "< The O-QPSK PHY symbol rate when operating in the 780MHz, 915MHz, 2380MHz, 2450MHz"]
pub const OT_RADIO_SYMBOL_RATE: _bindgen_ty_2 = 62500;
#[doc = "< Symbol duration time in unit of microseconds"]
pub const OT_RADIO_SYMBOL_TIME: _bindgen_ty_2 = 16;
#[doc = "< Time for 10 symbols in unit of microseconds"]
pub const OT_RADIO_TEN_SYMBOLS_TIME: _bindgen_ty_2 = 160;
#[doc = "< LQI measurement not supported"]
pub const OT_RADIO_LQI_NONE: _bindgen_ty_2 = 0;
#[doc = "< Invalid or unknown RSSI value"]
pub const OT_RADIO_RSSI_INVALID: _bindgen_ty_2 = 127;
#[doc = "< Invalid or unknown power value"]
pub const OT_RADIO_POWER_INVALID: _bindgen_ty_2 = 127;
#[doc = " @defgroup radio-types Radio Types\n\n @brief\n   This module includes the platform abstraction for a radio frame.\n\n @{\n"]
pub type _bindgen_ty_2 = crate::c_types::c_uint;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0: _bindgen_ty_3 = 0;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0_MASK: _bindgen_ty_3 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2: _bindgen_ty_3 = 2;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2_MASK: _bindgen_ty_3 = 4;
#[doc = " Defines the channel page.\n"]
pub type _bindgen_ty_3 = crate::c_types::c_uint;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_4 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_4 = 10;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_4 = 2046;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_4 = 11;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_4 = 26;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_4 = 134215680;
#[doc = " Defines the frequency band channel range.\n"]
pub type _bindgen_ty_4 = crate::c_types::c_uint;
#[doc = " Represents radio capabilities.\n\n The value is a bit-field indicating the capabilities supported by the radio. See `OT_RADIO_CAPS_*` definitions.\n"]
pub type otRadioCaps = u16;
#[doc = "< Radio supports no capability."]
pub const OT_RADIO_CAPS_NONE: _bindgen_ty_5 = 0;
#[doc = "< Radio supports AckTime event."]
pub const OT_RADIO_CAPS_ACK_TIMEOUT: _bindgen_ty_5 = 1;
#[doc = "< Radio supports Energy Scans."]
pub const OT_RADIO_CAPS_ENERGY_SCAN: _bindgen_ty_5 = 2;
#[doc = "< Radio supports tx retry logic with collision avoidance (CSMA)."]
pub const OT_RADIO_CAPS_TRANSMIT_RETRIES: _bindgen_ty_5 = 4;
#[doc = "< Radio supports CSMA backoff for frame transmission (but no retry)."]
pub const OT_RADIO_CAPS_CSMA_BACKOFF: _bindgen_ty_5 = 8;
#[doc = "< Radio supports direct transition from sleep to TX with CSMA."]
pub const OT_RADIO_CAPS_SLEEP_TO_TX: _bindgen_ty_5 = 16;
#[doc = "< Radio supports tx security."]
pub const OT_RADIO_CAPS_TRANSMIT_SEC: _bindgen_ty_5 = 32;
#[doc = "< Radio supports tx at specific time."]
pub const OT_RADIO_CAPS_TRANSMIT_TIMING: _bindgen_ty_5 = 64;
#[doc = "< Radio supports rx at specific time."]
pub const OT_RADIO_CAPS_RECEIVE_TIMING: _bindgen_ty_5 = 128;
#[doc = "< Radio supports RxOnWhenIdle handling."]
pub const OT_RADIO_CAPS_RX_ON_WHEN_IDLE: _bindgen_ty_5 = 256;
#[doc = "< Radio supports setting per-frame transmit power."]
pub const OT_RADIO_CAPS_TRANSMIT_FRAME_POWER: _bindgen_ty_5 = 512;
#[doc = " Defines constants that are used to indicate different radio capabilities. See `otRadioCaps`.\n"]
pub type _bindgen_ty_5 = crate::c_types::c_uint;
#[doc = " Represents the IEEE 802.15.4 PAN ID.\n"]
pub type otPanId = u16;
#[doc = " Represents the IEEE 802.15.4 Short Address.\n"]
pub type otShortAddress = u16;
#[doc = "< Size of IE header in bytes."]
pub const OT_IE_HEADER_SIZE: _bindgen_ty_6 = 2;
#[doc = "< Size of CSL IE content in bytes."]
pub const OT_CSL_IE_SIZE: _bindgen_ty_6 = 4;
#[doc = "< Max length for header IE in ACK."]
pub const OT_ACK_IE_MAX_SIZE: _bindgen_ty_6 = 16;
#[doc = "< Max length of Link Metrics data in Vendor-Specific IE."]
pub const OT_ENH_PROBING_IE_DATA_MAX_SIZE: _bindgen_ty_6 = 2;
#[doc = " Defines constants about size of header IE in ACK.\n"]
pub type _bindgen_ty_6 = crate::c_types::c_uint;
#[doc = " @struct otExtAddress\n\n Represents the IEEE 802.15.4 Extended Address.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otExtAddress {
    #[doc = "< IEEE 802.15.4 Extended Address bytes"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otMacKey\n\n Represents a MAC Key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otMacKey {
    #[doc = "< MAC Key bytes."]
    pub m8: [u8; 16usize],
}
#[doc = " Represents a MAC Key Ref used by PSA.\n"]
pub type otMacKeyRef = otCryptoKeyRef;
#[doc = " @struct otMacKeyMaterial\n\n Represents a MAC Key.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacKeyMaterial {
    pub mKeyMaterial: otMacKeyMaterial__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otMacKeyMaterial__bindgen_ty_1 {
    #[doc = "< Reference to the key stored."]
    pub mKeyRef: otMacKeyRef,
    #[doc = "< Key stored as literal."]
    pub mKey: otMacKey,
}
#[doc = "< Use Literal Keys."]
pub const otRadioKeyType_OT_KEY_TYPE_LITERAL_KEY: otRadioKeyType = 0;
#[doc = "< Use Reference to Key."]
pub const otRadioKeyType_OT_KEY_TYPE_KEY_REF: otRadioKeyType = 1;
#[doc = " Defines constants about key types.\n"]
pub type otRadioKeyType = crate::c_types::c_uint;
#[doc = " Represents the IEEE 802.15.4 Header IE (Information Element) related information of a radio frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioIeInfo {
    #[doc = "< The time offset to the Thread network time."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< The Time IE offset from the start of PSDU."]
    pub mTimeIeOffset: u8,
    #[doc = "< The Time sync sequence."]
    pub mTimeSyncSeq: u8,
}
#[doc = " Represents an IEEE 802.15.4 radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame {
    #[doc = "< The PSDU."]
    pub mPsdu: *mut u8,
    #[doc = "< Length of the PSDU."]
    pub mLength: u16,
    #[doc = "< Channel used to transmit/receive the frame."]
    pub mChannel: u8,
    #[doc = "< Radio link type - should be ignored by radio driver."]
    pub mRadioType: u8,
    pub mInfo: otRadioFrame__bindgen_ty_1,
}
#[doc = " The union of transmit and receive information for a radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union otRadioFrame__bindgen_ty_1 {
    pub mTxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_1,
    pub mRxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Structure representing radio frame transmit information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The key material used for AES-CCM frame security."]
    pub mAesKey: *const otMacKeyMaterial,
    #[doc = "< The pointer to the Header IE(s) related information."]
    pub mIeInfo: *mut otRadioIeInfo,
    #[doc = " The base time in microseconds for scheduled transmissions\n relative to the local radio clock, see `otPlatRadioGetNow` and\n `mTxDelay`."]
    pub mTxDelayBaseTime: u32,
    #[doc = " The delay time in microseconds for this transmission referenced\n to `mTxDelayBaseTime`.\n\n Note: `mTxDelayBaseTime` + `mTxDelay` SHALL point to the point in\n time when the end of the SFD will be present at the local\n antenna, relative to the local radio clock."]
    pub mTxDelay: u32,
    #[doc = "< Maximum number of backoffs attempts before declaring CCA failure."]
    pub mMaxCsmaBackoffs: u8,
    #[doc = "< Maximum number of retries allowed after a transmission failure."]
    pub mMaxFrameRetries: u8,
    #[doc = " The RX channel after frame TX is done (after all frame retries - ack received, or timeout, or abort).\n\n Radio platforms can choose to fully ignore this. OT stack will make sure to call `otPlatRadioReceive()`\n with the desired RX channel after a frame TX is done and signaled in `otPlatRadioTxDone()` callback.\n Radio platforms that don't provide `OT_RADIO_CAPS_TRANSMIT_RETRIES` must always ignore this.\n\n This is intended for situations where there may be delay in interactions between OT stack and radio, as\n an example this is used in RCP/host architecture to make sure RCP switches to PAN channel more quickly.\n In particular, this can help with CSL tx to a sleepy child, where the child may use a different channel\n for CSL than the PAN channel. After frame tx, we want the radio/RCP to go back to the PAN channel\n quickly to ensure that parent does not miss tx from child afterwards, e.g., child responding to the\n earlier CSL transmitted frame from parent using PAN channel while radio still staying on CSL channel.\n\n The switch to the RX channel MUST happen after the frame TX is fully done, i.e., after all retries and\n when ack is received (when \"Ack Request\" flag is set on the TX frame) or ack timeout. Note that ack is\n expected on the same channel that frame is sent on.\n"]
    pub mRxChannelAfterTxDone: u8,
    #[doc = " The transmit power in dBm.\n\n If the platform layer does not provide `OT_RADIO_CAPS_TRANSMIT_FRAME_POWER` capability, it can ignore\n this value.\n\n If the value is OT_RADIO_POWER_INVALID, then the platform should ignore this value and transmit the frame\n with its default transmit power.\n\n Otherwise, the platform should transmit this frame with the maximum power no larger than minimal of the\n following values:\n     1. mTxPower,\n     2. The power limit set by otPlatRadioSetChannelTargetPower(),\n     3. The power limit set by otPlatRadioSetChannelMaxTransmitPower(),\n     4. The power limit set by otPlatRadioSetRegion().\n"]
    pub mTxPower: i8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mIsHeaderUpdated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHeaderUpdated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsARetx(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsARetx(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCsmaCaEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCsmaCaEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCslPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCslPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityProcessed(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityProcessed(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsHeaderUpdated: bool,
        mIsARetx: bool,
        mCsmaCaEnabled: bool,
        mCslPresent: bool,
        mIsSecurityProcessed: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsHeaderUpdated: u8 = unsafe { ::core::mem::transmute(mIsHeaderUpdated) };
            mIsHeaderUpdated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsARetx: u8 = unsafe { ::core::mem::transmute(mIsARetx) };
            mIsARetx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mCsmaCaEnabled: u8 = unsafe { ::core::mem::transmute(mCsmaCaEnabled) };
            mCsmaCaEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mCslPresent: u8 = unsafe { ::core::mem::transmute(mCslPresent) };
            mCslPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsSecurityProcessed: u8 = unsafe { ::core::mem::transmute(mIsSecurityProcessed) };
            mIsSecurityProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure representing radio frame receive information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The time of the local radio clock in microseconds when the end of\n the SFD was present at the local antenna."]
    pub mTimestamp: u64,
    #[doc = "< ACK security frame counter (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckFrameCounter: u32,
    #[doc = "< ACK security key index (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckKeyId: u8,
    #[doc = "< Received signal strength indicator in dBm for received frames."]
    pub mRssi: i8,
    #[doc = "< Link Quality Indicator for received frames."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn mAckedWithFramePending(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithFramePending(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAckedWithSecEnhAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithSecEnhAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAckedWithFramePending: bool,
        mAckedWithSecEnhAck: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAckedWithFramePending: u8 =
                unsafe { ::core::mem::transmute(mAckedWithFramePending) };
            mAckedWithFramePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mAckedWithSecEnhAck: u8 = unsafe { ::core::mem::transmute(mAckedWithSecEnhAck) };
            mAckedWithSecEnhAck as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const otRadioState_OT_RADIO_STATE_DISABLED: otRadioState = 0;
pub const otRadioState_OT_RADIO_STATE_SLEEP: otRadioState = 1;
pub const otRadioState_OT_RADIO_STATE_RECEIVE: otRadioState = 2;
pub const otRadioState_OT_RADIO_STATE_TRANSMIT: otRadioState = 3;
pub const otRadioState_OT_RADIO_STATE_INVALID: otRadioState = 255;
#[doc = " Represents the state of a radio.\n Initially, a radio is in the Disabled state."]
pub type otRadioState = crate::c_types::c_uint;
#[doc = " Represents radio coexistence metrics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioCoexMetrics {
    #[doc = "< Number of grant glitches."]
    pub mNumGrantGlitch: u32,
    #[doc = "< Number of tx requests."]
    pub mNumTxRequest: u32,
    #[doc = "< Number of tx requests while grant was active."]
    pub mNumTxGrantImmediate: u32,
    #[doc = "< Number of tx requests while grant was inactive."]
    pub mNumTxGrantWait: u32,
    #[doc = "< Number of tx requests while grant was inactive that were ultimately granted."]
    pub mNumTxGrantWaitActivated: u32,
    #[doc = "< Number of tx requests while grant was inactive that timed out."]
    pub mNumTxGrantWaitTimeout: u32,
    #[doc = "< Number of tx that were in progress when grant was deactivated."]
    pub mNumTxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of tx requests that were not granted within 50us."]
    pub mNumTxDelayedGrant: u32,
    #[doc = "< Average time in usec from tx request to grant."]
    pub mAvgTxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests."]
    pub mNumRxRequest: u32,
    #[doc = "< Number of rx requests while grant was active."]
    pub mNumRxGrantImmediate: u32,
    #[doc = "< Number of rx requests while grant was inactive."]
    pub mNumRxGrantWait: u32,
    #[doc = "< Number of rx requests while grant was inactive that were ultimately granted."]
    pub mNumRxGrantWaitActivated: u32,
    #[doc = "< Number of rx requests while grant was inactive that timed out."]
    pub mNumRxGrantWaitTimeout: u32,
    #[doc = "< Number of rx that were in progress when grant was deactivated."]
    pub mNumRxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of rx requests that were not granted within 50us."]
    pub mNumRxDelayedGrant: u32,
    #[doc = "< Average time in usec from rx request to grant."]
    pub mAvgRxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests that completed without receiving grant."]
    pub mNumRxGrantNone: u32,
    #[doc = "< Stats collection stopped due to saturation."]
    pub mStopped: bool,
}
#[doc = " Represents what metrics are specified to query.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otLinkMetrics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkMetrics {
    #[inline]
    pub fn mPduCount(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPduCount(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLqi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLqi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkMargin(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkMargin(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRssi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRssi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mReserved(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mReserved(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPduCount: bool,
        mLqi: bool,
        mLinkMargin: bool,
        mRssi: bool,
        mReserved: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPduCount: u8 = unsafe { ::core::mem::transmute(mPduCount) };
            mPduCount as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLqi: u8 = unsafe { ::core::mem::transmute(mLqi) };
            mLqi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mLinkMargin: u8 = unsafe { ::core::mem::transmute(mLinkMargin) };
            mLinkMargin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRssi: u8 = unsafe { ::core::mem::transmute(mRssi) };
            mRssi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mReserved: u8 = unsafe { ::core::mem::transmute(mReserved) };
            mReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the radio capabilities.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The radio capability bit vector (see `OT_RADIO_CAP_*` definitions).\n"]
    pub fn otPlatRadioGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
extern "C" {
    #[doc = " Get the radio version string.\n\n This is an optional radio driver platform function. If not provided by platform radio driver, OpenThread uses\n the OpenThread version instead (@sa otGetVersionString()).\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns A pointer to the OpenThread radio version.\n"]
    pub fn otPlatRadioGetVersionString(aInstance: *mut otInstance)
        -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Get the radio receive sensitivity value.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The radio receive sensitivity value in dBm.\n"]
    pub fn otPlatRadioGetReceiveSensitivity(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Gets the factory-assigned IEEE EUI-64 for this interface.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.\n"]
    pub fn otPlatRadioGetIeeeEui64(aInstance: *mut otInstance, aIeeeEui64: *mut u8);
}
extern "C" {
    #[doc = " Set the PAN ID for address filtering.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aPanId     The IEEE 802.15.4 PAN ID.\n"]
    pub fn otPlatRadioSetPanId(aInstance: *mut otInstance, aPanId: otPanId);
}
extern "C" {
    #[doc = " Set the Extended Address for address filtering.\n\n @param[in] aInstance    The OpenThread instance structure.\n @param[in] aExtAddress  A pointer to the IEEE 802.15.4 Extended Address stored in little-endian byte order.\n\n"]
    pub fn otPlatRadioSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    );
}
extern "C" {
    #[doc = " Set the Short Address for address filtering.\n\n @param[in] aInstance      The OpenThread instance structure.\n @param[in] aShortAddress  The IEEE 802.15.4 Short Address.\n"]
    pub fn otPlatRadioSetShortAddress(aInstance: *mut otInstance, aShortAddress: otShortAddress);
}
extern "C" {
    #[doc = " Get the radio's transmit power in dBm.\n\n @note The transmit power returned will be no larger than the power specified in the max power table for\n the current channel.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[out] aPower    The transmit power in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the transmit power.\n @retval OT_ERROR_INVALID_ARGS     @p aPower was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioGetTransmitPower(aInstance: *mut otInstance, aPower: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Set the radio's transmit power in dBm.\n\n @note The real transmit power will be no larger than the power specified in the max power table for\n the current channel.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aPower     The transmit power in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the transmit power.\n @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioSetTransmitPower(aInstance: *mut otInstance, aPower: i8) -> otError;
}
extern "C" {
    #[doc = " Get the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.\n\n @param[in] aInstance    The OpenThread instance structure.\n @param[out] aThreshold  The CCA ED threshold in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the CCA ED threshold.\n @retval OT_ERROR_INVALID_ARGS     @p aThreshold was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioGetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.\n\n @param[in] aInstance   The OpenThread instance structure.\n @param[in] aThreshold  The CCA ED threshold in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the transmit power.\n @retval OT_ERROR_INVALID_ARGS     Given threshold is out of range.\n @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioSetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the external FEM's Rx LNA gain in dBm.\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[out] aGain     The external FEM's Rx LNA gain in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the external FEM's LNA gain.\n @retval OT_ERROR_INVALID_ARGS     @p aGain was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA setting is not implemented.\n"]
    pub fn otPlatRadioGetFemLnaGain(aInstance: *mut otInstance, aGain: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Sets the external FEM's Rx LNA gain in dBm.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aGain      The external FEM's Rx LNA gain in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the external FEM's LNA gain.\n @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA gain setting is not implemented.\n"]
    pub fn otPlatRadioSetFemLnaGain(aInstance: *mut otInstance, aGain: i8) -> otError;
}
extern "C" {
    #[doc = " Get the status of promiscuous mode.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval TRUE   Promiscuous mode is enabled.\n @retval FALSE  Promiscuous mode is disabled.\n"]
    pub fn otPlatRadioGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enable or disable promiscuous mode.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aEnable   TRUE to enable or FALSE to disable promiscuous mode.\n"]
    pub fn otPlatRadioSetPromiscuous(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Sets the rx-on-when-idle state to the radio platform.\n\n There are a few situations that the radio can enter sleep state if the device is in rx-off-when-idle state but\n it's hard and costly for the SubMac to identify these situations and instruct the radio to enter sleep:\n\n - Finalization of a regular frame reception task, provided that:\n   - The frame is received without errors and passes the filtering and it's not an spurious ACK.\n   - ACK is not requested or transmission of ACK is not possible due to internal conditions.\n - Finalization of a frame transmission or transmission of an ACK frame, when ACK is not requested in the transmitted\n   frame.\n - Finalization of the reception operation of a requested ACK due to:\n   - ACK timeout expiration.\n   - Reception of an invalid ACK or not an ACK frame.\n   - Reception of the proper ACK, unless the transmitted frame was a Data Request Command and the frame pending bit\n     on the received ACK is set to true. In this case the radio platform implementation SHOULD keep the receiver on\n     until a determined timeout which triggers an idle period start.`OPENTHREAD_CONFIG_MAC_DATA_POLL_TIMEOUT` can be\n     taken as a reference for this.\n - Finalization of a stand alone CCA task.\n - Finalization of a CCA operation with busy result during CSMA/CA procedure.\n - Finalization of an Energy Detection task.\n - Finalization of a radio reception window scheduled with `otPlatRadioReceiveAt`.\n\n If a platform supports `OT_RADIO_CAPS_RX_ON_WHEN_IDLE` it must also support `OT_RADIO_CAPS_CSMA_BACKOFF` and handle\n idle periods after CCA as described above.\n\n Upon the transition of the \"RxOnWhenIdle\" flag from TRUE to FALSE, the radio platform should enter sleep mode.\n If the radio is currently in receive mode, it should enter sleep mode immediately. Otherwise, it should enter sleep\n mode after the current operation is completed.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aEnable      TRUE to keep radio in Receive state, FALSE to put to Sleep state during idle periods.\n"]
    pub fn otPlatRadioSetRxOnWhenIdle(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Update MAC keys and key index\n\n Is used when radio provides OT_RADIO_CAPS_TRANSMIT_SEC capability.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aKeyIdMode   The key ID mode.\n @param[in]   aKeyId       Current MAC key index.\n @param[in]   aPrevKey     A pointer to the previous MAC key.\n @param[in]   aCurrKey     A pointer to the current MAC key.\n @param[in]   aNextKey     A pointer to the next MAC key.\n @param[in]   aKeyType     Key Type used.\n"]
    pub fn otPlatRadioSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKeyMaterial,
        aCurrKey: *const otMacKeyMaterial,
        aNextKey: *const otMacKeyMaterial,
        aKeyType: otRadioKeyType,
    );
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value.\n\n Is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n"]
    pub fn otPlatRadioSetMacFrameCounter(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value only if the new given value is larger than the current value.\n\n Is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n"]
    pub fn otPlatRadioSetMacFrameCounterIfLarger(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " Get the current time in microseconds referenced to a continuous monotonic\n local radio clock (64 bits width).\n\n The radio clock SHALL NOT wrap during the device's uptime. Implementations\n SHALL therefore identify and compensate for internal counter overflows. The\n clock does not have a defined epoch and it SHALL NOT introduce any continuous\n or discontinuous adjustments (e.g. leap seconds). Implementations SHALL\n compensate for any sleep times of the device.\n\n Implementations MAY choose to discipline the radio clock and compensate for\n sleep times by any means (e.g. by combining a high precision/low power RTC\n with a high resolution counter) as long as the exposed combined clock\n provides continuous monotonic microsecond resolution ticks within the\n accuracy limits announced by @ref otPlatRadioGetCslAccuracy.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The current time in microseconds. UINT64_MAX when platform does not\n support or radio time is not ready.\n"]
    pub fn otPlatRadioGetNow(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " Get the bus speed in bits/second between the host and the radio chip.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The bus speed in bits/second between the host and the radio chip.\n          Return 0 when the MAC and above layer and Radio layer resides on the same chip.\n"]
    pub fn otPlatRadioGetBusSpeed(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get the bus latency in microseconds between the host and the radio chip.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The bus latency in microseconds between the host and the radio chip.\n          Return 0 when the MAC and above layer and Radio layer resides on the same chip.\n"]
    pub fn otPlatRadioGetBusLatency(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get current state of the radio.\n\n Is not required by OpenThread. It may be used for debugging and/or application-specific purposes.\n\n @note This function may be not implemented. It does not affect OpenThread.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @return  Current state of the radio.\n"]
    pub fn otPlatRadioGetState(aInstance: *mut otInstance) -> otRadioState;
}
extern "C" {
    #[doc = " Enable the radio.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE     Successfully enabled.\n @retval OT_ERROR_FAILED   The radio could not be enabled.\n"]
    pub fn otPlatRadioEnable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Disable the radio.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE            Successfully transitioned to Disabled.\n @retval OT_ERROR_INVALID_STATE   The radio was not in sleep state.\n"]
    pub fn otPlatRadioDisable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Check whether radio is enabled or not.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns TRUE if the radio is enabled, FALSE otherwise.\n"]
    pub fn otPlatRadioIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep (turn off the radio).\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Sleep.\n @retval OT_ERROR_BUSY          The radio was transmitting.\n @retval OT_ERROR_INVALID_STATE The radio was disabled.\n"]
    pub fn otPlatRadioSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Sleep to Receive (turn on the radio).\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[in]  aChannel   The channel to use for receiving.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Receive.\n @retval OT_ERROR_INVALID_STATE The radio was disabled or transmitting.\n"]
    pub fn otPlatRadioReceive(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Schedule a radio reception window at a specific time and duration.\n\n @param[in]  aChannel   The radio channel on which to receive.\n @param[in]  aStart     The receive window start time relative to the local\n                        radio clock, see `otPlatRadioGetNow`. The radio\n                        receiver SHALL be on and ready to receive the first\n                        symbol of a frame's SHR at the window start time.\n @param[in]  aDuration  The receive window duration, in microseconds, as\n                        measured by the local radio clock. The radio SHOULD be\n                        turned off (or switched to TX mode if an ACK frame\n                        needs to be sent) after that duration unless it is\n                        still actively receiving a frame. In the latter case\n                        the radio SHALL be kept in reception mode until frame\n                        reception has either succeeded or failed.\n\n @retval OT_ERROR_NONE    Successfully scheduled receive window.\n @retval OT_ERROR_FAILED  The receive window could not be scheduled."]
    pub fn otPlatRadioReceiveAt(
        aInstance: *mut otInstance,
        aChannel: u8,
        aStart: u32,
        aDuration: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread of a received frame.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.\n @param[in]  aError    OT_ERROR_NONE when successfully received a frame,\n                       OT_ERROR_ABORT when reception was aborted and a frame was not received,\n                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.\n"]
    pub fn otPlatRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module of a received frame.\n\n Is used when diagnostics is enabled.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.\n @param[in]  aError    OT_ERROR_NONE when successfully received a frame,\n                       OT_ERROR_ABORT when reception was aborted and a frame was not received,\n                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.\n"]
    pub fn otPlatDiagRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the radio transmit frame buffer.\n\n OpenThread forms the IEEE 802.15.4 frame in this buffer then calls `otPlatRadioTransmit()` to request transmission.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns A pointer to the transmit frame buffer.\n"]
    pub fn otPlatRadioGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
extern "C" {
    #[doc = " Begin the transmit sequence on the radio.\n\n The caller must form the IEEE 802.15.4 frame in the buffer provided by `otPlatRadioGetTransmitBuffer()` before\n requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure.\n\n The transmit sequence consists of:\n 1. Transitioning the radio to Transmit from one of the following states:\n    - Receive if RX is on when the device is idle or OT_RADIO_CAPS_SLEEP_TO_TX is not supported\n    - Sleep if RX is off when the device is idle and OT_RADIO_CAPS_SLEEP_TO_TX is supported.\n 2. Transmits the psdu on the given channel and at the given transmit power.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aFrame     A pointer to the frame to be transmitted.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Transmit.\n @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state.\n"]
    pub fn otPlatRadioTransmit(aInstance: *mut otInstance, aFrame: *mut otRadioFrame) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the transmission has started.\n\n @note  This function should be called by the same thread that executes all of the other OpenThread code. It should\n        not be called by ISR or any other task.\n\n @param[in]  aInstance  A pointer to the OpenThread instance structure.\n @param[in]  aFrame     A pointer to the frame that is being transmitted.\n"]
    pub fn otPlatRadioTxStarted(aInstance: *mut otInstance, aFrame: *mut otRadioFrame);
}
extern "C" {
    #[doc = " The radio driver calls this function to notify OpenThread that the transmit operation has completed,\n providing both the transmitted frame and, if applicable, the received ack frame.\n\n When radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability, radio platform layer updates @p aFrame\n with the security frame counter and key index values maintained by the radio.\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[in]  aFrame     A pointer to the frame that was transmitted.\n @param[in]  aAckFrame  A pointer to the ACK frame, NULL if no ACK was received.\n @param[in]  aError     OT_ERROR_NONE when the frame was transmitted,\n                        OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received,\n                        OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,\n                        OT_ERROR_ABORT when transmission was aborted for other reasons.\n"]
    pub fn otPlatRadioTxDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed.\n\n Is used when diagnostics is enabled.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aFrame         A pointer to the frame that was transmitted.\n @param[in]  aError         OT_ERROR_NONE when the frame was transmitted,\n                            OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,\n                            OT_ERROR_ABORT when transmission was aborted for other reasons.\n"]
    pub fn otPlatDiagRadioTransmitDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid.\n"]
    pub fn otPlatRadioGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Begin the energy scan sequence on the radio.\n\n Is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.\n\n @param[in] aInstance      The OpenThread instance structure.\n @param[in] aScanChannel   The channel to perform the energy scan on.\n @param[in] aScanDuration  The duration, in milliseconds, for the channel to be scanned.\n\n @retval OT_ERROR_NONE             Successfully started scanning the channel.\n @retval OT_ERROR_BUSY             The radio is performing energy scanning.\n @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning.\n"]
    pub fn otPlatRadioEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the energy scan is complete.\n\n Is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.\n\n @param[in]  aInstance           The OpenThread instance structure.\n @param[in]  aEnergyScanMaxRssi  The maximum RSSI encountered on the scanned channel.\n"]
    pub fn otPlatRadioEnergyScanDone(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8);
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the spinel bus latency has been changed.\n\n @param[in]  aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatRadioBusLatencyChanged(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Enable/Disable source address match feature.\n\n The source address match feature controls how the radio layer decides the \"frame pending\" bit for acks sent in\n response to data request commands from children.\n\n If disabled, the radio layer must set the \"frame pending\" on all acks to data request commands.\n\n If enabled, the radio layer uses the source address match table to determine whether to set or clear the \"frame\n pending\" bit in an ack to a data request command.\n\n The source address match table provides the list of children for which there is a pending frame. Either a short\n address or an extended/long address can be added to the source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[in]  aEnable     Enable/disable source address match feature.\n"]
    pub fn otPlatRadioEnableSrcMatch(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Add a short address to the source address match table.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aShortAddress  The short address to be added.\n\n @retval OT_ERROR_NONE      Successfully added short address to the source match table.\n @retval OT_ERROR_NO_BUFS   No available entry in the source match table.\n"]
    pub fn otPlatRadioAddSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an extended address to the source address match table.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aExtAddress  The extended address to be added stored in little-endian byte order.\n\n @retval OT_ERROR_NONE      Successfully added extended address to the source match table.\n @retval OT_ERROR_NO_BUFS   No available entry in the source match table.\n"]
    pub fn otPlatRadioAddSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a short address from the source address match table.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aShortAddress  The short address to be removed.\n\n @retval OT_ERROR_NONE        Successfully removed short address from the source match table.\n @retval OT_ERROR_NO_ADDRESS  The short address is not in source address match table.\n"]
    pub fn otPlatRadioClearSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an extended address from the source address match table.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aExtAddress  The extended address to be removed stored in little-endian byte order.\n\n @retval OT_ERROR_NONE        Successfully removed the extended address from the source match table.\n @retval OT_ERROR_NO_ADDRESS  The extended address is not in source address match table.\n"]
    pub fn otPlatRadioClearSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all short addresses from the source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n"]
    pub fn otPlatRadioClearSrcMatchShortEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Clear all the extended/long addresses from source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n"]
    pub fn otPlatRadioClearSrcMatchExtEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the radio supported channel mask that the device is allowed to be on.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns The radio supported channel mask.\n"]
    pub fn otPlatRadioGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the radio preferred channel mask that the device prefers to form on.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns The radio preferred channel mask.\n"]
    pub fn otPlatRadioGetPreferredChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Enable the radio coex.\n\n Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aEnabled   TRUE to enable the radio coex, FALSE otherwise.\n\n @retval OT_ERROR_NONE     Successfully enabled.\n @retval OT_ERROR_FAILED   The radio coex could not be enabled.\n"]
    pub fn otPlatRadioSetCoexEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Check whether radio coex is enabled or not.\n\n Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns TRUE if the radio coex is enabled, FALSE otherwise.\n"]
    pub fn otPlatRadioIsCoexEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the radio coexistence metrics.\n\n Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[out] aCoexMetrics  A pointer to the coexistence metrics structure.\n\n @retval OT_ERROR_NONE          Successfully retrieved the coex metrics.\n @retval OT_ERROR_INVALID_ARGS  @p aCoexMetrics was NULL."]
    pub fn otPlatRadioGetCoexMetrics(
        aInstance: *mut otInstance,
        aCoexMetrics: *mut otRadioCoexMetrics,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable or disable CSL receiver.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aCslPeriod    CSL period, 0 for disabling CSL. CSL period is in unit of 10 symbols.\n @param[in]  aShortAddr    The short source address of CSL receiver's peer.\n @param[in]  aExtAddr      The extended source address of CSL receiver's peer.\n\n @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks.\n\n @retval  OT_ERROR_NOT_IMPLEMENTED Radio driver doesn't support CSL.\n @retval  OT_ERROR_FAILED          Other platform specific errors.\n @retval  OT_ERROR_NONE            Successfully enabled or disabled CSL.\n"]
    pub fn otPlatRadioEnableCsl(
        aInstance: *mut otInstance,
        aCslPeriod: u32,
        aShortAddr: otShortAddress,
        aExtAddr: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Reset CSL receiver in the platform.\n\n @note Defaults to `otPlatRadioEnableCsl(aInstance,0, Mac::kShortAddrInvalid, nullptr);`\n\n @param[in]  aInstance     The OpenThread instance structure.\n\n @retval  OT_ERROR_NOT_IMPLEMENTED Radio driver doesn't support CSL.\n @retval  OT_ERROR_FAILED          Other platform specific errors.\n @retval  OT_ERROR_NONE            Successfully disabled CSL.\n"]
    pub fn otPlatRadioResetCsl(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Update CSL sample time in radio driver.\n\n Sample time is stored in radio driver as a copy to calculate phase when\n sending ACK with CSL IE. The CSL sample (window) of the CSL receiver extends\n before and after the sample time. The CSL sample time marks a timestamp in\n the CSL sample window when a frame should be received in \"ideal conditions\"\n if there would be no inaccuracy/clock-drift.\n\n @param[in]  aInstance         The OpenThread instance structure.\n @param[in]  aCslSampleTime    The next sample time, in microseconds. It is\n                               the time when the first symbol of the MHR of\n                               the frame is expected."]
    pub fn otPlatRadioUpdateCslSampleTime(aInstance: *mut otInstance, aCslSampleTime: u32);
}
extern "C" {
    #[doc = " Get the current estimated worst case accuracy (maximum  deviation from the\n nominal frequency) of the local radio clock in units of PPM. This is the\n clock used to schedule CSL operations.\n\n @note Implementations MAY estimate this value based on current operating\n conditions (e.g. temperature).\n\n In case the implementation does not estimate the current value but returns a\n fixed value, this value MUST be the worst-case accuracy over all possible\n foreseen operating conditions (temperature, pressure, etc) of the\n implementation.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The current CSL rx/tx scheduling drift, in PPM.\n"]
    pub fn otPlatRadioGetCslAccuracy(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The fixed uncertainty (i.e. random jitter) of the arrival time of CSL\n transmissions received by this device in units of 10 microseconds.\n\n This designates the worst case constant positive or negative deviation of\n the actual arrival time of a transmission from the transmission time\n calculated relative to the local radio clock independent of elapsed time. In\n addition to uncertainty accumulated over elapsed time, the CSL channel sample\n (\"RX window\") must be extended by twice this deviation such that an actual\n transmission is guaranteed to be detected by the local receiver in the\n presence of random arrival time jitter.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The CSL Uncertainty in units of 10 us.\n"]
    pub fn otPlatRadioGetCslUncertainty(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the max transmit power for a specific channel.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aChannel     The radio channel.\n @param[in]  aMaxPower    The max power in dBm, passing OT_RADIO_RSSI_INVALID will disable this channel.\n\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented\n @retval  OT_ERROR_INVALID_ARGS     The specified channel is not valid.\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully set max transmit power.\n"]
    pub fn otPlatRadioSetChannelMaxTransmitPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aMaxPower: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the region code.\n\n The radio region format is the 2-bytes ascii representation of the\n ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char\n                          and the `aRegionCode & 0xff` is the second ascii char.\n\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully set region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
extern "C" {
    #[doc = " Get the region code.\n\n The radio region format is the 2-bytes ascii representation of the\n ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[out] aRegionCode  The radio region.\n\n @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully got region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
extern "C" {
    #[doc = " Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator.\n\n After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that\n node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to\n collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that\n Probing Initiator.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics\n                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0.\n @param[in]  aShortAddress The short address of the Probing Initiator.\n @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`.\n\n @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing.\n @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`.\n @retval  OT_ERROR_NOT_FOUND       The Initiator indicated by @p aShortAddress is not found when trying to clear.\n @retval  OT_ERROR_NO_BUFS         No more Initiator can be supported.\n @retval  OT_ERROR_NOT_IMPLEMENTED The feature is not implemented.\n"]
    pub fn otPlatRadioConfigureEnhAckProbing(
        aInstance: *mut otInstance,
        aLinkMetrics: otLinkMetrics,
        aShortAddress: otShortAddress,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a calibrated power of the specified channel to the power calibration table.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n\n The @p aActualPower is the actual measured output power when the parameters of the radio hardware modules\n are set to the @p aRawPowerSetting.\n\n The raw power setting is an opaque byte array. OpenThread doesn't define the format of the raw power setting.\n Its format is radio hardware related and it should be defined by the developers in the platform radio driver.\n For example, if the radio hardware contains both the radio chip and the FEM chip, the raw power setting can be\n a combination of the radio power register and the FEM gain value.\n\n @param[in] aInstance               The OpenThread instance structure.\n @param[in] aChannel                The radio channel.\n @param[in] aActualPower            The actual power in 0.01dBm.\n @param[in] aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting.\n\n @retval OT_ERROR_NONE             Successfully added the calibrated power to the power calibration table.\n @retval OT_ERROR_NO_BUFS          No available entry in the power calibration table.\n @retval OT_ERROR_INVALID_ARGS     The @p aChannel, @p aActualPower or @p aRawPowerSetting is invalid or the\n                                   @p aActualPower already exists in the power calibration table.\n @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.\n"]
    pub fn otPlatRadioAddCalibratedPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aActualPower: i16,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all calibrated powers from the power calibration table.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @retval OT_ERROR_NONE             Successfully cleared all calibrated powers from the power calibration table.\n @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.\n"]
    pub fn otPlatRadioClearCalibratedPowers(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Set the target power for the given channel.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n       If this API is implemented, the function `otPlatRadioSetTransmitPower()` should be disabled.\n\n The radio driver should set the actual output power to be less than or equal to the @p aTargetPower and as close\n as possible to the @p aTargetPower. If the @p aTargetPower is lower than the minimum output power supported\n by the platform, the output power should be set to the minimum output power supported by the platform.  If the\n @p aTargetPower is higher than the maximum output power supported by the platform, the output power should be\n set to the maximum output power supported by the platform. If the @p aTargetPower is set to `INT16_MAX`, the\n corresponding channel is disabled.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aChannel      The radio channel.\n @param[in]  aTargetPower  The target power in 0.01dBm.\n\n @retval  OT_ERROR_NONE             Successfully set the target power.\n @retval  OT_ERROR_INVALID_ARGS     The @p aChannel is invalid.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioSetChannelTargetPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: i16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the raw power setting for the given channel.\n\n @note OpenThread `src/core/utils` implements a default implementation of the API `otPlatRadioAddCalibratedPower()`,\n       `otPlatRadioClearCalibratedPowers()` and `otPlatRadioSetChannelTargetPower()`. This API is provided by\n       the default implementation to get the raw power setting for the given channel. If the platform doesn't\n       use the default implementation, it can ignore this API.\n\n Platform radio layer should parse the raw power setting based on the radio layer defined format and set the\n parameters of each radio hardware module.\n\n @param[in]      aInstance               The OpenThread instance structure.\n @param[in]      aChannel                The radio channel.\n @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting.\n                                         On output, a pointer to the length of the raw power setting data.\n\n @retval  OT_ERROR_NONE          Successfully got the target power.\n @retval  OT_ERROR_INVALID_ARGS  The @p aChannel is invalid, @p aRawPowerSetting or @p aRawPowerSettingLength is NULL\n                                 or @aRawPowerSettingLength is too short.\n @retval  OT_ERROR_NOT_FOUND     The raw power setting for the @p aChannel was not found.\n"]
    pub fn otPlatRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aChannel: u8,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
#[doc = " @struct otIp6InterfaceIdentifier\n\n Represents the Interface Identifier of an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6InterfaceIdentifier {
    #[doc = "< The Interface Identifier accessor fields"]
    pub mFields: otIp6InterfaceIdentifier__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6InterfaceIdentifier__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 8usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 4usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 2usize],
}
#[doc = " @struct otIp6NetworkPrefix\n\n Represents the Network Prefix of an IPv6 address (most significant 64 bits of the address).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otIp6NetworkPrefix {
    #[doc = "< The Network Prefix."]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6AddressComponents\n\n Represents the components of an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6AddressComponents {
    #[doc = "< The Network Prefix (most significant 64 bits of the address)"]
    pub mNetworkPrefix: otIp6NetworkPrefix,
    #[doc = "< The Interface Identifier (least significant 64 bits of the address)"]
    pub mIid: otIp6InterfaceIdentifier,
}
#[doc = " @struct otIp6Address\n\n Represents an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Address {
    #[doc = "< IPv6 accessor fields"]
    pub mFields: otIp6Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 16usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 8usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 4usize],
    #[doc = "< IPv6 address components"]
    pub mComponents: otIp6AddressComponents,
}
#[doc = " @struct otIp6Prefix\n\n Represents an IPv6 prefix.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Prefix {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Address,
    #[doc = "< The IPv6 prefix length (in bits)."]
    pub mLength: u8,
}
#[doc = "< Thread assigned address (ALOC, RLOC, MLEID, etc)"]
pub const OT_ADDRESS_ORIGIN_THREAD: _bindgen_ty_7 = 0;
#[doc = "< SLAAC assigned address"]
pub const OT_ADDRESS_ORIGIN_SLAAC: _bindgen_ty_7 = 1;
#[doc = "< DHCPv6 assigned address"]
pub const OT_ADDRESS_ORIGIN_DHCPV6: _bindgen_ty_7 = 2;
#[doc = "< Manually assigned address"]
pub const OT_ADDRESS_ORIGIN_MANUAL: _bindgen_ty_7 = 3;
#[doc = " IPv6 Address origins\n"]
pub type _bindgen_ty_7 = crate::c_types::c_uint;
#[doc = " Represents an IPv6 network interface unicast address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifAddress {
    #[doc = "< The IPv6 unicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< The Prefix length (in bits)."]
    pub mPrefixLength: u8,
    #[doc = "< The IPv6 address origin."]
    pub mAddressOrigin: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< A pointer to the next network interface address."]
    pub mNext: *const otNetifAddress,
}
impl otNetifAddress {
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverrideValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mScopeOverrideValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverride(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mScopeOverride(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mRloc(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRloc(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMeshLocal(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMeshLocal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSrpRegistered(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSrpRegistered(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreferred: bool,
        mValid: bool,
        mScopeOverrideValid: bool,
        mScopeOverride: crate::c_types::c_uint,
        mRloc: bool,
        mMeshLocal: bool,
        mSrpRegistered: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValid: u8 = unsafe { ::core::mem::transmute(mValid) };
            mValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mScopeOverrideValid: u8 = unsafe { ::core::mem::transmute(mScopeOverrideValid) };
            mScopeOverrideValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let mScopeOverride: u32 = unsafe { ::core::mem::transmute(mScopeOverride) };
            mScopeOverride as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mRloc: u8 = unsafe { ::core::mem::transmute(mRloc) };
            mRloc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mMeshLocal: u8 = unsafe { ::core::mem::transmute(mMeshLocal) };
            mMeshLocal as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mSrpRegistered: u8 = unsafe { ::core::mem::transmute(mSrpRegistered) };
            mSrpRegistered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents an IPv6 network interface multicast address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifMulticastAddress {
    #[doc = "< The IPv6 multicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< A pointer to the next network interface multicast address."]
    pub mNext: *const otNetifMulticastAddress,
}
#[doc = " Represents an IPv6 socket address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSockAddr {
    #[doc = "< An IPv6 address."]
    pub mAddress: otIp6Address,
    #[doc = "< A transport-layer port."]
    pub mPort: u16,
}
#[doc = "< Non-ECT"]
pub const OT_ECN_NOT_CAPABLE: _bindgen_ty_8 = 0;
#[doc = "< ECT(0)"]
pub const OT_ECN_CAPABLE_0: _bindgen_ty_8 = 2;
#[doc = "< ECT(1)"]
pub const OT_ECN_CAPABLE_1: _bindgen_ty_8 = 1;
#[doc = "< Congestion encountered (CE)"]
pub const OT_ECN_MARKED: _bindgen_ty_8 = 3;
#[doc = " ECN statuses, represented as in the IP header.\n"]
pub type _bindgen_ty_8 = crate::c_types::c_uint;
#[doc = " Represents the local and peer IPv6 socket addresses.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageInfo {
    #[doc = "< The local IPv6 address."]
    pub mSockAddr: otIp6Address,
    #[doc = "< The peer IPv6 address."]
    pub mPeerAddr: otIp6Address,
    #[doc = "< The local transport-layer port."]
    pub mSockPort: u16,
    #[doc = "< The peer transport-layer port."]
    pub mPeerPort: u16,
    #[doc = "< The IPv6 Hop Limit value. Only applies if `mAllowZeroHopLimit` is FALSE.\n< If `0`, IPv6 Hop Limit is default value `OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT`.\n< Otherwise, specifies the IPv6 Hop Limit."]
    pub mHopLimit: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otMessageInfo {
    #[inline]
    pub fn mEcn(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mEcn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsHostInterface(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHostInterface(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAllowZeroHopLimit(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllowZeroHopLimit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMulticastLoop(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMulticastLoop(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mEcn: u8,
        mIsHostInterface: bool,
        mAllowZeroHopLimit: bool,
        mMulticastLoop: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mEcn: u8 = unsafe { ::core::mem::transmute(mEcn) };
            mEcn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsHostInterface: u8 = unsafe { ::core::mem::transmute(mIsHostInterface) };
            mIsHostInterface as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mAllowZeroHopLimit: u8 = unsafe { ::core::mem::transmute(mAllowZeroHopLimit) };
            mAllowZeroHopLimit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mMulticastLoop: u8 = unsafe { ::core::mem::transmute(mMulticastLoop) };
            mMulticastLoop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< IPv6 Hop-by-Hop Option"]
pub const OT_IP6_PROTO_HOP_OPTS: _bindgen_ty_9 = 0;
#[doc = "< Transmission Control Protocol"]
pub const OT_IP6_PROTO_TCP: _bindgen_ty_9 = 6;
#[doc = "< User Datagram"]
pub const OT_IP6_PROTO_UDP: _bindgen_ty_9 = 17;
#[doc = "< IPv6 encapsulation"]
pub const OT_IP6_PROTO_IP6: _bindgen_ty_9 = 41;
#[doc = "< Routing Header for IPv6"]
pub const OT_IP6_PROTO_ROUTING: _bindgen_ty_9 = 43;
#[doc = "< Fragment Header for IPv6"]
pub const OT_IP6_PROTO_FRAGMENT: _bindgen_ty_9 = 44;
#[doc = "< ICMP for IPv6"]
pub const OT_IP6_PROTO_ICMP6: _bindgen_ty_9 = 58;
#[doc = "< No Next Header for IPv6"]
pub const OT_IP6_PROTO_NONE: _bindgen_ty_9 = 59;
#[doc = "< Destination Options for IPv6"]
pub const OT_IP6_PROTO_DST_OPTS: _bindgen_ty_9 = 60;
#[doc = " Internet Protocol Numbers.\n"]
pub type _bindgen_ty_9 = crate::c_types::c_uint;
extern "C" {
    #[doc = " Brings the IPv6 interface up or down.\n\n Call this to enable or disable IPv6 communication.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE to enable IPv6, FALSE otherwise.\n\n @retval OT_ERROR_NONE            Successfully brought the IPv6 interface up/down.\n @retval OT_ERROR_INVALID_STATE   IPv6 interface is not available since device is operating in raw-link mode\n                                  (applicable only when `OPENTHREAD_CONFIG_LINK_RAW_ENABLE` feature is enabled).\n"]
    pub fn otIp6SetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not the IPv6 interface is up.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   The IPv6 interface is enabled.\n @retval FALSE  The IPv6 interface is disabled.\n"]
    pub fn otIp6IsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Adds a Network Interface Address to the Thread interface.\n\n The passed-in instance @p aAddress is copied by the Thread interface. The Thread interface only\n supports a fixed number of externally added unicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_UCAST_ADDRS`.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to a Network Interface Address.\n\n @retval OT_ERROR_NONE          Successfully added (or updated) the Network Interface Address.\n @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NO_BUFS       The Network Interface is already storing the maximum allowed external addresses.\n"]
    pub fn otIp6AddUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otNetifAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Network Interface Address from the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE          Successfully removed the Network Interface Address.\n @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found.\n"]
    pub fn otIp6RemoveUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 addresses assigned to the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the first Network Interface Address.\n"]
    pub fn otIp6GetUnicastAddresses(aInstance: *mut otInstance) -> *const otNetifAddress;
}
extern "C" {
    #[doc = " Indicates whether or not a unicast IPv6 address is assigned to the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to the unicast address.\n\n @retval TRUE   If @p aAddress is assigned to the Thread interface.\n @retval FALSE  If @p aAddress is not assigned to the Thread interface.\n"]
    pub fn otIp6HasUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> bool;
}
extern "C" {
    #[doc = " Subscribes the Thread interface to a Network Interface Multicast Address.\n\n The passed in instance @p aAddress will be copied by the Thread interface. The Thread interface only\n supports a fixed number of externally added multicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_MCAST_ADDRS`.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE           Successfully subscribed to the Network Interface Multicast Address.\n @retval OT_ERROR_ALREADY        The multicast address is already subscribed.\n @retval OT_ERROR_INVALID_ARGS   The IP Address indicated by @p aAddress is an invalid multicast address.\n @retval OT_ERROR_REJECTED       The IP Address indicated by @p aAddress is an internal multicast address.\n @retval OT_ERROR_NO_BUFS        The Network Interface is already storing the maximum allowed external multicast\n                                 addresses.\n"]
    pub fn otIp6SubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Unsubscribes the Thread interface to a Network Interface Multicast Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE          Successfully unsubscribed to the Network Interface Multicast Address.\n @retval OT_ERROR_REJECTED      The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found.\n"]
    pub fn otIp6UnsubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 multicast addresses subscribed to the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the first Network Interface Multicast Address.\n"]
    pub fn otIp6GetMulticastAddresses(aInstance: *mut otInstance)
        -> *const otNetifMulticastAddress;
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv6 message.\n\n @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n\n @sa otMessageFree\n"]
    pub fn otIp6NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Allocate a new message buffer and write the IPv6 datagram to the message buffer for sending an IPv6 message.\n\n @note If @p aSettings is NULL, the link layer security is enabled and the message priority is obtained from IPv6\n       message itself.\n       If @p aSettings is not NULL, the @p aSetting->mPriority is ignored and obtained from IPv6 message itself.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aData        A pointer to the IPv6 datagram buffer.\n @param[in]  aDataLength  The size of the IPv6 datagram buffer pointed by @p aData.\n @param[in]  aSettings    A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message or NULL if malformed IPv6 header or insufficient message buffers are available.\n\n @sa otMessageFree\n"]
    pub fn otIp6NewMessageFromBuffer(
        aInstance: *mut otInstance,
        aData: *const u8,
        aDataLength: u16,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
#[doc = " Pointer is called when an IPv6 datagram is received.\n\n @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers\n                       the ownership of the @p aMessage to the receiver of the callback. The message should be\n                       freed by the receiver of the callback after it is processed (see otMessageFree()).\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otIp6ReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Registers a callback to provide received IPv6 datagrams.\n\n By default, this callback does not pass Thread control traffic.  See otIp6SetReceiveFilterEnabled() to\n change the Thread control traffic filter setting.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aCallback         A pointer to a function that is called when an IPv6 datagram is received or\n                               NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @sa otIp6IsReceiveFilterEnabled\n @sa otIp6SetReceiveFilterEnabled\n"]
    pub fn otIp6SetReceiveCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6ReceiveCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
#[doc = " Represents IPv6 address information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIp6AddressInfo {
    #[doc = "< A pointer to the IPv6 address."]
    pub mAddress: *const otIp6Address,
    #[doc = "< The prefix length of mAddress if it is a unicast address."]
    pub mPrefixLength: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otIp6AddressInfo {
    #[inline]
    pub fn mScope(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mScope(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMeshLocal(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMeshLocal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mScope: u8,
        mPreferred: bool,
        mMeshLocal: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mScope: u8 = unsafe { ::core::mem::transmute(mScope) };
            mScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mMeshLocal: u8 = unsafe { ::core::mem::transmute(mMeshLocal) };
            mMeshLocal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Pointer is called when an internal IPv6 address is added or removed.\n\n @param[in]   aAddressInfo        A pointer to the IPv6 address information.\n @param[in]   aIsAdded            TRUE if the @p aAddress was added, FALSE if @p aAddress was removed.\n @param[in]   aContext            A pointer to application-specific context.\n"]
pub type otIp6AddressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aAddressInfo: *const otIp6AddressInfo,
        aIsAdded: bool,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Registers a callback to notify internal IPv6 address changes.\n\n @param[in]   aInstance           A pointer to an OpenThread instance.\n @param[in]   aCallback           A pointer to a function that is called when an internal IPv6 address is added or\n                                  removed. NULL to disable the callback.\n @param[in]   aCallbackContext    A pointer to application-specific context.\n"]
    pub fn otIp6SetAddressCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6AddressCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Indicates whether or not Thread control traffic is filtered out when delivering IPv6 datagrams\n via the callback specified in otIp6SetReceiveCallback().\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns  TRUE if Thread control traffic is filtered out, FALSE otherwise.\n\n @sa otIp6SetReceiveCallback\n @sa otIp6SetReceiveFilterEnabled\n"]
    pub fn otIp6IsReceiveFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Sets whether or not Thread control traffic is filtered out when delivering IPv6 datagrams\n via the callback specified in otIp6SetReceiveCallback().\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aEnabled  TRUE if Thread control traffic is filtered out, FALSE otherwise.\n\n @sa otIp6SetReceiveCallback\n @sa otIsReceiveIp6FilterEnabled\n"]
    pub fn otIp6SetReceiveFilterEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Sends an IPv6 datagram via the Thread interface.\n\n The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when\n processing is complete, including when a value other than `OT_ERROR_NONE` is returned.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aMessage  A pointer to the message buffer containing the IPv6 datagram.\n\n @retval OT_ERROR_NONE                    Successfully processed the message.\n @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing\n rules.\n @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram.\n @retval OT_ERROR_NO_ROUTE                No route to host.\n @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address.\n @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message.\n @retval OT_ERROR_INVALID_ARGS            The message's metadata is invalid, e.g. the message uses\n                                          `OT_MESSAGE_ORIGIN_THREAD_NETIF` as the origin.\n"]
    pub fn otIp6Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " Adds a port to the allowed unsecured port list.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPort     The port value.\n\n @retval OT_ERROR_NONE         The port was successfully added to the allowed unsecure port list.\n @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).\n @retval OT_ERROR_NO_BUFS      The unsecure port list is full.\n"]
    pub fn otIp6AddUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " Removes a port from the allowed unsecure port list.\n\n @note This function removes @p aPort by overwriting @p aPort with the element after @p aPort in the internal port\n       list. Be careful when calling otIp6GetUnsecurePorts() followed by otIp6RemoveUnsecurePort() to remove unsecure\n       ports.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPort     The port value.\n\n @retval OT_ERROR_NONE         The port was successfully removed from the allowed unsecure port list.\n @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).\n @retval OT_ERROR_NOT_FOUND    The port was not found in the unsecure port list.\n"]
    pub fn otIp6RemoveUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " Removes all ports from the allowed unsecure port list.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otIp6RemoveAllUnsecurePorts(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Returns a pointer to the unsecure port list.\n\n @note Port value 0 is used to indicate an invalid entry.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aNumEntries  The number of entries in the list.\n\n @returns A pointer to the unsecure port list.\n"]
    pub fn otIp6GetUnsecurePorts(aInstance: *mut otInstance, aNumEntries: *mut u8) -> *const u16;
}
extern "C" {
    #[doc = " Test if two IPv6 addresses are the same.\n\n @param[in]  aFirst   A pointer to the first IPv6 address to compare.\n @param[in]  aSecond  A pointer to the second IPv6 address to compare.\n\n @retval TRUE   The two IPv6 addresses are the same.\n @retval FALSE  The two IPv6 addresses are not the same.\n"]
    pub fn otIp6IsAddressEqual(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " Test if two IPv6 prefixes are the same.\n\n @param[in]  aFirst   A pointer to the first IPv6 prefix to compare.\n @param[in]  aSecond  A pointer to the second IPv6 prefix to compare.\n\n @retval TRUE   The two IPv6 prefixes are the same.\n @retval FALSE  The two IPv6 prefixes are not the same.\n"]
    pub fn otIp6ArePrefixesEqual(aFirst: *const otIp6Prefix, aSecond: *const otIp6Prefix) -> bool;
}
extern "C" {
    #[doc = " Converts a human-readable IPv6 address string into a binary representation.\n\n @param[in]   aString   A pointer to a NULL-terminated string.\n @param[out]  aAddress  A pointer to an IPv6 address.\n\n @retval OT_ERROR_NONE   Successfully parsed @p aString and updated @p aAddress.\n @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 address.\n"]
    pub fn otIp6AddressFromString(
        aString: *const crate::c_types::c_char,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a human-readable IPv6 prefix string into a binary representation.\n\n The @p aString parameter should be a string in the format \"<address>/<plen>\", where `<address>` is an IPv6\n address and `<plen>` is a prefix length.\n\n @param[in]   aString  A pointer to a NULL-terminated string.\n @param[out]  aPrefix  A pointer to an IPv6 prefix.\n\n @retval OT_ERROR_NONE   Successfully parsed the string as an IPv6 prefix and updated @p aPrefix.\n @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 prefix.\n"]
    pub fn otIp6PrefixFromString(
        aString: *const crate::c_types::c_char,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a given IPv6 address to a human-readable string.\n\n The IPv6 address string is formatted as 16 hex values separated by ':' (i.e., \"%x:%x:%x:...:%x\").\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aAddress  A pointer to an IPv6 address (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_ADDRESS_STRING_SIZE`.\n"]
    pub fn otIp6AddressToString(
        aAddress: *const otIp6Address,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Converts a given IPv6 socket address to a human-readable string.\n\n The IPv6 socket address string is formatted as [`address`]:`port` where `address` is shown\n as 16 hex values separated by `:` and `port` is the port number in decimal format,\n for example \"[%x:%x:...:%x]:%u\".\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aSockAddr A pointer to an IPv6 socket address (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_SOCK_ADDR_STRING_SIZE`.\n"]
    pub fn otIp6SockAddrToString(
        aSockAddr: *const otSockAddr,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Converts a given IPv6 prefix to a human-readable string.\n\n The IPv6 address string is formatted as \"%x:%x:%x:...[::]/plen\".\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aPrefix   A pointer to an IPv6 prefix (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_PREFIX_STRING_SIZE`.\n"]
    pub fn otIp6PrefixToString(
        aPrefix: *const otIp6Prefix,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Returns the prefix match length (bits) for two IPv6 addresses.\n\n @param[in]  aFirst   A pointer to the first IPv6 address.\n @param[in]  aSecond  A pointer to the second IPv6 address.\n\n @returns  The prefix match length in bits.\n"]
    pub fn otIp6PrefixMatch(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> u8;
}
extern "C" {
    #[doc = " Gets a prefix with @p aLength from @p aAddress.\n\n @param[in]  aAddress   A pointer to an IPv6 address.\n @param[in]  aLength    The length of prefix in bits.\n @param[out] aPrefix    A pointer to output the IPv6 prefix.\n"]
    pub fn otIp6GetPrefix(aAddress: *const otIp6Address, aLength: u8, aPrefix: *mut otIp6Prefix);
}
extern "C" {
    #[doc = " Indicates whether or not a given IPv6 address is the Unspecified Address.\n\n @param[in]  aAddress   A pointer to an IPv6 address.\n\n @retval TRUE   If the IPv6 address is the Unspecified Address.\n @retval FALSE  If the IPv6 address is not the Unspecified Address.\n"]
    pub fn otIp6IsAddressUnspecified(aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " Perform OpenThread source address selection.\n\n @param[in]      aInstance     A pointer to an OpenThread instance.\n @param[in,out]  aMessageInfo  A pointer to the message information.\n\n @retval  OT_ERROR_NONE       Found a source address and is filled into mSockAddr of @p aMessageInfo.\n @retval  OT_ERROR_NOT_FOUND  No source address was found and @p aMessageInfo is unchanged.\n"]
    pub fn otIp6SelectSourceAddress(
        aInstance: *mut otInstance,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Indicates whether the SLAAC module is enabled or not.\n\n `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.\n\n @retval TRUE    SLAAC module is enabled.\n @retval FALSE   SLAAC module is disabled.\n"]
    pub fn otIp6IsSlaacEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enables/disables the SLAAC module.\n\n `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.\n\n When SLAAC module is enabled, SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface.\n When SLAAC module is disabled any previously added SLAAC address is removed.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE to enable, FALSE to disable.\n"]
    pub fn otIp6SetSlaacEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
#[doc = " Pointer allows user to filter prefixes and not allow an SLAAC address based on a prefix to be added.\n\n `otIp6SetSlaacPrefixFilter()` can be used to set the filter handler. The filter handler is invoked by SLAAC module\n when it is about to add a SLAAC address based on a prefix. Its boolean return value determines whether the address\n is filtered (not added) or not.\n\n @param[in] aInstance   A pointer to an OpenThread instance.\n @param[in] aPrefix     A pointer to prefix for which SLAAC address is about to be added.\n\n @retval TRUE    Indicates that the SLAAC address based on the prefix should be filtered and NOT added.\n @retval FALSE   Indicates that the SLAAC address based on the prefix should be added.\n"]
pub type otIp6SlaacPrefixFilter = ::core::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aPrefix: *const otIp6Prefix) -> bool,
>;
extern "C" {
    #[doc = " Sets the SLAAC module filter handler.\n\n `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.\n\n The filter handler is called by SLAAC module when it is about to add a SLAAC address based on a prefix to decide\n whether the address should be added or not.\n\n A NULL filter handler disables filtering and allows all SLAAC addresses to be added.\n\n If this function is not called, the default filter used by SLAAC module will be NULL (filtering is disabled).\n\n @param[in] aInstance    A pointer to an OpenThread instance.\n @param[in] aFilter      A pointer to SLAAC prefix filter handler, or NULL to disable filtering.\n"]
    pub fn otIp6SetSlaacPrefixFilter(aInstance: *mut otInstance, aFilter: otIp6SlaacPrefixFilter);
}
#[doc = " Pointer is called with results of `otIp6RegisterMulticastListeners`.\n\n @param[in]  aContext  A pointer to the user context.\n @param[in]  aError    OT_ERROR_NONE when successfully sent MLR.req and received MLR.rsp,\n                       OT_ERROR_RESPONSE_TIMEOUT when failed to receive MLR.rsp,\n                       OT_ERROR_PARSE when failed to parse MLR.rsp.\n @param[in]  aMlrStatus         The Multicast Listener Registration status when @p aError is OT_ERROR_NONE.\n @param[in]  aFailedAddresses   A pointer to the failed IPv6 addresses when @p aError is OT_ERROR_NONE.\n @param[in]  aFailedAddressNum  The number of failed IPv6 addresses when @p aError is OT_ERROR_NONE.\n\n @sa otIp6RegisterMulticastListeners\n"]
pub type otIp6RegisterMulticastListenersCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aError: otError,
        aMlrStatus: u8,
        aFailedAddresses: *const otIp6Address,
        aFailedAddressNum: u8,
    ),
>;
extern "C" {
    #[doc = " Registers Multicast Listeners to Primary Backbone Router.\n\n `OPENTHREAD_CONFIG_TMF_PROXY_MLR_ENABLE` and `OPENTHREAD_CONFIG_COMMISSIONER_ENABLE`\n must be enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aAddresses   A Multicast Address Array to register.\n @param[in]  aAddressNum  The number of Multicast Address to register (0 if @p aAddresses is NULL).\n @param[in]  aTimeout     A pointer to the timeout value (in seconds) to be included in MLR.req. A timeout value of 0\n                          removes the corresponding Multicast Listener. If NULL, MLR.req would have no Timeout Tlv by\n                          default.\n @param[in]  aCallback    A pointer to the callback function.\n @param[in]  aContext     A pointer to the user context.\n\n @retval OT_ERROR_NONE           Successfully sent MLR.req. The @p aCallback will be called iff this method\n                                 returns OT_ERROR_NONE.\n @retval OT_ERROR_BUSY           If a previous registration was ongoing.\n @retval OT_ERROR_INVALID_ARGS   If one or more arguments are invalid.\n @retval OT_ERROR_INVALID_STATE  If the device was not in a valid state to send MLR.req (e.g. Commissioner not\n                                 started, Primary Backbone Router not found).\n @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.\n\n @sa otIp6RegisterMulticastListenersCallback\n"]
    pub fn otIp6RegisterMulticastListeners(
        aInstance: *mut otInstance,
        aAddresses: *const otIp6Address,
        aAddressNum: u8,
        aTimeout: *const u32,
        aCallback: otIp6RegisterMulticastListenersCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Mesh Local IID (for test purpose).\n\n Requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[in]   aIid        A pointer to the Mesh Local IID to set.\n\n @retval  OT_ERROR_NONE           Successfully set the Mesh Local IID.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otIp6SetMeshLocalIid(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a given IP protocol number to a human-readable string.\n\n @param[in] aIpProto   An IP protocol number (`OT_IP6_PROTO_*` enumeration).\n\n @returns A string representing @p aIpProto.\n"]
    pub fn otIp6ProtoToString(aIpProto: u8) -> *const crate::c_types::c_char;
}
#[doc = " Represents the counters for packets and bytes.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otPacketsAndBytes {
    #[doc = "< The number of packets."]
    pub mPackets: u64,
    #[doc = "< The number of bytes."]
    pub mBytes: u64,
}
#[doc = " Represents the counters of packets forwarded via Border Routing.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBorderRoutingCounters {
    #[doc = "< The counters for inbound unicast."]
    pub mInboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for inbound multicast."]
    pub mInboundMulticast: otPacketsAndBytes,
    #[doc = "< The counters for outbound unicast."]
    pub mOutboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for outbound multicast."]
    pub mOutboundMulticast: otPacketsAndBytes,
    #[doc = "< The counters for inbound Internet when DHCPv6 PD enabled."]
    pub mInboundInternet: otPacketsAndBytes,
    #[doc = "< The counters for outbound Internet when DHCPv6 PD enabled."]
    pub mOutboundInternet: otPacketsAndBytes,
    #[doc = "< The number of received RA packets."]
    pub mRaRx: u32,
    #[doc = "< The number of RA packets successfully transmitted."]
    pub mRaTxSuccess: u32,
    #[doc = "< The number of RA packets failed to transmit."]
    pub mRaTxFailure: u32,
    #[doc = "< The number of received RS packets."]
    pub mRsRx: u32,
    #[doc = "< The number of RS packets successfully transmitted."]
    pub mRsTxSuccess: u32,
    #[doc = "< The number of RS packets failed to transmit."]
    pub mRsTxFailure: u32,
}
extern "C" {
    #[doc = " Gets the Border Routing counters.\n\n `OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE` build-time feature must be enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the Border Routing counters.\n"]
    pub fn otIp6GetBorderRoutingCounters(
        aInstance: *mut otInstance,
    ) -> *const otBorderRoutingCounters;
}
extern "C" {
    #[doc = " Resets the Border Routing counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otIp6ResetBorderRoutingCounters(aInstance: *mut otInstance);
}
#[doc = " This callback allows OpenThread to provide specific handlers for certain UDP messages.\n\n @retval  true    The message is handled by this receiver and should not be further processed.\n @retval  false   The message is not handled by this receiver.\n"]
pub type otUdpHandler = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aMessage: *const otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> bool,
>;
#[doc = " Represents a UDP receiver.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otUdpReceiver {
    #[doc = "< A pointer to the next UDP receiver (internal use only)."]
    pub mNext: *mut otUdpReceiver,
    #[doc = "< A function pointer to the receiver callback."]
    pub mHandler: otUdpHandler,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " Adds a UDP receiver.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aUdpReceiver    A pointer to the UDP receiver.\n\n @retval  OT_ERROR_NONE       The receiver is successfully added.\n @retval  OT_ERROR_ALREADY    The UDP receiver was already added.\n"]
    pub fn otUdpAddReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a UDP receiver.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aUdpReceiver    A pointer to the UDP receiver.\n\n @retval  OT_ERROR_NONE       The receiver is successfully removed.\n @retval  OT_ERROR_NOT_FOUND  The UDP receiver was not added.\n"]
    pub fn otUdpRemoveReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends a UDP message without socket.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A pointer to a message without UDP header.\n @param[in]  aMessageInfo  A pointer to a message info associated with @p aMessage.\n\n @retval OT_ERROR_NONE          Successfully enqueued the message into an output interface.\n @retval OT_ERROR_NO_BUFS       Insufficient available buffer to add the IPv6 headers.\n @retval OT_ERROR_INVALID_ARGS  Invalid arguments are given.\n"]
    pub fn otUdpSendDatagram(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
#[doc = " This callback allows OpenThread to inform the application of a received UDP message.\n"]
pub type otUdpReceive = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " Represents a UDP socket.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpSocket {
    #[doc = "< The local IPv6 socket address."]
    pub mSockName: otSockAddr,
    #[doc = "< The peer IPv6 socket address."]
    pub mPeerName: otSockAddr,
    #[doc = "< A function pointer to the application callback."]
    pub mHandler: otUdpReceive,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut crate::c_types::c_void,
    #[doc = "< A handle to platform's UDP."]
    pub mHandle: *mut crate::c_types::c_void,
    #[doc = "< A pointer to the next UDP socket (internal use only)."]
    pub mNext: *mut otUdpSocket,
}
#[doc = "< Unspecified network interface."]
pub const otNetifIdentifier_OT_NETIF_UNSPECIFIED: otNetifIdentifier = 0;
#[doc = "< The Thread interface."]
pub const otNetifIdentifier_OT_NETIF_THREAD: otNetifIdentifier = 1;
#[doc = "< The Backbone interface."]
pub const otNetifIdentifier_OT_NETIF_BACKBONE: otNetifIdentifier = 2;
#[doc = " Defines the OpenThread network interface identifiers.\n"]
pub type otNetifIdentifier = crate::c_types::c_uint;
extern "C" {
    #[doc = " Allocate a new message buffer for sending a UDP message.\n\n @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to use default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n\n @sa otMessageFree\n"]
    pub fn otUdpNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Open a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aCallback  A pointer to the application callback function.\n @param[in]  aContext   A pointer to application-specific context.\n\n @retval OT_ERROR_NONE    Successfully opened the socket.\n @retval OT_ERROR_FAILED  Failed to open the socket.\n"]
    pub fn otUdpOpen(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aCallback: otUdpReceive,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if a UDP socket is open.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n\n @returns Whether the UDP socket is open.\n"]
    pub fn otUdpIsOpen(aInstance: *mut otInstance, aSocket: *const otUdpSocket) -> bool;
}
extern "C" {
    #[doc = " Close a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n\n @retval OT_ERROR_NONE   Successfully closed the socket.\n @retval OT_ERROR_FAILED Failed to close UDP Socket.\n"]
    pub fn otUdpClose(aInstance: *mut otInstance, aSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " Bind a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aSockName  A pointer to an IPv6 socket address structure.\n @param[in]  aNetif     The network interface to bind.\n\n @retval OT_ERROR_NONE   Bind operation was successful.\n @retval OT_ERROR_FAILED Failed to bind UDP socket.\n"]
    pub fn otUdpBind(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
        aNetif: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Connect a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aSockName  A pointer to an IPv6 socket address structure.\n\n @retval OT_ERROR_NONE   Connect operation was successful.\n @retval OT_ERROR_FAILED Failed to connect UDP socket.\n"]
    pub fn otUdpConnect(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a UDP/IPv6 message.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aSocket       A pointer to a UDP socket structure.\n @param[in]  aMessage      A pointer to a message buffer.\n @param[in]  aMessageInfo  A pointer to a message info structure.\n\n If the return value is OT_ERROR_NONE, OpenThread takes ownership of @p aMessage, and the caller should no longer\n reference @p aMessage. If the return value is not OT_ERROR_NONE, the caller retains ownership of @p aMessage,\n including freeing @p aMessage if the message buffer is no longer needed.\n\n @retval OT_ERROR_NONE           The message is successfully scheduled for sending.\n @retval OT_ERROR_INVALID_ARGS   Invalid arguments are given.\n @retval OT_ERROR_NO_BUFS        Insufficient available buffer to add the UDP and IPv6 headers.\n"]
    pub fn otUdpSend(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the head of linked list of UDP Sockets.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the head of UDP Socket linked list.\n"]
    pub fn otUdpGetSockets(aInstance: *mut otInstance) -> *mut otUdpSocket;
}
#[doc = " Pointer delivers the UDP packet to host and host should send the packet through its own network stack.\n\n @param[in]  aMessage   A pointer to the UDP Message.\n @param[in]  aPeerPort  The destination UDP port.\n @param[in]  aPeerAddr  A pointer to the destination IPv6 address.\n @param[in]  aSockPort  The source UDP port.\n @param[in]  aContext   A pointer to application-specific context.\n"]
pub type otUdpForwarder = ::core::option::Option<
    unsafe extern "C" fn(
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *mut otIp6Address,
        aSockPort: u16,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Set UDP forward callback to deliver UDP packets to host.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aForwarder           A pointer to a function called to forward UDP packet to host.\n @param[in]  aContext             A pointer to application-specific context.\n"]
    pub fn otUdpForwardSetForwarder(
        aInstance: *mut otInstance,
        aForwarder: otUdpForwarder,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Handle a UDP packet received from host.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aMessage             A pointer to the UDP Message.\n @param[in]  aPeerPort            The source UDP port.\n @param[in]  aPeerAddr            A pointer to the source address.\n @param[in]  aSockPort            The destination UDP port.\n\n @warning No matter the call success or fail, the message is freed.\n"]
    pub fn otUdpForwardReceive(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *const otIp6Address,
        aSockPort: u16,
    );
}
extern "C" {
    #[doc = " Determines if the given UDP port is exclusively opened by OpenThread API.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  port                 UDP port number to verify.\n\n @retval true    The port is being used exclusively by OpenThread.\n @retval false   The port is not used by any of the OpenThread API or is shared (e.g. is Backbone socket).\n"]
    pub fn otUdpIsPortInUse(aInstance: *mut otInstance, port: u16) -> bool;
}
#[doc = " @struct otNetworkKey\n\n Represents a Thread Network Key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkKey {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to NetworkKey.\n"]
pub type otNetworkKeyRef = otCryptoKeyRef;
#[doc = " Represents a Network Name.\n\n The `otNetworkName` is a null terminated C string (i.e., `m8` char array MUST end with null char `\\0`).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkName {
    #[doc = "< Byte values. The `+ 1` is for null char."]
    pub m8: [crate::c_types::c_char; 17usize],
}
#[doc = " Represents an Extended PAN ID.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otExtendedPanId {
    #[doc = "< Byte values"]
    pub m8: [u8; 8usize],
}
#[doc = " Represents a Mesh Local Prefix.\n"]
pub type otMeshLocalPrefix = otIp6NetworkPrefix;
#[doc = " Represents PSKc.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPskc {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to PSKc.\n"]
pub type otPskcRef = otCryptoKeyRef;
#[doc = " Represent Security Policy.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSecurityPolicy {
    #[doc = "< The value for thrKeyRotation in units of hours."]
    pub mRotationTime: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otSecurityPolicy {
    #[inline]
    pub fn mObtainNetworkKeyEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mObtainNetworkKeyEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNativeCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNativeCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mExternalCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mExternalCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCommercialCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCommercialCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAutonomousEnrollmentEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAutonomousEnrollmentEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkKeyProvisioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkKeyProvisioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mTobleLinkEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mTobleLinkEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNonCcmRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNonCcmRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mVersionThresholdForRouting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mVersionThresholdForRouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mObtainNetworkKeyEnabled: bool,
        mNativeCommissioningEnabled: bool,
        mRoutersEnabled: bool,
        mExternalCommissioningEnabled: bool,
        mCommercialCommissioningEnabled: bool,
        mAutonomousEnrollmentEnabled: bool,
        mNetworkKeyProvisioningEnabled: bool,
        mTobleLinkEnabled: bool,
        mNonCcmRoutersEnabled: bool,
        mVersionThresholdForRouting: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mObtainNetworkKeyEnabled: u8 =
                unsafe { ::core::mem::transmute(mObtainNetworkKeyEnabled) };
            mObtainNetworkKeyEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mNativeCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNativeCommissioningEnabled) };
            mNativeCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mRoutersEnabled: u8 = unsafe { ::core::mem::transmute(mRoutersEnabled) };
            mRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mExternalCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mExternalCommissioningEnabled) };
            mExternalCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mCommercialCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mCommercialCommissioningEnabled) };
            mCommercialCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mAutonomousEnrollmentEnabled: u8 =
                unsafe { ::core::mem::transmute(mAutonomousEnrollmentEnabled) };
            mAutonomousEnrollmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mNetworkKeyProvisioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNetworkKeyProvisioningEnabled) };
            mNetworkKeyProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mTobleLinkEnabled: u8 = unsafe { ::core::mem::transmute(mTobleLinkEnabled) };
            mTobleLinkEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mNonCcmRoutersEnabled: u8 =
                unsafe { ::core::mem::transmute(mNonCcmRoutersEnabled) };
            mNonCcmRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mVersionThresholdForRouting: u8 =
                unsafe { ::core::mem::transmute(mVersionThresholdForRouting) };
            mVersionThresholdForRouting as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents Channel Mask.\n"]
pub type otChannelMask = u32;
#[doc = " Represents presence of different components in Active or Pending Operational Dataset.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otOperationalDatasetComponents {
    #[doc = "< TRUE if Active Timestamp is present, FALSE otherwise."]
    pub mIsActiveTimestampPresent: bool,
    #[doc = "< TRUE if Pending Timestamp is present, FALSE otherwise."]
    pub mIsPendingTimestampPresent: bool,
    #[doc = "< TRUE if Network Key is present, FALSE otherwise."]
    pub mIsNetworkKeyPresent: bool,
    #[doc = "< TRUE if Network Name is present, FALSE otherwise."]
    pub mIsNetworkNamePresent: bool,
    #[doc = "< TRUE if Extended PAN ID is present, FALSE otherwise."]
    pub mIsExtendedPanIdPresent: bool,
    #[doc = "< TRUE if Mesh Local Prefix is present, FALSE otherwise."]
    pub mIsMeshLocalPrefixPresent: bool,
    #[doc = "< TRUE if Delay Timer is present, FALSE otherwise."]
    pub mIsDelayPresent: bool,
    #[doc = "< TRUE if PAN ID is present, FALSE otherwise."]
    pub mIsPanIdPresent: bool,
    #[doc = "< TRUE if Channel is present, FALSE otherwise."]
    pub mIsChannelPresent: bool,
    #[doc = "< TRUE if PSKc is present, FALSE otherwise."]
    pub mIsPskcPresent: bool,
    #[doc = "< TRUE if Security Policy is present, FALSE otherwise."]
    pub mIsSecurityPolicyPresent: bool,
    #[doc = "< TRUE if Channel Mask is present, FALSE otherwise."]
    pub mIsChannelMaskPresent: bool,
}
#[doc = " Represents a Thread Dataset timestamp component.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otTimestamp {
    pub mSeconds: u64,
    pub mTicks: u16,
    pub mAuthoritative: bool,
}
#[doc = " Represents an Active or Pending Operational Dataset.\n\n Components in Dataset are optional. `mComponents` structure specifies which components are present in the Dataset.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otOperationalDataset {
    #[doc = "< Active Timestamp"]
    pub mActiveTimestamp: otTimestamp,
    #[doc = "< Pending Timestamp"]
    pub mPendingTimestamp: otTimestamp,
    #[doc = "< Network Key"]
    pub mNetworkKey: otNetworkKey,
    #[doc = "< Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Mesh Local Prefix"]
    pub mMeshLocalPrefix: otMeshLocalPrefix,
    #[doc = "< Delay Timer"]
    pub mDelay: u32,
    #[doc = "< PAN ID"]
    pub mPanId: otPanId,
    #[doc = "< Channel"]
    pub mChannel: u16,
    #[doc = "< PSKc"]
    pub mPskc: otPskc,
    #[doc = "< Security Policy"]
    pub mSecurityPolicy: otSecurityPolicy,
    #[doc = "< Channel Mask"]
    pub mChannelMask: otChannelMask,
    #[doc = "< Specifies which components are set in the Dataset."]
    pub mComponents: otOperationalDatasetComponents,
}
#[doc = " Represents an Active or Pending Operational Dataset.\n\n The Operational Dataset is TLV encoded as specified by Thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otOperationalDatasetTlvs {
    #[doc = "< Operational Dataset TLVs."]
    pub mTlvs: [u8; 254usize],
    #[doc = "< Size of Operational Dataset in bytes."]
    pub mLength: u8,
}
#[doc = "< meshcop Channel TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNEL: otMeshcopTlvType = 0;
#[doc = "< meshcop Pan Id TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PANID: otMeshcopTlvType = 1;
#[doc = "< meshcop Extended Pan Id TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_EXTPANID: otMeshcopTlvType = 2;
#[doc = "< meshcop Network Name TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKNAME: otMeshcopTlvType = 3;
#[doc = "< meshcop PSKc TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PSKC: otMeshcopTlvType = 4;
#[doc = "< meshcop Network Key TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKKEY: otMeshcopTlvType = 5;
#[doc = "< meshcop Network Key Sequence TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORK_KEY_SEQUENCE: otMeshcopTlvType = 6;
#[doc = "< meshcop Mesh Local Prefix TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_MESHLOCALPREFIX: otMeshcopTlvType = 7;
#[doc = "< meshcop Steering Data TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STEERING_DATA: otMeshcopTlvType = 8;
#[doc = "< meshcop Border Agent Locator TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_BORDER_AGENT_RLOC: otMeshcopTlvType = 9;
#[doc = "< meshcop Commissioner ID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_ID: otMeshcopTlvType = 10;
#[doc = "< meshcop Commissioner Session ID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMM_SESSION_ID: otMeshcopTlvType = 11;
#[doc = "< meshcop Security Policy TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SECURITYPOLICY: otMeshcopTlvType = 12;
#[doc = "< meshcop Get TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_GET: otMeshcopTlvType = 13;
#[doc = "< meshcop Active Timestamp TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ACTIVETIMESTAMP: otMeshcopTlvType = 14;
#[doc = "< meshcop Commissioner UDP Port TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_UDP_PORT: otMeshcopTlvType = 15;
#[doc = "< meshcop State TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STATE: otMeshcopTlvType = 16;
#[doc = "< meshcop Joiner DTLS Encapsulation TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_DTLS: otMeshcopTlvType = 17;
#[doc = "< meshcop Joiner UDP Port TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_UDP_PORT: otMeshcopTlvType = 18;
#[doc = "< meshcop Joiner IID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_IID: otMeshcopTlvType = 19;
#[doc = "< meshcop Joiner Router Locator TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_RLOC: otMeshcopTlvType = 20;
#[doc = "< meshcop Joiner Router KEK TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_ROUTER_KEK: otMeshcopTlvType = 21;
#[doc = "< meshcop Provisioning URL TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PROVISIONING_URL: otMeshcopTlvType = 32;
#[doc = "< meshcop Vendor Name TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_NAME_TLV: otMeshcopTlvType = 33;
#[doc = "< meshcop Vendor Model TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_MODEL_TLV: otMeshcopTlvType = 34;
#[doc = "< meshcop Vendor SW Version TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_SW_VERSION_TLV: otMeshcopTlvType = 35;
#[doc = "< meshcop Vendor Data TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_DATA_TLV: otMeshcopTlvType = 36;
#[doc = "< meshcop Vendor Stack Version TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_STACK_VERSION_TLV: otMeshcopTlvType = 37;
#[doc = "< meshcop UDP encapsulation TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_UDP_ENCAPSULATION_TLV: otMeshcopTlvType = 48;
#[doc = "< meshcop IPv6 address TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_IPV6_ADDRESS_TLV: otMeshcopTlvType = 49;
#[doc = "< meshcop Pending Timestamp TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PENDINGTIMESTAMP: otMeshcopTlvType = 51;
#[doc = "< meshcop Delay Timer TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DELAYTIMER: otMeshcopTlvType = 52;
#[doc = "< meshcop Channel Mask TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNELMASK: otMeshcopTlvType = 53;
#[doc = "< meshcop Count TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COUNT: otMeshcopTlvType = 54;
#[doc = "< meshcop Period TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PERIOD: otMeshcopTlvType = 55;
#[doc = "< meshcop Scan Duration TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SCAN_DURATION: otMeshcopTlvType = 56;
#[doc = "< meshcop Energy List TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ENERGY_LIST: otMeshcopTlvType = 57;
#[doc = "< meshcop Discovery Request TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYREQUEST: otMeshcopTlvType = 128;
#[doc = "< meshcop Discovery Response TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYRESPONSE: otMeshcopTlvType = 129;
#[doc = "< meshcop Joiner Advertisement TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINERADVERTISEMENT: otMeshcopTlvType = 241;
#[doc = " Represents meshcop TLV types.\n"]
pub type otMeshcopTlvType = crate::c_types::c_uint;
#[doc = " Pointer is called when a response to a MGMT_SET request is received or times out.\n\n @param[in]  aResult   A result of the operation.\n @param[in]  aContext  A pointer to application-specific context.\n\n @retval  OT_ERROR_NONE              The request was accepted by the leader.\n @retval  OT_ERROR_REJECTED          The request was rejected by the leader.\n @retval  OT_ERROR_PARSE             An error occurred during parsing the response.\n @retval  OT_ERROR_ABORT             The request was reset by peer.\n @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period.\n"]
pub type otDatasetMgmtSetCallback = ::core::option::Option<
    unsafe extern "C" fn(aResult: otError, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Indicates whether a valid network is present in the Active Operational Dataset or not.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if a valid network is present in the Active Operational Dataset, FALSE otherwise.\n"]
    pub fn otDatasetIsCommissioned(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the Active Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetActive(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Active Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Active Operational Dataset.\n\n If the dataset does not include an Active Timestamp, the dataset is only partially complete.\n\n If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to\n an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to\n attach to a network.\n\n If channel is not included in the dataset, the device will send MLE Announce messages across different channels to\n find neighbors on other channels.\n\n If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from\n its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a\n complete Active Dataset.\n\n This function consistently returns `OT_ERROR_NONE` and can effectively be treated as having a `void` return type.\n Previously, other errors (e.g., `OT_ERROR_NOT_IMPLEMENTED`) were allowed for legacy reasons. However, as\n non-volatile storage is now mandatory for Thread operation, any failure to save the dataset will trigger an\n assertion. The `otError` return type is retained for backward compatibility.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Active Operational Dataset.\n\n @retval OT_ERROR_NONE    Successfully set the Active Operational Dataset.\n"]
    pub fn otDatasetSetActive(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Active Operational Dataset.\n\n If the dataset does not include an Active Timestamp, the dataset is only partially complete.\n\n If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to\n an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to\n attach to a network.\n\n If channel is not included in the dataset, the device will send MLE Announce messages across different channels to\n find neighbors on other channels.\n\n If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from\n its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a\n complete Active Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Active Operational Dataset.\n\n @retval OT_ERROR_NONE          Successfully set the Active Operational Dataset.\n @retval OT_ERROR_INVALID_ARGS  The @p aDataset is invalid. It is too long or contains incorrect TLV formatting.\n"]
    pub fn otDatasetSetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Pending Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetPending(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Pending Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Pending Operational Dataset.\n\n This function consistently returns `OT_ERROR_NONE` and can effectively be treated as having a `void` return type.\n Previously, other errors (e.g., `OT_ERROR_NOT_IMPLEMENTED`) were allowed for legacy reasons. However, as\n non-volatile storage is now mandatory for Thread operation, any failure to save the dataset will trigger an\n assertion. The `otError` return type is retained for backward compatibility.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Pending Operational Dataset.\n\n @retval OT_ERROR_NONE    Successfully set the Pending Operational Dataset.\n"]
    pub fn otDatasetSetPending(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Pending Operational Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Pending Operational Dataset.\n\n @retval OT_ERROR_NONE          Successfully set the Pending Operational Dataset.\n @retval OT_ERROR_INVALID_ARGS  The @p aDataset is invalid. It is too long or contains incorrect TLV formatting.\n"]
    pub fn otDatasetSetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_GET.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.\n @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.\n @param[in]  aLength             The length of @p aTlvTypes.\n @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n"]
    pub fn otDatasetSendMgmtActiveGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to operational dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.\n @param[in]  aContext   A pointer to application-specific context for @p aCallback.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_BUSY          A previous request is ongoing.\n"]
    pub fn otDatasetSendMgmtActiveSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_GET.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.\n @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.\n @param[in]  aLength             The length of @p aTlvTypes.\n @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n"]
    pub fn otDatasetSendMgmtPendingGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to operational dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.\n @param[in]  aContext   A pointer to application-specific context for @p aCallback.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_BUSY          A previous request is ongoing.\n"]
    pub fn otDatasetSendMgmtPendingSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Generates PSKc from a given pass-phrase, network name, and extended PAN ID.\n\n PSKc is used to establish the Commissioner Session.\n\n @param[in]  aPassPhrase   The commissioning pass-phrase.\n @param[in]  aNetworkName  The network name for PSKc computation.\n @param[in]  aExtPanId     The extended PAN ID for PSKc computation.\n @param[out] aPskc         A pointer to variable to output the generated PSKc.\n\n @retval OT_ERROR_NONE          Successfully generate PSKc.\n @retval OT_ERROR_INVALID_ARGS  If any of the input arguments is invalid.\n"]
    pub fn otDatasetGeneratePskc(
        aPassPhrase: *const crate::c_types::c_char,
        aNetworkName: *const otNetworkName,
        aExtPanId: *const otExtendedPanId,
        aPskc: *mut otPskc,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets an `otNetworkName` instance from a given null terminated C string.\n\n @p aNameString must follow UTF-8 encoding and the Network Name length must not be longer than\n `OT_NETWORK_NAME_MAX_SIZE`.\n\n @param[out] aNetworkName        A pointer to the `otNetworkName` to set.\n @param[in]  aNameString         A name C string.\n\n @retval OT_ERROR_NONE           Successfully set @p aNetworkName from @p aNameString.\n @retval OT_ERROR_INVALID_ARGS   @p aNameStrng is invalid (too long or does not follow UTF-8 encoding).\n"]
    pub fn otNetworkNameFromString(
        aNetworkName: *mut otNetworkName,
        aNameString: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Parses an Operational Dataset from a given `otOperationalDatasetTlvs`.\n\n @param[in]  aDatasetTlvs  A pointer to dataset TLVs.\n @param[out] aDataset      A pointer to where the dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully set @p aDataset from @p aDatasetTlvs.\n @retval OT_ERROR_INVALID_ARGS  @p aDatasetTlvs's length is longer than `OT_OPERATIONAL_DATASET_MAX_LENGTH`.\n"]
    pub fn otDatasetParseTlvs(
        aDatasetTlvs: *const otOperationalDatasetTlvs,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a given Operational Dataset to `otOperationalDatasetTlvs`.\n\n @param[in]  aDataset      An Operational dataset to convert to TLVs.\n @param[out] aDatasetTlvs  A pointer to dataset TLVs to return the result.\n"]
    pub fn otDatasetConvertToTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    );
}
extern "C" {
    #[doc = " Updates a given Operational Dataset.\n\n @p aDataset contains the fields to be updated and their new value.\n\n @param[in]     aDataset      Specifies the set of types and values to update.\n @param[in,out] aDatasetTlvs  A pointer to dataset TLVs to update.\n\n @retval OT_ERROR_NONE          Successfully updated @p aDatasetTlvs.\n @retval OT_ERROR_INVALID_ARGS  @p aDataset contains invalid values.\n @retval OT_ERROR_NO_BUFS       Not enough space space in @p aDatasetTlvs to apply the update.\n"]
    pub fn otDatasetUpdateTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
pub const otJoinerState_OT_JOINER_STATE_IDLE: otJoinerState = 0;
pub const otJoinerState_OT_JOINER_STATE_DISCOVER: otJoinerState = 1;
pub const otJoinerState_OT_JOINER_STATE_CONNECT: otJoinerState = 2;
pub const otJoinerState_OT_JOINER_STATE_CONNECTED: otJoinerState = 3;
pub const otJoinerState_OT_JOINER_STATE_ENTRUST: otJoinerState = 4;
pub const otJoinerState_OT_JOINER_STATE_JOINED: otJoinerState = 5;
#[doc = " Defines the Joiner State.\n"]
pub type otJoinerState = crate::c_types::c_uint;
#[doc = " Represents a Joiner Discerner.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otJoinerDiscerner {
    #[doc = "< Discerner value (the lowest `mLength` bits specify the discerner)."]
    pub mValue: u64,
    #[doc = "< Length (number of bits) - must be non-zero and at most `OT_JOINER_MAX_DISCERNER_LENGTH`."]
    pub mLength: u8,
}
#[doc = " Pointer is called to notify the completion of a join operation.\n\n @param[in]  aError    OT_ERROR_NONE if the join process succeeded.\n                       OT_ERROR_SECURITY if the join process failed due to security credentials.\n                       OT_ERROR_NOT_FOUND if no joinable network was discovered.\n                       OT_ERROR_RESPONSE_TIMEOUT if a response timed out.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Enables the Thread Joiner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aPskd             A pointer to the PSKd.\n @param[in]  aProvisioningUrl  A pointer to the Provisioning URL (may be NULL).\n @param[in]  aVendorName       A pointer to the Vendor Name (may be NULL).\n @param[in]  aVendorModel      A pointer to the Vendor Model (may be NULL).\n @param[in]  aVendorSwVersion  A pointer to the Vendor SW Version (may be NULL).\n @param[in]  aVendorData       A pointer to the Vendor Data (may be NULL).\n @param[in]  aCallback         A pointer to a function that is called when the join operation completes.\n @param[in]  aContext          A pointer to application-specific context.\n\n @retval OT_ERROR_NONE              Successfully started the Joiner role.\n @retval OT_ERROR_BUSY              The previous attempt is still on-going.\n @retval OT_ERROR_INVALID_ARGS      @p aPskd or @p aProvisioningUrl is invalid.\n @retval OT_ERROR_INVALID_STATE     The IPv6 stack is not enabled or Thread stack is fully enabled.\n"]
    pub fn otJoinerStart(
        aInstance: *mut otInstance,
        aPskd: *const crate::c_types::c_char,
        aProvisioningUrl: *const crate::c_types::c_char,
        aVendorName: *const crate::c_types::c_char,
        aVendorModel: *const crate::c_types::c_char,
        aVendorSwVersion: *const crate::c_types::c_char,
        aVendorData: *const crate::c_types::c_char,
        aCallback: otJoinerCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Disables the Thread Joiner role.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otJoinerStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Joiner State.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The joiner state.\n"]
    pub fn otJoinerGetState(aInstance: *mut otInstance) -> otJoinerState;
}
extern "C" {
    #[doc = " Gets the Joiner ID.\n\n If a Joiner Discerner is not set, Joiner ID is the first 64 bits of the result of computing SHA-256 over\n factory-assigned IEEE EUI-64. Otherwise the Joiner ID is calculated from the Joiner Discerner value.\n\n The Joiner ID is also used as the device's IEEE 802.15.4 Extended Address during the commissioning process.\n\n @param[in]   aInstance  A pointer to the OpenThread instance.\n\n @returns A pointer to the Joiner ID.\n"]
    pub fn otJoinerGetId(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the Joiner Discerner.\n\n The Joiner Discerner is used to calculate the Joiner ID during the Thread Commissioning process. For more\n information, refer to #otJoinerGetId.\n @note The Joiner Discerner takes the place of the Joiner EUI-64 during the joiner session of Thread Commissioning.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n @param[in]   aDiscerner   A pointer to a Joiner Discerner. If NULL clears any previously set discerner.\n\n @retval OT_ERROR_NONE           The Joiner Discerner updated successfully.\n @retval OT_ERROR_INVALID_ARGS   @p aDiscerner is not valid (specified length is not within valid range).\n @retval OT_ERROR_INVALID_STATE  There is an ongoing Joining process so Joiner Discerner could not be changed.\n"]
    pub fn otJoinerSetDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *mut otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Joiner Discerner. For more information, refer to #otJoinerSetDiscerner.\n\n @param[in]   aInstance       A pointer to the OpenThread instance.\n\n @returns A pointer to Joiner Discerner or NULL if none is set.\n"]
    pub fn otJoinerGetDiscerner(aInstance: *mut otInstance) -> *const otJoinerDiscerner;
}
extern "C" {
    #[doc = " Converts a given joiner state enumeration value to a human-readable string.\n\n @param[in] aState   The joiner state.\n\n @returns A human-readable string representation of @p aState.\n"]
    pub fn otJoinerStateToString(aState: otJoinerState) -> *const crate::c_types::c_char;
}
#[doc = "< Commissioner role is disabled."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_DISABLED: otCommissionerState = 0;
#[doc = "< Currently petitioning to become a Commissioner."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_PETITION: otCommissionerState = 1;
#[doc = "< Commissioner role is active."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_ACTIVE: otCommissionerState = 2;
#[doc = " Defines the Commissioner State.\n"]
pub type otCommissionerState = crate::c_types::c_uint;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_START: otCommissionerJoinerEvent = 0;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_CONNECTED: otCommissionerJoinerEvent = 1;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_FINALIZE: otCommissionerJoinerEvent = 2;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_END: otCommissionerJoinerEvent = 3;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_REMOVED: otCommissionerJoinerEvent = 4;
#[doc = " Defines a Joiner Event on the Commissioner.\n"]
pub type otCommissionerJoinerEvent = crate::c_types::c_uint;
#[doc = " Represents the steering data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSteeringData {
    #[doc = "< Length of steering data (bytes)"]
    pub mLength: u8,
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " Represents a Commissioning Dataset.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCommissioningDataset {
    #[doc = "< Border Router RLOC16"]
    pub mLocator: u16,
    #[doc = "< Commissioner Session Id"]
    pub mSessionId: u16,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otCommissioningDataset {
    #[inline]
    pub fn mIsLocatorSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsLocatorSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSessionIdSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSessionIdSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSteeringDataSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSteeringDataSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinerUdpPortSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinerUdpPortSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mHasExtraTlv(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mHasExtraTlv(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsLocatorSet: bool,
        mIsSessionIdSet: bool,
        mIsSteeringDataSet: bool,
        mIsJoinerUdpPortSet: bool,
        mHasExtraTlv: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsLocatorSet: u8 = unsafe { ::core::mem::transmute(mIsLocatorSet) };
            mIsLocatorSet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsSessionIdSet: u8 = unsafe { ::core::mem::transmute(mIsSessionIdSet) };
            mIsSessionIdSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsSteeringDataSet: u8 = unsafe { ::core::mem::transmute(mIsSteeringDataSet) };
            mIsSteeringDataSet as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsJoinerUdpPortSet: u8 = unsafe { ::core::mem::transmute(mIsJoinerUdpPortSet) };
            mIsJoinerUdpPortSet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mHasExtraTlv: u8 = unsafe { ::core::mem::transmute(mHasExtraTlv) };
            mHasExtraTlv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents a Joiner PSKd.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otJoinerPskd {
    #[doc = "< Char string array (must be null terminated - +1 is for null char)."]
    pub m8: [crate::c_types::c_char; 33usize],
}
#[doc = "< Accept any Joiner (no EUI64 or Discerner is specified)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_ANY: otJoinerInfoType = 0;
#[doc = "< Joiner EUI-64 is specified (`mSharedId.mEui64` in `otJoinerInfo`)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_EUI64: otJoinerInfoType = 1;
#[doc = "< Joiner Discerner is specified (`mSharedId.mDiscerner` in `otJoinerInfo`)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_DISCERNER: otJoinerInfoType = 2;
#[doc = " Defines a Joiner Info Type.\n"]
pub type otJoinerInfoType = crate::c_types::c_uint;
#[doc = " Represents a Joiner Info.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerInfo {
    #[doc = "< Joiner type."]
    pub mType: otJoinerInfoType,
    #[doc = "< Shared fields"]
    pub mSharedId: otJoinerInfo__bindgen_ty_1,
    #[doc = "< Joiner PSKd"]
    pub mPskd: otJoinerPskd,
    #[doc = "< Joiner expiration time in msec"]
    pub mExpirationTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otJoinerInfo__bindgen_ty_1 {
    #[doc = "< Joiner EUI64 (when `mType` is `OT_JOINER_INFO_TYPE_EUI64`)"]
    pub mEui64: otExtAddress,
    #[doc = "< Joiner Discerner (when `mType` is `OT_JOINER_INFO_TYPE_DISCERNER`)"]
    pub mDiscerner: otJoinerDiscerner,
}
#[doc = " Pointer is called whenever the commissioner state changes.\n\n @param[in]  aState    The Commissioner state.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otCommissionerStateCallback = ::core::option::Option<
    unsafe extern "C" fn(aState: otCommissionerState, aContext: *mut crate::c_types::c_void),
>;
#[doc = " Pointer is called whenever the joiner state changes.\n\n @param[in]  aEvent       The joiner event type.\n @param[in]  aJoinerInfo  A pointer to the Joiner Info.\n @param[in]  aJoinerId    A pointer to the Joiner ID (if not known, it will be NULL).\n @param[in]  aContext     A pointer to application-specific context.\n"]
pub type otCommissionerJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aEvent: otCommissionerJoinerEvent,
        aJoinerInfo: *const otJoinerInfo,
        aJoinerId: *const otExtAddress,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Enables the Thread Commissioner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aStateCallback    A pointer to a function that is called when the commissioner state changes.\n @param[in]  aJoinerCallback   A pointer to a function that is called with a joiner event occurs.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE           Successfully started the Commissioner service.\n @retval OT_ERROR_ALREADY        Commissioner is already started.\n @retval OT_ERROR_INVALID_STATE  Device is not currently attached to a network.\n"]
    pub fn otCommissionerStart(
        aInstance: *mut otInstance,
        aStateCallback: otCommissionerStateCallback,
        aJoinerCallback: otCommissionerJoinerCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Disables the Thread Commissioner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE     Successfully stopped the Commissioner service.\n @retval OT_ERROR_ALREADY  Commissioner is already stopped.\n"]
    pub fn otCommissionerStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Returns the Commissioner Id.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n\n @returns The Commissioner Id.\n"]
    pub fn otCommissionerGetId(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Sets the Commissioner Id.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aId           A pointer to a string character array. Must be null terminated.\n\n @retval OT_ERROR_NONE            Successfully set the Commissioner Id.\n @retval OT_ERROR_INVALID_ARGS    Given name is too long.\n @retval OT_ERROR_INVALID_STATE   The commissioner is active and id cannot be changed.\n"]
    pub fn otCommissionerSetId(
        aInstance: *mut otInstance,
        aId: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.\n @param[in]  aPskd              A pointer to the PSKd.\n @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.\n\n @retval OT_ERROR_NONE          Successfully added the Joiner.\n @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.\n @retval OT_ERROR_INVALID_ARGS  @p aEui64 or @p aPskd is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAddJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
        aPskd: *const crate::c_types::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a Joiner entry with a given Joiner Discerner value.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDiscerner         A pointer to the Joiner Discerner.\n @param[in]  aPskd              A pointer to the PSKd.\n @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.\n\n @retval OT_ERROR_NONE          Successfully added the Joiner.\n @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.\n @retval OT_ERROR_INVALID_ARGS  @p aDiscerner or @p aPskd is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAddJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
        aPskd: *const crate::c_types::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Get joiner info at aIterator position.\n\n @param[in]      aInstance   A pointer to instance.\n @param[in,out]  aIterator   A pointer to the Joiner Info iterator context.\n @param[out]     aJoiner     A reference to Joiner info.\n\n @retval OT_ERROR_NONE       Successfully get the Joiner info.\n @retval OT_ERROR_NOT_FOUND  Not found next Joiner.\n"]
    pub fn otCommissionerGetNextJoinerInfo(
        aInstance: *mut otInstance,
        aIterator: *mut u16,
        aJoiner: *mut otJoinerInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.\n\n @retval OT_ERROR_NONE          Successfully removed the Joiner.\n @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.\n @retval OT_ERROR_INVALID_ARGS  @p aEui64 is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerRemoveJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDiscerner         A pointer to the Joiner Discerner.\n\n @retval OT_ERROR_NONE          Successfully removed the Joiner.\n @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.\n @retval OT_ERROR_INVALID_ARGS  @p aDiscerner is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerRemoveJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Provisioning URL.\n\n @param[in]    aInstance       A pointer to an OpenThread instance.\n\n @returns A pointer to the URL string.\n"]
    pub fn otCommissionerGetProvisioningUrl(
        aInstance: *mut otInstance,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Sets the Provisioning URL.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aProvisioningUrl      A pointer to the Provisioning URL (may be NULL to set as empty string).\n\n @retval OT_ERROR_NONE          Successfully set the Provisioning URL.\n @retval OT_ERROR_INVALID_ARGS  @p aProvisioningUrl is invalid (too long).\n"]
    pub fn otCommissionerSetProvisioningUrl(
        aInstance: *mut otInstance,
        aProvisioningUrl: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends an Announce Begin message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aCount                The number of Announcement messages per channel.\n @param[in]  aPeriod               The time between two successive MLE Announce transmissions (in milliseconds).\n @param[in]  aAddress              A pointer to the IPv6 destination.\n\n @retval OT_ERROR_NONE          Successfully enqueued the Announce Begin message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Announce Begin message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAnnounceBegin(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aAddress: *const otIp6Address,
    ) -> otError;
}
#[doc = " Pointer is called when the Commissioner receives an Energy Report.\n\n @param[in]  aChannelMask       The channel mask value.\n @param[in]  aEnergyList        A pointer to the energy measurement list.\n @param[in]  aEnergyListLength  Number of entries in @p aEnergyListLength.\n @param[in]  aContext           A pointer to application-specific context.\n"]
pub type otCommissionerEnergyReportCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aChannelMask: u32,
        aEnergyList: *const u8,
        aEnergyListLength: u8,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Sends an Energy Scan Query message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aCount                The number of energy measurements per channel.\n @param[in]  aPeriod               The time between energy measurements (milliseconds).\n @param[in]  aScanDuration         The scan duration for each energy measurement (milliseconds).\n @param[in]  aAddress              A pointer to the IPv6 destination.\n @param[in]  aCallback             A pointer to a function called on receiving an Energy Report message.\n @param[in]  aContext              A pointer to application-specific context.\n\n @retval OT_ERROR_NONE          Successfully enqueued the Energy Scan Query message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Energy Scan Query message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerEnergyScan(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aScanDuration: u16,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerEnergyReportCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
#[doc = " Pointer is called when the Commissioner receives a PAN ID Conflict message.\n\n @param[in]  aPanId             The PAN ID value.\n @param[in]  aChannelMask       The channel mask value.\n @param[in]  aContext           A pointer to application-specific context.\n"]
pub type otCommissionerPanIdConflictCallback = ::core::option::Option<
    unsafe extern "C" fn(aPanId: u16, aChannelMask: u32, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Sends a PAN ID Query message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aPanId                The PAN ID to query.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aAddress              A pointer to the IPv6 destination.\n @param[in]  aCallback             A pointer to a function called on receiving a PAN ID Conflict message.\n @param[in]  aContext              A pointer to application-specific context.\n\n @retval OT_ERROR_NONE          Successfully enqueued the PAN ID Query message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate a PAN ID Query message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerPanIdQuery(
        aInstance: *mut otInstance,
        aPanId: u16,
        aChannelMask: u32,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerPanIdConflictCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_COMMISSIONER_GET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n"]
    pub fn otCommissionerSendMgmtGet(
        aInstance: *mut otInstance,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_COMMISSIONER_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to commissioning dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n"]
    pub fn otCommissionerSendMgmtSet(
        aInstance: *mut otInstance,
        aDataset: *const otCommissioningDataset,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Returns the Commissioner Session ID.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The current commissioner session id.\n"]
    pub fn otCommissionerGetSessionId(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Returns the Commissioner State.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval OT_COMMISSIONER_STATE_DISABLED  Commissioner disabled.\n @retval OT_COMMISSIONER_STATE_PETITION  Becoming the commissioner.\n @retval OT_COMMISSIONER_STATE_ACTIVE    Commissioner enabled.\n"]
    pub fn otCommissionerGetState(aInstance: *mut otInstance) -> otCommissionerState;
}
pub type otMacFilterIterator = u8;
#[doc = "< Address filter is disabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DISABLED: otMacFilterAddressMode = 0;
#[doc = "< Allowlist address filter mode is enabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_ALLOWLIST: otMacFilterAddressMode = 1;
#[doc = "< Denylist address filter mode is enabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DENYLIST: otMacFilterAddressMode = 2;
#[doc = " Defines address mode of the mac filter.\n"]
pub type otMacFilterAddressMode = crate::c_types::c_uint;
#[doc = " Represents a Mac Filter entry.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMacFilterEntry {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Received signal strength"]
    pub mRssIn: i8,
}
#[doc = " Represents the MAC layer counters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMacCounters {
    #[doc = " The total number of unique MAC frame transmission requests.\n\n Note that this counter is incremented for each MAC transmission request only by one,\n regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions.\n\n This increment rule applies to the following counters:\n   - @p mTxUnicast\n   - @p mTxBroadcast\n   - @p mTxAckRequested\n   - @p mTxNoAckRequested\n   - @p mTxData\n   - @p mTxDataPoll\n   - @p mTxBeacon\n   - @p mTxBeaconRequest\n   - @p mTxOther\n   - @p mTxErrAbort\n   - @p mTxErrBusyChannel\n\n The following equations are valid:\n   - @p mTxTotal = @p mTxUnicast + @p mTxBroadcast\n   - @p mTxTotal = @p mTxAckRequested + @p mTxNoAckRequested\n   - @p mTxTotal = @p mTxData + @p mTxDataPoll + @p mTxBeacon + @p mTxBeaconRequest + @p mTxOther\n"]
    pub mTxTotal: u32,
    #[doc = " The total number of unique unicast MAC frame transmission requests.\n"]
    pub mTxUnicast: u32,
    #[doc = " The total number of unique broadcast MAC frame transmission requests.\n"]
    pub mTxBroadcast: u32,
    #[doc = " The total number of unique MAC frame transmission requests with requested acknowledgment.\n"]
    pub mTxAckRequested: u32,
    #[doc = " The total number of unique MAC frame transmission requests that were acked.\n"]
    pub mTxAcked: u32,
    #[doc = " The total number of unique MAC frame transmission requests without requested acknowledgment.\n"]
    pub mTxNoAckRequested: u32,
    #[doc = " The total number of unique MAC Data frame transmission requests.\n"]
    pub mTxData: u32,
    #[doc = " The total number of unique MAC Data Poll frame transmission requests.\n"]
    pub mTxDataPoll: u32,
    #[doc = " The total number of unique MAC Beacon frame transmission requests.\n"]
    pub mTxBeacon: u32,
    #[doc = " The total number of unique MAC Beacon Request frame transmission requests.\n"]
    pub mTxBeaconRequest: u32,
    #[doc = " The total number of unique other MAC frame transmission requests.\n\n This counter is currently used for counting out-of-band frames.\n"]
    pub mTxOther: u32,
    #[doc = " The total number of MAC retransmission attempts.\n\n Note that this counter is incremented by one for each retransmission attempt that may be\n triggered by lack of acknowledgement, CSMA/CA failure, or other type of transmission error.\n The @p mTxRetry counter is incremented both for unicast and broadcast MAC frames.\n\n Modify the following configuration parameters to control the amount of retransmissions in the system:\n\n - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_DIRECT\n - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_INDIRECT\n - OPENTHREAD_CONFIG_MAC_TX_NUM_BCAST\n - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_DIRECT\n - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_INDIRECT\n\n Currently, this counter is invalid if the platform's radio driver capability includes\n @ref OT_RADIO_CAPS_TRANSMIT_RETRIES.\n"]
    pub mTxRetry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for direct packets.\n"]
    pub mTxDirectMaxRetryExpiry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for indirect packets.\n"]
    pub mTxIndirectMaxRetryExpiry: u32,
    #[doc = " The total number of CCA failures.\n\n The meaning of this counter can be different and it depends on the platform's radio driver capabilities.\n\n If @ref OT_RADIO_CAPS_CSMA_BACKOFF is enabled, this counter represents the total number of full CSMA/CA\n failed attempts and it is incremented by one also for each retransmission (in case of a CSMA/CA fail).\n\n If @ref OT_RADIO_CAPS_TRANSMIT_RETRIES is enabled, this counter represents the total number of full CSMA/CA\n failed attempts and it is incremented by one for each individual data frame request (regardless of the\n amount of retransmissions).\n"]
    pub mTxErrCca: u32,
    #[doc = " The total number of unique MAC transmission request failures cause by an abort error.\n"]
    pub mTxErrAbort: u32,
    #[doc = " The total number of unique MAC transmission requests failures caused by a busy channel (a CSMA/CA fail).\n"]
    pub mTxErrBusyChannel: u32,
    #[doc = " The total number of received frames.\n\n This counter counts all frames reported by the platform's radio driver, including frames\n that were dropped, for example because of an FCS error.\n"]
    pub mRxTotal: u32,
    #[doc = " The total number of unicast frames received.\n"]
    pub mRxUnicast: u32,
    #[doc = " The total number of broadcast frames received.\n"]
    pub mRxBroadcast: u32,
    #[doc = " The total number of MAC Data frames received.\n"]
    pub mRxData: u32,
    #[doc = " The total number of MAC Data Poll frames received.\n"]
    pub mRxDataPoll: u32,
    #[doc = " The total number of MAC Beacon frames received.\n"]
    pub mRxBeacon: u32,
    #[doc = " The total number of MAC Beacon Request frames received.\n"]
    pub mRxBeaconRequest: u32,
    #[doc = " The total number of other types of frames received.\n"]
    pub mRxOther: u32,
    #[doc = " The total number of frames dropped by MAC Filter module, for example received from denylisted node.\n"]
    pub mRxAddressFiltered: u32,
    #[doc = " The total number of frames dropped by destination address check, for example received frame for other node.\n"]
    pub mRxDestAddrFiltered: u32,
    #[doc = " The total number of frames dropped due to duplication, that is when the frame has been already received.\n\n This counter may be incremented, for example when ACK frame generated by the receiver hasn't reached\n transmitter node which performed retransmission.\n"]
    pub mRxDuplicated: u32,
    #[doc = " The total number of frames dropped because of missing or malformed content.\n"]
    pub mRxErrNoFrame: u32,
    #[doc = " The total number of frames dropped due to unknown neighbor.\n"]
    pub mRxErrUnknownNeighbor: u32,
    #[doc = " The total number of frames dropped due to invalid source address.\n"]
    pub mRxErrInvalidSrcAddr: u32,
    #[doc = " The total number of frames dropped due to security error.\n\n This counter may be incremented, for example when lower than expected Frame Counter is used\n to encrypt the frame.\n"]
    pub mRxErrSec: u32,
    #[doc = " The total number of frames dropped due to invalid FCS.\n"]
    pub mRxErrFcs: u32,
    #[doc = " The total number of frames dropped due to other error.\n"]
    pub mRxErrOther: u32,
}
#[doc = " Represents a received IEEE 802.15.4 Beacon.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct otActiveScanResult {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Thread Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Thread Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< IEEE 802.15.4 PAN ID"]
    pub mPanId: u16,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< RSSI (dBm)"]
    pub mRssi: i8,
    #[doc = "< LQI"]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otActiveScanResult {
    #[inline]
    pub fn mVersion(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNative(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNative(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDiscover(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDiscover(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mVersion: crate::c_types::c_uint,
        mIsNative: bool,
        mDiscover: bool,
        mIsJoinable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u32 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsNative: u8 = unsafe { ::core::mem::transmute(mIsNative) };
            mIsNative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mDiscover: u8 = unsafe { ::core::mem::transmute(mDiscover) };
            mDiscover as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsJoinable: u8 = unsafe { ::core::mem::transmute(mIsJoinable) };
            mIsJoinable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents an energy scan result.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otEnergyScanResult {
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< The max RSSI (dBm)"]
    pub mMaxRssi: i8,
}
#[doc = " Pointer is called during an IEEE 802.15.4 Active Scan when an IEEE 802.15.4 Beacon is received or\n the scan completes.\n\n @param[in]  aResult   A valid pointer to the beacon information or NULL when the active scan completes.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otHandleActiveScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otActiveScanResult, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Starts an IEEE 802.15.4 Active Scan\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aScanChannels     A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).\n @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.\n @param[in]  aCallback         A pointer to a function called on receiving a beacon or scan completes.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE  Accepted the Active Scan request.\n @retval OT_ERROR_BUSY  Already performing an Active Scan.\n"]
    pub fn otLinkActiveScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not an IEEE 802.15.4 Active Scan is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 Active Scan is in progress, false otherwise."]
    pub fn otLinkIsActiveScanInProgress(aInstance: *mut otInstance) -> bool;
}
#[doc = " Pointer is called during an IEEE 802.15.4 Energy Scan when the result for a channel is ready or the\n scan completes.\n\n @param[in]  aResult   A valid pointer to the energy scan result information or NULL when the energy scan completes.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otHandleEnergyScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otEnergyScanResult, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Starts an IEEE 802.15.4 Energy Scan\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aScanChannels     A bit vector indicating on which channels to perform energy scan.\n @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.\n @param[in]  aCallback         A pointer to a function called to pass on scan result on indicate scan completion.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE  Accepted the Energy Scan request.\n @retval OT_ERROR_BUSY  Could not start the energy scan.\n"]
    pub fn otLinkEnergyScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleEnergyScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not an IEEE 802.15.4 Energy Scan is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 Energy Scan is in progress, false otherwise.\n"]
    pub fn otLinkIsEnergyScanInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enqueues an IEEE 802.15.4 Data Request message for transmission.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully enqueued an IEEE 802.15.4 Data Request message.\n @retval OT_ERROR_INVALID_STATE  Device is not in rx-off-when-idle mode.\n @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.\n"]
    pub fn otLinkSendDataRequest(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not an IEEE 802.15.4 MAC is in the transmit state.\n\n MAC module is in the transmit state during CSMA/CA procedure, CCA, Data, Beacon or Data Request frame transmission\n and receiving an ACK of a transmitted frame. MAC module is not in the transmit state during transmission of an ACK\n frame or a Beacon Request frame.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 MAC is in the transmit state, false otherwise.\n"]
    pub fn otLinkIsInTransmitState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 channel.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The IEEE 802.15.4 channel.\n\n @sa otLinkSetChannel\n"]
    pub fn otLinkGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 channel\n\n Succeeds only when Thread protocols are disabled.  A successful call to this function invalidates the\n Active and Pending Operational Datasets in non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aChannel    The IEEE 802.15.4 channel.\n\n @retval  OT_ERROR_NONE           Successfully set the channel.\n @retval  OT_ERROR_INVALID_ARGS   If @p aChannel is not in the range [11, 26] or is not in the supported channel mask.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otLinkGetChannel\n"]
    pub fn otLinkSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Get the supported channel mask of MAC layer.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The supported channel mask as `uint32_t` with bit 0 (lsb) mapping to channel 0, bit 1 to channel 1, so on.\n"]
    pub fn otLinkGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the supported channel mask of MAC layer.\n\n Succeeds only when Thread protocols are disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aChannelMask  The supported channel mask (bit 0 or lsb mapping to channel 0, and so on).\n\n @retval  OT_ERROR_NONE           Successfully set the supported channel mask.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otLinkSetSupportedChannelMask(aInstance: *mut otInstance, aChannelMask: u32) -> otError;
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Extended Address.\n"]
    pub fn otLinkGetExtendedAddress(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended Address.\n\n @note Only succeeds when Thread protocols are disabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address.\n\n @retval OT_ERROR_NONE           Successfully set the IEEE 802.15.4 Extended Address.\n @retval OT_ERROR_INVALID_ARGS   @p aExtAddress was NULL.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otLinkSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the factory-assigned IEEE EUI-64.\n\n @param[in]   aInstance  A pointer to the OpenThread instance.\n @param[out]  aEui64     A pointer to where the factory-assigned IEEE EUI-64 is placed.\n"]
    pub fn otLinkGetFactoryAssignedIeeeEui64(aInstance: *mut otInstance, aEui64: *mut otExtAddress);
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 PAN ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The IEEE 802.15.4 PAN ID.\n\n @sa otLinkSetPanId\n"]
    pub fn otLinkGetPanId(aInstance: *mut otInstance) -> otPanId;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 PAN ID.\n\n Succeeds only when Thread protocols are disabled.  A successful call to this function also invalidates\n the Active and Pending Operational Datasets in non-volatile memory.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aPanId       The IEEE 802.15.4 PAN ID.\n\n @retval OT_ERROR_NONE           Successfully set the PAN ID.\n @retval OT_ERROR_INVALID_ARGS   If aPanId is not in the range [0, 65534].\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otLinkGetPanId\n"]
    pub fn otLinkSetPanId(aInstance: *mut otInstance, aPanId: otPanId) -> otError;
}
extern "C" {
    #[doc = " Get the data poll period of sleepy end device.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns  The data poll period of sleepy end device in milliseconds.\n\n @sa otLinkSetPollPeriod\n"]
    pub fn otLinkGetPollPeriod(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set/clear user-specified/external data poll period for sleepy end device.\n\n @note This function updates only poll period of sleepy end device. To update child timeout the function\n       `otThreadSetChildTimeout()` shall be called.\n\n @note Minimal non-zero value should be `OPENTHREAD_CONFIG_MAC_MINIMUM_POLL_PERIOD` (10ms).\n       Or zero to clear user-specified poll period.\n\n @note User-specified value should be no more than the maximal value 0x3FFFFFF ((1 << 26) - 1) allowed,\n otherwise it would be clipped by the maximal value.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aPollPeriod  data poll period in milliseconds.\n\n @retval OT_ERROR_NONE           Successfully set/cleared user-specified poll period.\n @retval OT_ERROR_INVALID_ARGS   If aPollPeriod is invalid.\n\n @sa otLinkGetPollPeriod\n"]
    pub fn otLinkSetPollPeriod(aInstance: *mut otInstance, aPollPeriod: u32) -> otError;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 Short Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Short Address.\n"]
    pub fn otLinkGetShortAddress(aInstance: *mut otInstance) -> otShortAddress;
}
extern "C" {
    #[doc = " Returns the maximum number of frame retries during direct transmission.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The maximum number of retries during direct transmission.\n"]
    pub fn otLinkGetMaxFrameRetriesDirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the maximum number of frame retries during direct transmission.\n\n @param[in]  aInstance               A pointer to an OpenThread instance.\n @param[in]  aMaxFrameRetriesDirect  The maximum number of retries during direct transmission.\n"]
    pub fn otLinkSetMaxFrameRetriesDirect(aInstance: *mut otInstance, aMaxFrameRetriesDirect: u8);
}
extern "C" {
    #[doc = " Returns the maximum number of frame retries during indirect transmission.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The maximum number of retries during indirect transmission.\n"]
    pub fn otLinkGetMaxFrameRetriesIndirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the maximum number of frame retries during indirect transmission.\n\n @param[in]  aInstance                 A pointer to an OpenThread instance.\n @param[in]  aMaxFrameRetriesIndirect  The maximum number of retries during indirect transmission.\n"]
    pub fn otLinkSetMaxFrameRetriesIndirect(
        aInstance: *mut otInstance,
        aMaxFrameRetriesIndirect: u8,
    );
}
extern "C" {
    #[doc = " Gets the current MAC frame counter value.\n\n @param[in] aInstance    A pointer to the OpenThread instance.\n\n @returns The current MAC frame counter value.\n"]
    pub fn otLinkGetFrameCounter(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the address mode of MAC filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns  the address mode.\n"]
    pub fn otLinkFilterGetAddressMode(aInstance: *mut otInstance) -> otMacFilterAddressMode;
}
extern "C" {
    #[doc = " Sets the address mode of MAC filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aMode      The address mode to set.\n"]
    pub fn otLinkFilterSetAddressMode(aInstance: *mut otInstance, aMode: otMacFilterAddressMode);
}
extern "C" {
    #[doc = " Adds an Extended Address to MAC filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE           Successfully added @p aExtAddress to MAC filter.\n @retval OT_ERROR_NO_BUFS        No available entry exists.\n"]
    pub fn otLinkFilterAddAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes an Extended Address from MAC filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n No action is performed if there is no existing entry in Filter matching the given Extended Address.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).\n"]
    pub fn otLinkFilterRemoveAddress(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " Clears all the Extended Addresses from MAC filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearAddresses(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets an in-use address filter entry.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the MAC filter iterator context. To get the first in-use address filter\n                            entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT. MUST NOT be NULL.\n @param[out]     aEntry     A pointer to where the information is placed. MUST NOT be NULL.\n\n @retval OT_ERROR_NONE          Successfully retrieved an in-use address filter entry.\n @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.\n"]
    pub fn otLinkFilterGetNextAddress(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds the specified Extended Address to the `RssIn` list (or modifies an existing\n address in the `RssIn` list) and sets the received signal strength (in dBm) entry\n for messages from that address. The Extended Address does not necessarily have\n to be in the `address allowlist/denylist` filter to set the `rss`.\n @note The `RssIn` list contains Extended Addresses whose `rss` or link quality indicator (`lqi`)\n values have been set to be different from the defaults.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.\n @param[in]  aRss         A received signal strength (in dBm).\n\n @retval OT_ERROR_NONE           Successfully added an entry for @p aExtAddress and @p aRss.\n @retval OT_ERROR_NO_BUFS        No available entry exists.\n"]
    pub fn otLinkFilterAddRssIn(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aRss: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes the specified Extended Address from the `RssIn` list. Once removed\n from the `RssIn` list, this MAC address will instead use the default `rss`\n and `lqi` settings, assuming defaults have been set.\n (If no defaults have been set, the over-air signal is used.)\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n No action is performed if there is no existing entry in the `RssIn` list matching the specified Extended Address.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.\n"]
    pub fn otLinkFilterRemoveRssIn(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " Sets the default received signal strength (in dBm) on MAC Filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n The default RSS value is used for all received frames from addresses for which there is no explicit RSS-IN entry\n in the Filter list (added using `otLinkFilterAddRssIn()`).\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aRss         The default received signal strength (in dBm) to set.\n"]
    pub fn otLinkFilterSetDefaultRssIn(aInstance: *mut otInstance, aRss: i8);
}
extern "C" {
    #[doc = " Clears any previously set default received signal strength (in dBm) on MAC Filter.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearDefaultRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Clears all the received signal strength (`rss`) and link quality\n indicator (`lqi`) entries (including defaults) from the `RssIn` list.\n Performing this action means that all Extended Addresses will use the on-air signal.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearAllRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets an in-use RssIn filter entry.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the MAC filter iterator context. MUST NOT be NULL.\n                            To get the first entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT.\n @param[out]     aEntry     A pointer to where the information is placed. The last entry would have the extended\n                            address as all 0xff to indicate the default received signal strength if it was set.\n@p aEntry MUST NOT be NULL.\n\n @retval OT_ERROR_NONE          Successfully retrieved the next entry.\n @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.\n"]
    pub fn otLinkFilterGetNextRssIn(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables/disables IEEE 802.15.4 radio filter mode.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n The radio filter is mainly intended for testing. It can be used to temporarily block all tx/rx on the 802.15.4 radio.\n When radio filter is enabled, radio is put to sleep instead of receive (to ensure device does not receive any frame\n and/or potentially send ack). Also the frame transmission requests return immediately without sending the frame over\n the air (return \"no ack\" error if ack is requested, otherwise return success).\n\n @param[in] aInstance         A pointer to an OpenThread instance.\n @param[in] aFilterEnabled    TRUE to enable radio filter, FALSE to disable\n"]
    pub fn otLinkSetRadioFilterEnabled(aInstance: *mut otInstance, aFilterEnabled: bool);
}
extern "C" {
    #[doc = " Indicates whether the IEEE 802.15.4 radio filter is enabled or not.\n\n Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.\n\n @retval TRUE   If the radio filter is enabled.\n @retval FALSE  If the radio filter is disabled.\n"]
    pub fn otLinkIsRadioFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Converts received signal strength to link quality.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aRss       The received signal strength value to be converted.\n\n @return Link quality value mapping to @p aRss.\n"]
    pub fn otLinkConvertRssToLinkQuality(aInstance: *mut otInstance, aRss: i8) -> u8;
}
extern "C" {
    #[doc = " Converts link quality to typical received signal strength.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aLinkQuality  LinkQuality value, should be in range [0,3].\n\n @return Typical platform received signal strength mapping to @p aLinkQuality.\n"]
    pub fn otLinkConvertLinkQualityToRss(aInstance: *mut otInstance, aLinkQuality: u8) -> i8;
}
extern "C" {
    #[doc = " Gets histogram of retries for a single direct packet until success.\n\n Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.\n\n @returns     A pointer to the histogram of retries (in a form of an array).\n              The n-th element indicates that the packet has been sent with n-th retry."]
    pub fn otLinkGetTxDirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " Gets histogram of retries for a single indirect packet until success.\n\n Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.\n\n @returns     A pointer to the histogram of retries (in a form of an array).\n              The n-th element indicates that the packet has been sent with n-th retry.\n"]
    pub fn otLinkGetTxIndirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " Clears histogram statistics for direct and indirect transmissions.\n\n Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n"]
    pub fn otLinkResetTxRetrySuccessHistogram(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the MAC layer counters.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the MAC layer counters.\n"]
    pub fn otLinkGetCounters(aInstance: *mut otInstance) -> *const otMacCounters;
}
extern "C" {
    #[doc = " Resets the MAC layer counters.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otLinkResetCounters(aInstance: *mut otInstance);
}
#[doc = " Pointer is called when an IEEE 802.15.4 frame is received.\n\n @note This callback is called after FCS processing and @p aFrame may not contain the actual FCS that was received.\n\n @note This callback is called before IEEE 802.15.4 security processing.\n\n @param[in]  aFrame    A pointer to the received IEEE 802.15.4 frame.\n @param[in]  aIsTx     Whether this frame is transmitted, not received.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otLinkPcapCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aFrame: *const otRadioFrame,
        aIsTx: bool,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Registers a callback to provide received raw IEEE 802.15.4 frames.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aPcapCallback     A pointer to a function that is called when receiving an IEEE 802.15.4 link frame or\n                               NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n"]
    pub fn otLinkSetPcapCallback(
        aInstance: *mut otInstance,
        aPcapCallback: otLinkPcapCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Indicates whether or not promiscuous mode is enabled at the link layer.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   Promiscuous mode is enabled.\n @retval FALSE  Promiscuous mode is not enabled.\n"]
    pub fn otLinkIsPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enables or disables the link layer promiscuous mode.\n\n @note Promiscuous mode may only be enabled when the Thread interface is disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aPromiscuous  true to enable promiscuous mode, or false otherwise.\n\n @retval OT_ERROR_NONE           Successfully enabled promiscuous mode.\n @retval OT_ERROR_INVALID_STATE  Could not enable promiscuous mode because\n                                 the Thread interface is enabled.\n"]
    pub fn otLinkSetPromiscuous(aInstance: *mut otInstance, aPromiscuous: bool) -> otError;
}
extern "C" {
    #[doc = " Gets the CSL channel.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL channel.\n"]
    pub fn otLinkGetCslChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the CSL channel.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aChannel       The CSL sample channel. Channel value should be `0` (Set CSL Channel unspecified) or\n                            within the range [1, 10] (if 915-MHz supported) and [11, 26] (if 2.4 GHz supported).\n\n @retval OT_ERROR_NONE           Successfully set the CSL parameters.\n @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel.\n"]
    pub fn otLinkSetCslChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Gets the CSL period in microseconds\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL period in microseconds.\n"]
    pub fn otLinkGetCslPeriod(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the CSL period in microseconds. Disable CSL by setting this parameter to `0`.\n\n The CSL period MUST be a multiple of `OT_LINK_CSL_PERIOD_TEN_SYMBOLS_UNIT_IN_USEC`, otherwise `OT_ERROR_INVALID_ARGS`\n is returned.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aPeriod        The CSL period in microseconds.\n\n @retval OT_ERROR_NONE           Successfully set the CSL period.\n @retval OT_ERROR_INVALID_ARGS   Invalid CSL period\n"]
    pub fn otLinkSetCslPeriod(aInstance: *mut otInstance, aPeriod: u32) -> otError;
}
extern "C" {
    #[doc = " Gets the CSL timeout.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL timeout in seconds.\n"]
    pub fn otLinkGetCslTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the CSL timeout in seconds.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aTimeout       The CSL timeout in seconds.\n\n @retval OT_ERROR_NONE           Successfully set the CSL timeout.\n @retval OT_ERROR_INVALID_ARGS   Invalid CSL timeout.\n"]
    pub fn otLinkSetCslTimeout(aInstance: *mut otInstance, aTimeout: u32) -> otError;
}
extern "C" {
    #[doc = " Returns the current CCA (Clear Channel Assessment) failure rate.\n\n The rate is maintained over a window of (roughly) last `OPENTHREAD_CONFIG_CCA_FAILURE_RATE_AVERAGING_WINDOW`\n frame transmissions.\n\n @returns The CCA failure rate with maximum value `0xffff` corresponding to 100% failure rate.\n"]
    pub fn otLinkGetCcaFailureRate(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Enables or disables the link layer.\n\n @note The link layer may only be enabled / disabled when the Thread Interface is disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aEnable       true to enable the link layer, or false otherwise.\n\n @retval OT_ERROR_NONE          Successfully enabled / disabled the link layer.\n @retval OT_ERROR_INVALID_STATE Could not disable the link layer because\n                                the Thread interface is enabled.\n"]
    pub fn otLinkSetEnabled(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not the link layer is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   Link layer is enabled.\n @retval FALSE  Link layer is not enabled.\n"]
    pub fn otLinkIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Indicates whether or not CSL is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   Link layer is CSL enabled.\n @retval FALSE  Link layer is not CSL enabled.\n"]
    pub fn otLinkIsCslEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Indicates whether the device is connected to a parent which supports CSL.\n\n @retval TRUE   If parent supports CSL.\n @retval FALSE  If parent does not support CSL.\n"]
    pub fn otLinkIsCslSupported(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Instructs the device to send an empty IEEE 802.15.4 data frame.\n\n Is only supported on an Rx-Off-When-Idle device to send an empty data frame to its parent.\n Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully enqueued an empty message.\n @retval OT_ERROR_INVALID_STATE  Device is not in Rx-Off-When-Idle mode.\n @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.\n"]
    pub fn otLinkSendEmptyData(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Sets the region code.\n\n The radio region format is the 2-bytes ascii representation of the ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char\n                          and the `aRegionCode & 0xff` is the second ascii char.\n\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully set region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otLinkSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
extern "C" {
    #[doc = " Get the region code.\n\n The radio region format is the 2-bytes ascii representation of the ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[out] aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char\n                          and the `aRegionCode & 0xff` is the second ascii char.\n\n @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully got region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otLinkGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
#[doc = "< The Thread stack is disabled."]
pub const otDeviceRole_OT_DEVICE_ROLE_DISABLED: otDeviceRole = 0;
#[doc = "< Not currently participating in a Thread network/partition."]
pub const otDeviceRole_OT_DEVICE_ROLE_DETACHED: otDeviceRole = 1;
#[doc = "< The Thread Child role."]
pub const otDeviceRole_OT_DEVICE_ROLE_CHILD: otDeviceRole = 2;
#[doc = "< The Thread Router role."]
pub const otDeviceRole_OT_DEVICE_ROLE_ROUTER: otDeviceRole = 3;
#[doc = "< The Thread Leader role."]
pub const otDeviceRole_OT_DEVICE_ROLE_LEADER: otDeviceRole = 4;
#[doc = " Represents a Thread device role.\n"]
pub type otDeviceRole = crate::c_types::c_uint;
#[doc = " Represents an MLE Link Mode configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otLinkModeConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkModeConfig {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDeviceType(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDeviceType(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mDeviceType: bool,
        mNetworkData: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mDeviceType: u8 = unsafe { ::core::mem::transmute(mDeviceType) };
            mDeviceType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNetworkData: u8 = unsafe { ::core::mem::transmute(mNetworkData) };
            mNetworkData as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Holds diagnostic information for a neighboring Thread node\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNeighborInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Seconds since last heard"]
    pub mAge: u32,
    #[doc = "< Seconds since link establishment (requires `CONFIG_UPTIME_ENABLE`)"]
    pub mConnectionTime: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Link Frame Counter"]
    pub mLinkFrameCounter: u32,
    #[doc = "< MLE Frame Counter"]
    pub mMleFrameCounter: u32,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Link Margin"]
    pub mLinkMargin: u8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    #[doc = "< Thread version of the neighbor"]
    pub mVersion: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otNeighborInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChild(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsChild: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::core::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::core::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsChild: u8 = unsafe { ::core::mem::transmute(mIsChild) };
            mIsChild as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otNeighborInfoIterator = i16;
#[doc = " Represents the Thread Leader Data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otLeaderData {
    #[doc = "< Partition ID"]
    pub mPartitionId: u32,
    #[doc = "< Leader Weight"]
    pub mWeighting: u8,
    #[doc = "< Full Network Data Version"]
    pub mDataVersion: u8,
    #[doc = "< Stable Network Data Version"]
    pub mStableDataVersion: u8,
    #[doc = "< Leader Router ID"]
    pub mLeaderRouterId: u8,
}
#[doc = " Holds diagnostic information for a Thread Router\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRouterInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Router ID"]
    pub mRouterId: u8,
    #[doc = "< Next hop to router"]
    pub mNextHop: u8,
    #[doc = "< Path cost to router"]
    pub mPathCost: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Link Quality Out"]
    pub mLinkQualityOut: u8,
    #[doc = "< Time last heard"]
    pub mAge: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Thread version"]
    pub mVersion: u8,
    #[doc = "< CSL clock accuracy, in  ppm"]
    pub mCslClockAccuracy: u8,
    #[doc = "< CSL uncertainty, in 10 us"]
    pub mCslUncertainty: u8,
}
impl otRouterInfo {
    #[inline]
    pub fn mAllocated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllocated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkEstablished(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkEstablished(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAllocated: bool,
        mLinkEstablished: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAllocated: u8 = unsafe { ::core::mem::transmute(mAllocated) };
            mAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLinkEstablished: u8 = unsafe { ::core::mem::transmute(mLinkEstablished) };
            mLinkEstablished as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents the IP level counters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIpCounters {
    #[doc = "< The number of IPv6 packets successfully transmitted."]
    pub mTxSuccess: u32,
    #[doc = "< The number of IPv6 packets successfully received."]
    pub mRxSuccess: u32,
    #[doc = "< The number of IPv6 packets failed to transmit."]
    pub mTxFailure: u32,
    #[doc = "< The number of IPv6 packets failed to receive."]
    pub mRxFailure: u32,
}
#[doc = " Represents the Thread MLE counters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMleCounters {
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_CHILD role."]
    pub mChildRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderRole: u16,
    #[doc = "< Number of attach attempts while device was detached."]
    pub mAttachAttempts: u16,
    #[doc = "< Number of changes to partition ID."]
    pub mPartitionIdChanges: u16,
    #[doc = "< Number of attempts to attach to a better partition."]
    pub mBetterPartitionAttachAttempts: u16,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role."]
    pub mChildTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderTime: u64,
    #[doc = "< Number of milliseconds tracked by previous counters."]
    pub mTrackedTime: u64,
    #[doc = " Number of times device changed its parent.\n\n A parent change can happen if device detaches from its current parent and attaches to a different one, or even\n while device is attached when the periodic parent search feature is enabled  (please see option\n OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE).\n"]
    pub mParentChanges: u16,
}
#[doc = " Represents the MLE Parent Response data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otThreadParentResponseInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the Parent"]
    pub mExtAddr: otExtAddress,
    #[doc = "< Short address of the Parent"]
    pub mRloc16: u16,
    #[doc = "< Rssi of the Parent"]
    pub mRssi: i8,
    #[doc = "< Parent priority"]
    pub mPriority: i8,
    #[doc = "< Parent Link Quality 3"]
    pub mLinkQuality3: u8,
    #[doc = "< Parent Link Quality 2"]
    pub mLinkQuality2: u8,
    #[doc = "< Parent Link Quality 1"]
    pub mLinkQuality1: u8,
    #[doc = "< Is the node receiving parent response attached"]
    pub mIsAttached: bool,
}
#[doc = " This callback informs the application that the detaching process has finished.\n\n @param[in] aContext A pointer to application-specific context.\n"]
pub type otDetachGracefullyCallback =
    ::core::option::Option<unsafe extern "C" fn(aContext: *mut crate::c_types::c_void)>;
extern "C" {
    #[doc = " Starts Thread protocol operation.\n\n The interface must be up when calling this function.\n\n Calling this function with @p aEnabled set to FALSE stops any ongoing processes of detaching started by\n otThreadDetachGracefully(). Its callback will be called.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE if Thread is enabled, FALSE otherwise.\n\n @retval OT_ERROR_NONE           Successfully started Thread protocol operation.\n @retval OT_ERROR_INVALID_STATE  The network interface was not up.\n"]
    pub fn otThreadSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread protocol version.\n\n The constants `OT_THREAD_VERSION_*` define the numerical version values.\n\n @returns the Thread protocol version.\n"]
    pub fn otThreadGetVersion() -> u16;
}
extern "C" {
    #[doc = " Indicates whether a node is the only router on the network.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   It is the only router in the network.\n @retval FALSE  It is a child or is not a single router in the network.\n"]
    pub fn otThreadIsSingleton(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Starts a Thread Discovery scan.\n\n @note A successful call to this function enables the rx-on-when-idle mode for the entire scan procedure.\n\n @param[in]  aInstance              A pointer to an OpenThread instance.\n @param[in]  aScanChannels          A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).\n @param[in]  aPanId                 The PAN ID filter (set to Broadcast PAN to disable filter).\n @param[in]  aJoiner                Value of the Joiner Flag in the Discovery Request TLV.\n @param[in]  aEnableEui64Filtering  TRUE to filter responses on EUI-64, FALSE otherwise.\n @param[in]  aCallback              A pointer to a function called on receiving an MLE Discovery Response or\n                                    scan completes.\n @param[in]  aCallbackContext       A pointer to application-specific context.\n\n @retval OT_ERROR_NONE           Successfully started a Thread Discovery Scan.\n @retval OT_ERROR_INVALID_STATE  The IPv6 interface is not enabled (netif is not up).\n @retval OT_ERROR_NO_BUFS        Could not allocate message for Discovery Request.\n @retval OT_ERROR_BUSY           Thread Discovery Scan is already in progress.\n"]
    pub fn otThreadDiscover(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aPanId: u16,
        aJoiner: bool,
        aEnableEui64Filtering: bool,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Determines if an MLE Thread Discovery is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otThreadIsDiscoverInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Sets the Thread Joiner Advertisement when discovering Thread network.\n\n Thread Joiner Advertisement is used to allow a Joiner to advertise its own application-specific information\n (such as Vendor ID, Product ID, Discriminator, etc.) via a newly-proposed Joiner Advertisement TLV,\n and to make this information available to Commissioners or Commissioner Candidates without human interaction.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aOui             The Vendor IEEE OUI value that will be included in the Joiner Advertisement. Only the\n                              least significant 3 bytes will be used, and the most significant byte will be ignored.\n @param[in]  aAdvData         A pointer to the AdvData that will be included in the Joiner Advertisement.\n @param[in]  aAdvDataLength   The length of AdvData in bytes.\n\n @retval OT_ERROR_NONE         Successfully set Joiner Advertisement.\n @retval OT_ERROR_INVALID_ARGS Invalid AdvData.\n"]
    pub fn otThreadSetJoinerAdvertisement(
        aInstance: *mut otInstance,
        aOui: u32,
        aAdvData: *const u8,
        aAdvDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Child Timeout (in seconds) used when operating in the Child role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Thread Child Timeout value in seconds.\n\n @sa otThreadSetChildTimeout\n"]
    pub fn otThreadGetChildTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the Thread Child Timeout (in seconds) used when operating in the Child role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aTimeout  The timeout value in seconds.\n\n @sa otThreadGetChildTimeout\n"]
    pub fn otThreadSetChildTimeout(aInstance: *mut otInstance, aTimeout: u32);
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended PAN ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Extended PAN ID.\n\n @sa otThreadSetExtendedPanId\n"]
    pub fn otThreadGetExtendedPanId(aInstance: *mut otInstance) -> *const otExtendedPanId;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended PAN ID.\n\n @note Can only be called while Thread protocols are disabled. A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aExtendedPanId  A pointer to the IEEE 802.15.4 Extended PAN ID.\n\n @retval OT_ERROR_NONE           Successfully set the Extended PAN ID.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetExtendedPanId\n"]
    pub fn otThreadSetExtendedPanId(
        aInstance: *mut otInstance,
        aExtendedPanId: *const otExtendedPanId,
    ) -> otError;
}
extern "C" {
    #[doc = " Returns a pointer to the Leader's RLOC.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLeaderRloc  A pointer to the Leader's RLOC.\n\n @retval OT_ERROR_NONE          The Leader's RLOC was successfully written to @p aLeaderRloc.\n @retval OT_ERROR_INVALID_ARGS  @p aLeaderRloc was NULL.\n @retval OT_ERROR_DETACHED      Not currently attached to a Thread Partition.\n"]
    pub fn otThreadGetLeaderRloc(
        aInstance: *mut otInstance,
        aLeaderRloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the MLE Link Mode configuration.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The MLE Link Mode configuration.\n\n @sa otThreadSetLinkMode\n"]
    pub fn otThreadGetLinkMode(aInstance: *mut otInstance) -> otLinkModeConfig;
}
extern "C" {
    #[doc = " Set the MLE Link Mode configuration.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aConfig   A pointer to the Link Mode configuration.\n\n @retval OT_ERROR_NONE  Successfully set the MLE Link Mode configuration.\n\n @sa otThreadGetLinkMode\n"]
    pub fn otThreadSetLinkMode(aInstance: *mut otInstance, aConfig: otLinkModeConfig) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Key.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[out]  aNetworkKey   A pointer to an `otNetworkKey` to return the Thread Network Key.\n\n @sa otThreadSetNetworkKey\n"]
    pub fn otThreadGetNetworkKey(aInstance: *mut otInstance, aNetworkKey: *mut otNetworkKey);
}
extern "C" {
    #[doc = " Get the `otNetworkKeyRef` for Thread Network Key.\n\n Requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n\n @returns Reference to the Thread Network Key stored in memory.\n\n @sa otThreadSetNetworkKeyRef\n"]
    pub fn otThreadGetNetworkKeyRef(aInstance: *mut otInstance) -> otNetworkKeyRef;
}
extern "C" {
    #[doc = " Set the Thread Network Key.\n\n Succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aKey        A pointer to a buffer containing the Thread Network Key.\n\n @retval OT_ERROR_NONE            Successfully set the Thread Network Key.\n @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.\n\n @sa otThreadGetNetworkKey\n"]
    pub fn otThreadSetNetworkKey(aInstance: *mut otInstance, aKey: *const otNetworkKey) -> otError;
}
extern "C" {
    #[doc = " Set the Thread Network Key as a `otNetworkKeyRef`.\n\n Succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n Requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aKeyRef     Reference to the Thread Network Key.\n\n @retval OT_ERROR_NONE            Successfully set the Thread Network Key.\n @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.\n\n @sa otThreadGetNetworkKeyRef\n"]
    pub fn otThreadSetNetworkKeyRef(
        aInstance: *mut otInstance,
        aKeyRef: otNetworkKeyRef,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Routing Locator (RLOC) address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Routing Locator (RLOC) address.\n"]
    pub fn otThreadGetRloc(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Mesh Local EID address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Mesh Local EID address.\n"]
    pub fn otThreadGetMeshLocalEid(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Returns a pointer to the Mesh Local Prefix.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Mesh Local Prefix.\n"]
    pub fn otThreadGetMeshLocalPrefix(aInstance: *mut otInstance) -> *const otMeshLocalPrefix;
}
extern "C" {
    #[doc = " Sets the Mesh Local Prefix.\n\n Succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aMeshLocalPrefix  A pointer to the Mesh Local Prefix.\n\n @retval OT_ERROR_NONE           Successfully set the Mesh Local Prefix.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otThreadSetMeshLocalPrefix(
        aInstance: *mut otInstance,
        aMeshLocalPrefix: *const otMeshLocalPrefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread link-local IPv6 address.\n\n The Thread link local address is derived using IEEE802.15.4 Extended Address as Interface Identifier.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread link-local IPv6 address.\n"]
    pub fn otThreadGetLinkLocalIp6Address(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Link-Local All Thread Nodes multicast address.\n\n The address is a link-local Unicast Prefix-Based Multicast Address [RFC 3306], with:\n   - flgs set to 3 (P = 1 and T = 1)\n   - scop set to 2\n   - plen set to 64\n   - network prefix set to the Mesh Local Prefix\n   - group ID set to 1\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread Link-Local All Thread Nodes multicast address.\n"]
    pub fn otThreadGetLinkLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Realm-Local All Thread Nodes multicast address.\n\n The address is a realm-local Unicast Prefix-Based Multicast Address [RFC 3306], with:\n   - flgs set to 3 (P = 1 and T = 1)\n   - scop set to 3\n   - plen set to 64\n   - network prefix set to the Mesh Local Prefix\n   - group ID set to 1\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread Realm-Local All Thread Nodes multicast address.\n"]
    pub fn otThreadGetRealmLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Retrieves the Service ALOC for given Service ID.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[in]   aServiceId    Service ID to get ALOC for.\n @param[out]  aServiceAloc  A pointer to output the Service ALOC. MUST NOT BE NULL.\n\n @retval OT_ERROR_NONE      Successfully retrieved the Service ALOC.\n @retval OT_ERROR_DETACHED  The Thread interface is not currently attached to a Thread Partition."]
    pub fn otThreadGetServiceAloc(
        aInstance: *mut otInstance,
        aServiceId: u8,
        aServiceAloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Name.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Network Name.\n\n @sa otThreadSetNetworkName\n"]
    pub fn otThreadGetNetworkName(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Set the Thread Network Name.\n\n Succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aNetworkName  A pointer to the Thread Network Name.\n\n @retval OT_ERROR_NONE           Successfully set the Thread Network Name.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetNetworkName\n"]
    pub fn otThreadSetNetworkName(
        aInstance: *mut otInstance,
        aNetworkName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Domain Name.\n\n @note Available since Thread 1.2.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Domain Name.\n\n @sa otThreadSetDomainName\n"]
    pub fn otThreadGetDomainName(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Sets the Thread Domain Name. Only succeeds when Thread protocols are disabled.\n\n @note Available since Thread 1.2.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aDomainName   A pointer to the Thread Domain Name.\n\n @retval OT_ERROR_NONE           Successfully set the Thread Domain Name.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetDomainName\n"]
    pub fn otThreadSetDomainName(
        aInstance: *mut otInstance,
        aDomainName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or clears the Interface Identifier manually specified for the Thread Domain Unicast Address.\n\n Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.\n\n @note Only available since Thread 1.2.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aIid        A pointer to the Interface Identifier to set or NULL to clear.\n\n @retval OT_ERROR_NONE           Successfully set/cleared the Interface Identifier.\n @retval OT_ERROR_INVALID_ARGS   The specified Interface Identifier is reserved.\n\n @sa otThreadGetFixedDuaInterfaceIdentifier"]
    pub fn otThreadSetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Interface Identifier manually specified for the Thread Domain Unicast Address.\n\n Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.\n\n @note Only available since Thread 1.2.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Interface Identifier which was set manually, or NULL if none was set.\n\n @sa otThreadSetFixedDuaInterfaceIdentifier\n"]
    pub fn otThreadGetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
    ) -> *const otIp6InterfaceIdentifier;
}
extern "C" {
    #[doc = " Gets the thrKeySequenceCounter.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The thrKeySequenceCounter value.\n\n @sa otThreadSetKeySequenceCounter\n"]
    pub fn otThreadGetKeySequenceCounter(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySequenceCounter.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aKeySequenceCounter  The thrKeySequenceCounter value.\n\n @sa otThreadGetKeySequenceCounter\n"]
    pub fn otThreadSetKeySequenceCounter(aInstance: *mut otInstance, aKeySequenceCounter: u32);
}
extern "C" {
    #[doc = " Gets the thrKeySwitchGuardTime (in hours).\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The thrKeySwitchGuardTime value (in hours).\n\n @sa otThreadSetKeySwitchGuardTime\n"]
    pub fn otThreadGetKeySwitchGuardTime(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the thrKeySwitchGuardTime (in hours).\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aKeySwitchGuardTime  The thrKeySwitchGuardTime value (in hours).\n\n @sa otThreadGetKeySwitchGuardTime\n"]
    pub fn otThreadSetKeySwitchGuardTime(aInstance: *mut otInstance, aKeySwitchGuardTime: u16);
}
extern "C" {
    #[doc = " Detach from the Thread network.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully detached from the Thread network.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled.\n"]
    pub fn otThreadBecomeDetached(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Attempt to reattach as a child.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully begin attempt to become a child.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled.\n"]
    pub fn otThreadBecomeChild(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the next neighbor information. It is used to go through the entries of\n the neighbor table.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the iterator context. To get the first neighbor entry\nit should be set to OT_NEIGHBOR_INFO_ITERATOR_INIT.\n @param[out]     aInfo      A pointer to the neighbor information.\n\n @retval OT_ERROR_NONE         Successfully found the next neighbor entry in table.\n @retval OT_ERROR_NOT_FOUND     No subsequent neighbor entry exists in the table.\n @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aInfo was NULL.\n"]
    pub fn otThreadGetNextNeighborInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNeighborInfoIterator,
        aInfo: *mut otNeighborInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the device role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_DEVICE_ROLE_DISABLED  The Thread stack is disabled.\n @retval OT_DEVICE_ROLE_DETACHED  The device is not currently participating in a Thread network/partition.\n @retval OT_DEVICE_ROLE_CHILD     The device is currently operating as a Thread Child.\n @retval OT_DEVICE_ROLE_ROUTER    The device is currently operating as a Thread Router.\n @retval OT_DEVICE_ROLE_LEADER    The device is currently operating as a Thread Leader.\n"]
    pub fn otThreadGetDeviceRole(aInstance: *mut otInstance) -> otDeviceRole;
}
extern "C" {
    #[doc = " Convert the device role to human-readable string.\n\n @param[in] aRole   The device role to convert.\n\n @returns A string representing @p aRole.\n"]
    pub fn otThreadDeviceRoleToString(aRole: otDeviceRole) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Get the Thread Leader Data.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLeaderData  A pointer to where the leader data is placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the leader data.\n @retval OT_ERROR_DETACHED      Not currently attached.\n"]
    pub fn otThreadGetLeaderData(
        aInstance: *mut otInstance,
        aLeaderData: *mut otLeaderData,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Leader's Router ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Leader's Router ID.\n"]
    pub fn otThreadGetLeaderRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Leader's Weight.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Leader's Weight.\n"]
    pub fn otThreadGetLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Partition ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Partition ID.\n"]
    pub fn otThreadGetPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get the RLOC16.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The RLOC16.\n"]
    pub fn otThreadGetRloc16(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " The function retrieves diagnostic information for a Thread Router as parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aParentInfo  A pointer to where the parent router information is placed.\n"]
    pub fn otThreadGetParentInfo(
        aInstance: *mut otInstance,
        aParentInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the average RSSI for the Thread Parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aParentRssi  A pointer to where the parent RSSI should be placed.\n"]
    pub fn otThreadGetParentAverageRssi(
        aInstance: *mut otInstance,
        aParentRssi: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the RSSI of the last packet from the Thread Parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLastRssi    A pointer to where the last RSSI should be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the RSSI data.\n @retval OT_ERROR_FAILED        Unable to get RSSI data.\n @retval OT_ERROR_INVALID_ARGS  @p aLastRssi is NULL.\n"]
    pub fn otThreadGetParentLastRssi(aInstance: *mut otInstance, aLastRssi: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Starts the process for child to search for a better parent while staying attached to its current parent.\n\n Must be used when device is attached as a child.\n\n @retval OT_ERROR_NONE           Successfully started the process to search for a better parent.\n @retval OT_ERROR_INVALID_STATE  Device role is not child.\n"]
    pub fn otThreadSearchForBetterParent(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the IPv6 counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the IPv6 counters.\n"]
    pub fn otThreadGetIp6Counters(aInstance: *mut otInstance) -> *const otIpCounters;
}
extern "C" {
    #[doc = " Resets the IPv6 counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otThreadResetIp6Counters(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the time-in-queue histogram for messages in the TX queue.\n\n Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.\n\n Histogram of the time-in-queue of messages in the transmit queue is collected. The time-in-queue is tracked for\n direct transmissions only and is measured as the duration from when a message is added to the transmit queue until\n it is passed to the MAC layer for transmission or dropped.\n\n The histogram is returned as an array of `uint32_t` values with `aNumBins` entries. The first entry in the array\n (at index 0) represents the number of messages with a time-in-queue less than `aBinInterval`. The second entry\n represents the number of messages with a time-in-queue greater than or equal to `aBinInterval`, but less than\n `2 * aBinInterval`. And so on. The last entry represents the number of messages with time-in-queue  greater than or\n equal to `(aNumBins - 1) * aBinInterval`.\n\n The collected statistics can be reset by calling `otThreadResetTimeInQueueStat()`. The histogram information is\n collected since the OpenThread instance was initialized or since the last time statistics collection was reset by\n calling the `otThreadResetTimeInQueueStat()`.\n\n Pointers @p aNumBins and @p aBinInterval MUST NOT be NULL.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[out] aNumBins       Pointer to return the number of bins in histogram (array length).\n @param[out] aBinInterval   Pointer to return the histogram bin interval length in milliseconds.\n\n @returns A pointer to an array of @p aNumBins entries representing the collected histogram info.\n"]
    pub fn otThreadGetTimeInQueueHistogram(
        aInstance: *mut otInstance,
        aNumBins: *mut u16,
        aBinInterval: *mut u32,
    ) -> *const u32;
}
extern "C" {
    #[doc = " Gets the maximum time-in-queue for messages in the TX queue.\n\n Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.\n\n The time-in-queue is tracked for direct transmissions only and is measured as the duration from when a message is\n added to the transmit queue until it is passed to the MAC layer for transmission or dropped.\n\n The collected statistics can be reset by calling `otThreadResetTimeInQueueStat()`.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The maximum time-in-queue in milliseconds for all messages in the TX queue (so far).\n"]
    pub fn otThreadGetMaxTimeInQueue(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Resets the TX queue time-in-queue statistics.\n\n Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n"]
    pub fn otThreadResetTimeInQueueStat(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Thread MLE counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread MLE counters.\n"]
    pub fn otThreadGetMleCounters(aInstance: *mut otInstance) -> *const otMleCounters;
}
extern "C" {
    #[doc = " Resets the Thread MLE counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otThreadResetMleCounters(aInstance: *mut otInstance);
}
#[doc = " Pointer is called every time an MLE Parent Response message is received.\n\n This is used in `otThreadRegisterParentResponseCallback()`.\n\n @param[in]  aInfo     A pointer to a location on stack holding the stats data.\n @param[in]  aContext  A pointer to callback client-specific context.\n"]
pub type otThreadParentResponseCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *mut otThreadParentResponseInfo,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Registers a callback to receive MLE Parent Response data.\n\n Requires `OPENTHREAD_CONFIG_MLE_PARENT_RESPONSE_CALLBACK_API_ENABLE`.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Parent Response message.\n @param[in]  aContext   A pointer to callback client-specific context.\n"]
    pub fn otThreadRegisterParentResponseCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadParentResponseCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
#[doc = " Represents the Thread Discovery Request data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otThreadDiscoveryRequestInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the requester"]
    pub mExtAddress: otExtAddress,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otThreadDiscoveryRequestInfo {
    #[inline]
    pub fn mVersion(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoiner(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoiner(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mVersion: u8, mIsJoiner: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u8 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsJoiner: u8 = unsafe { ::core::mem::transmute(mIsJoiner) };
            mIsJoiner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Pointer is called every time an MLE Discovery Request message is received.\n\n @param[in]  aInfo     A pointer to the Discovery Request info data.\n @param[in]  aContext  A pointer to callback application-specific context.\n"]
pub type otThreadDiscoveryRequestCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *const otThreadDiscoveryRequestInfo,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Sets a callback to receive MLE Discovery Request data.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Discovery Request message.\n @param[in]  aContext   A pointer to callback application-specific context.\n"]
    pub fn otThreadSetDiscoveryRequestCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadDiscoveryRequestCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
#[doc = " Pointer type defines the callback to notify the outcome of a `otThreadLocateAnycastDestination()`\n request.\n\n @param[in] aContext            A pointer to an arbitrary context (provided when callback is registered).\n @param[in] aError              The error when handling the request. OT_ERROR_NONE indicates success.\n                                OT_ERROR_RESPONSE_TIMEOUT indicates a destination could not be found.\n                                OT_ERROR_ABORT indicates the request was aborted.\n @param[in] aMeshLocalAddress   A pointer to the mesh-local EID of the closest destination of the anycast address\n                                when @p aError is OT_ERROR_NONE, NULL otherwise.\n @param[in] aRloc16             The RLOC16 of the destination if found, otherwise invalid RLOC16 (0xfffe).\n"]
pub type otThreadAnycastLocatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aError: otError,
        aMeshLocalAddress: *const otIp6Address,
        aRloc16: u16,
    ),
>;
extern "C" {
    #[doc = " Requests the closest destination of a given anycast address to be located.\n\n Is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.\n\n If a previous request is ongoing, a subsequent call to this function will cancel and replace the earlier request.\n\n @param[in] aInstance         A pointer to an OpenThread instance.\n @param[in] aAnycastAddress   The anycast address to locate. MUST NOT be NULL.\n @param[in] aCallback         The callback function to report the result.\n @param[in] aContext          An arbitrary context used with @p aCallback.\n\n @retval OT_ERROR_NONE          The request started successfully. @p aCallback will be invoked to report the result.\n @retval OT_ERROR_INVALID_ARGS  The @p aAnycastAddress is not a valid anycast address or @p aCallback is NULL.\n @retval OT_ERROR_NO_BUFS       Out of buffer to prepare and send the request message.\n"]
    pub fn otThreadLocateAnycastDestination(
        aInstance: *mut otInstance,
        aAnycastAddress: *const otIp6Address,
        aCallback: otThreadAnycastLocatorCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Indicates whether an anycast locate request is currently in progress.\n\n Is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if an anycast locate request is currently in progress, FALSE otherwise.\n"]
    pub fn otThreadIsAnycastLocateInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Sends a Proactive Address Notification (ADDR_NTF.ntf) message.\n\n Is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aDestination  The destination to send the ADDR_NTF.ntf message.\n @param[in]  aTarget       The target address of the ADDR_NTF.ntf message.\n @param[in]  aMlIid        The ML-IID of the ADDR_NTF.ntf message.\n"]
    pub fn otThreadSendAddressNotification(
        aInstance: *mut otInstance,
        aDestination: *mut otIp6Address,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
    );
}
extern "C" {
    #[doc = " Sends a Proactive Backbone Notification (PRO_BB.ntf) message on the Backbone link.\n\n Is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in]  aInstance                    A pointer to an OpenThread instance.\n @param[in]  aTarget                      The target address of the PRO_BB.ntf message.\n @param[in]  aMlIid                       The ML-IID of the PRO_BB.ntf message.\n @param[in]  aTimeSinceLastTransaction    Time since last transaction (in seconds).\n\n @retval OT_ERROR_NONE           Successfully sent PRO_BB.ntf on backbone link.\n @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.\n"]
    pub fn otThreadSendProactiveBackboneNotification(
        aInstance: *mut otInstance,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
        aTimeSinceLastTransaction: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Notifies other nodes in the network (if any) and then stops Thread protocol operation.\n\n It sends an Address Release if it's a router, or sets its child timeout to 0 if it's a child.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aCallback A pointer to a function that is called upon finishing detaching.\n @param[in] aContext  A pointer to callback application-specific context.\n\n @retval OT_ERROR_NONE Successfully started detaching.\n @retval OT_ERROR_BUSY Detaching is already in progress.\n"]
    pub fn otThreadDetachGracefully(
        aInstance: *mut otInstance,
        aCallback: otDetachGracefullyCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts an `uint32_t` duration (in seconds) to a human-readable string.\n\n Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The string follows the format \"<hh>:<mm>:<ss>\" for hours, minutes, seconds (if duration is shorter than one day) or\n \"<dd>d.<hh>:<mm>:<ss>\" (if longer than a day).\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n Is intended for use with `mAge` or `mConnectionTime` in `otNeighborInfo` or `otChildInfo` structures.\n\n @param[in]  aDuration A duration interval in seconds.\n @param[out] aBuffer   A pointer to a char array to output the string.\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_DURATION_STRING_SIZE`.\n"]
    pub fn otConvertDurationInSecondsToString(
        aDuration: u32,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Run all queued OpenThread tasklets at the time this is called.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otTaskletsProcess(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates whether or not OpenThread has tasklets pending.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   If there are tasklets pending.\n @retval FALSE  If there are no tasklets pending.\n"]
    pub fn otTaskletsArePending(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " OpenThread calls this function when the tasklet queue transitions from empty to non-empty.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otTaskletsSignalPending(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt milliseconds after @p aT0.\n\n For @p aT0 the platform MUST support all values in [0, 2^32-1].\n For @p aDt, the platform MUST support all values in [0, 2^31-1].\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aT0        The reference time.\n @param[in] aDt        The time delay in milliseconds from @p aT0."]
    pub fn otPlatAlarmMilliStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time.\n\n The current time MUST represent a free-running timer. When maintaining current time, the time value MUST utilize the\n entire range [0, 2^32-1] and MUST NOT wrap before 2^32.\n\n @returns The current time in milliseconds."]
    pub fn otPlatAlarmMilliGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Signal diagnostics module that the alarm has fired.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatDiagAlarmFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Performs a software reset on the platform, if supported.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Performs a hardware reset on the platform to launch bootloader mode, if supported.\n\n Used when `OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE` is enabled.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE         Reset to bootloader successfully.\n @retval OT_ERROR_BUSY         Failed due to another operation is ongoing.\n @retval OT_ERROR_NOT_CAPABLE  Not capable of resetting to bootloader.\n"]
    pub fn otPlatResetToBootloader(aInstance: *mut otInstance) -> otError;
}
pub const otPlatResetReason_OT_PLAT_RESET_REASON_POWER_ON: otPlatResetReason = 0;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_EXTERNAL: otPlatResetReason = 1;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_SOFTWARE: otPlatResetReason = 2;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_FAULT: otPlatResetReason = 3;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_CRASH: otPlatResetReason = 4;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_ASSERT: otPlatResetReason = 5;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_OTHER: otPlatResetReason = 6;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_UNKNOWN: otPlatResetReason = 7;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_WATCHDOG: otPlatResetReason = 8;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_COUNT: otPlatResetReason = 9;
#[doc = " Enumeration of possible reset reason codes.\n\n These are in the same order as the Spinel reset reason codes.\n"]
pub type otPlatResetReason = crate::c_types::c_uint;
extern "C" {
    #[doc = " Returns the reason for the last platform reset.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatGetResetReason(aInstance: *mut otInstance) -> otPlatResetReason;
}
extern "C" {
    #[doc = " Provides a platform specific implementation for assert.\n\n @param[in] aFilename    The name of the file where the assert occurred.\n @param[in] aLineNumber  The line number in the file where the assert occurred.\n"]
    pub fn otPlatAssertFail(
        aFilename: *const crate::c_types::c_char,
        aLineNumber: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " Performs a platform specific operation to wake the host MCU.\n This is used only for NCP configurations.\n"]
    pub fn otPlatWakeHost();
}
#[doc = " NCP's MCU stays on and active all the time.\n\n When the NCP's desired power state is set to `ON`, host can send messages to NCP without requiring any \"poke\" or\n external triggers.\n\n @note The `ON` power state only determines the MCU's power mode and is not related to radio's state.\n"]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_ON: otPlatMcuPowerState = 0;
#[doc = " NCP's MCU can enter low-power (energy-saving) state.\n\n When the NCP's desired power state is set to `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external\n trigger like an interrupt) before it can communicate with the NCP (send a message to the NCP). The \"poke\"\n mechanism is determined by the platform code (based on NCP's interface to the host).\n\n While power state is set to `LOW_POWER`, NCP can still (at any time) send messages to host. Note that receiving\n a message from the NCP does NOT indicate that the NCP's power state has changed, i.e., host is expected to\n continue to \"poke\" when it wants to talk to the NCP until the power state is explicitly changed (by a successful\n call to `otPlatSetMcuPowerState()` changing the state to `ON`).\n\n @note The `LOW_POWER` power state only determines the MCU's power mode and is not related to radio's state\n (radio is managed by OpenThread core and device role, e.g., device being sleepy or not.\n"]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_LOW_POWER: otPlatMcuPowerState = 1;
#[doc = " NCP is fully off.\n\n An NCP hardware reset (via a RESET pin) is required to bring the NCP back to `SPINEL_MCU_POWER_STATE_ON`.\n RAM is not retained after reset.\n"]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_OFF: otPlatMcuPowerState = 2;
#[doc = " Enumeration of micro-controller's power states.\n\n These values are used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL` is enabled.\n\n The power state specifies the desired power state of NCP's micro-controller (MCU) when the underlying platform's\n operating system enters idle mode (i.e., all active tasks/events are processed and the MCU can potentially enter a\n energy-saving power state).\n\n The power state primarily determines how the host should interact with the NCP and whether the host needs an\n external trigger (a \"poke\") to NCP before it can communicate with the NCP or not.\n\n After a reset, the MCU power state MUST be `OT_PLAT_POWER_STATE_ON`.\n"]
pub type otPlatMcuPowerState = crate::c_types::c_uint;
extern "C" {
    #[doc = " Sets the desired MCU power state.\n\n This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`\n is enabled.\n\n @param[in] aInstance      A pointer to OpenThread instance.\n @param[in] aState         The new MCU power state.\n\n @retval OT_ERROR_NONE     The power state updated successfully.\n @retval OT_ERROR_FAILED   The given MCU power state is not supported by the platform.\n"]
    pub fn otPlatSetMcuPowerState(
        aInstance: *mut otInstance,
        aState: otPlatMcuPowerState,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the current desired MCU power state.\n\n This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`\n is enabled.\n\n After a reset, the power state MUST return `OT_PLAT_POWER_STATE_ON`. During operation, power state SHOULD only\n change through an explicit successful call to `otPlatSetMcuPowerState()`.\n\n @param[in] aInstance  A pointer to OpenThread instance.\n\n @returns The current power state.\n"]
    pub fn otPlatGetMcuPowerState(aInstance: *mut otInstance) -> otPlatMcuPowerState;
}
extern "C" {
    #[doc = " Logs a crash dump using OpenThread logging APIs\n\n @note This API is an optional logging platform API. It's up to the platform layer to implement it.\n\n @retval OT_ERROR_NONE            Crash dump was logged successfully\n @retval OT_ERROR_NOT_CAPABLE     Platform is not capable of logging a crash dump"]
    pub fn otPlatLogCrashDump() -> otError;
}
extern "C" {
    #[doc = " Fill buffer with entropy.\n\n MUST be implemented using a true random number generator (TRNG).\n\n @param[out]  aOutput              A pointer to where the true random values are placed.  Must not be NULL.\n @param[in]   aOutputLength        Size of @p aBuffer.\n\n @retval OT_ERROR_NONE          Successfully filled @p aBuffer with true random values.\n @retval OT_ERROR_FAILED        Failed to fill @p aBuffer with true random values.\n @retval OT_ERROR_INVALID_ARGS  @p aBuffer was set to NULL.\n"]
    pub fn otPlatEntropyGet(aOutput: *mut u8, aOutputLength: u16) -> otError;
}
#[doc = "< Active Operational Dataset."]
pub const OT_SETTINGS_KEY_ACTIVE_DATASET: _bindgen_ty_10 = 1;
#[doc = "< Pending Operational Dataset."]
pub const OT_SETTINGS_KEY_PENDING_DATASET: _bindgen_ty_10 = 2;
#[doc = "< Thread network information."]
pub const OT_SETTINGS_KEY_NETWORK_INFO: _bindgen_ty_10 = 3;
#[doc = "< Parent information."]
pub const OT_SETTINGS_KEY_PARENT_INFO: _bindgen_ty_10 = 4;
#[doc = "< Child information."]
pub const OT_SETTINGS_KEY_CHILD_INFO: _bindgen_ty_10 = 5;
#[doc = "< SLAAC key to generate semantically opaque IID."]
pub const OT_SETTINGS_KEY_SLAAC_IID_SECRET_KEY: _bindgen_ty_10 = 7;
#[doc = "< Duplicate Address Detection (DAD) information."]
pub const OT_SETTINGS_KEY_DAD_INFO: _bindgen_ty_10 = 8;
#[doc = "< SRP client ECDSA public/private key pair."]
pub const OT_SETTINGS_KEY_SRP_ECDSA_KEY: _bindgen_ty_10 = 11;
#[doc = "< The SRP client info (selected SRP server address)."]
pub const OT_SETTINGS_KEY_SRP_CLIENT_INFO: _bindgen_ty_10 = 12;
#[doc = "< The SRP server info (UDP port)."]
pub const OT_SETTINGS_KEY_SRP_SERVER_INFO: _bindgen_ty_10 = 13;
#[doc = "< BR ULA prefix."]
pub const OT_SETTINGS_KEY_BR_ULA_PREFIX: _bindgen_ty_10 = 15;
#[doc = "< BR local on-link prefixes."]
pub const OT_SETTINGS_KEY_BR_ON_LINK_PREFIXES: _bindgen_ty_10 = 16;
#[doc = "< Unique Border Agent/Router ID."]
pub const OT_SETTINGS_KEY_BORDER_AGENT_ID: _bindgen_ty_10 = 17;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MIN: _bindgen_ty_10 = 32768;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MAX: _bindgen_ty_10 = 65535;
#[doc = " Defines the keys of settings.\n\n Note: When adding a new settings key, if the settings corresponding to the key contains security sensitive\n       information, the developer MUST add the key to the array `aSensitiveKeys` which is passed in\n       `otPlatSettingsInit()`.\n"]
pub type _bindgen_ty_10 = crate::c_types::c_uint;
extern "C" {
    #[doc = " Performs any initialization for the settings subsystem, if necessary.\n\n Also sets the sensitive keys that should be stored in the secure area.\n\n Note that the memory pointed by @p aSensitiveKeys MUST not be released before @p aInstance is destroyed.\n\n @param[in]  aInstance             The OpenThread instance structure.\n @param[in]  aSensitiveKeys        A pointer to an array containing the list of sensitive keys. May be NULL only if\n                                   @p aSensitiveKeysLength is 0, which means that there is no sensitive keys.\n @param[in]  aSensitiveKeysLength  The number of entries in the @p aSensitiveKeys array.\n"]
    pub fn otPlatSettingsInit(
        aInstance: *mut otInstance,
        aSensitiveKeys: *const u16,
        aSensitiveKeysLength: u16,
    );
}
extern "C" {
    #[doc = " Performs any de-initialization for the settings subsystem, if necessary.\n\n @param[in]  aInstance The OpenThread instance structure.\n"]
    pub fn otPlatSettingsDeinit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Fetches the value of a setting.\n\n Fetches the value of the setting identified\n by @p aKey and write it to the memory pointed to by aValue.\n It then writes the length to the integer pointed to by\n @p aValueLength. The initial value of @p aValueLength is the\n maximum number of bytes to be written to @p aValue.\n\n Can be used to check for the existence of\n a key without fetching the value by setting @p aValue and\n @p aValueLength to NULL. You can also check the length of\n the setting without fetching it by setting only aValue\n to NULL.\n\n Note that the underlying storage implementation is not\n required to maintain the order of settings with multiple\n values. The order of such values MAY change after ANY\n write operation to the store.\n\n @param[in]      aInstance     The OpenThread instance structure.\n @param[in]      aKey          The key associated with the requested setting.\n @param[in]      aIndex        The index of the specific item to get.\n @param[out]     aValue        A pointer to where the value of the setting should be written. May be set to NULL if\n                               just testing for the presence or length of a setting.\n @param[in,out]  aValueLength  A pointer to the length of the value. When called, this pointer should point to an\n                               integer containing the maximum value size that can be written to @p aValue. At return,\n                               the actual length of the setting is written. This may be set to NULL if performing\n                               a presence check.\n\n @retval OT_ERROR_NONE             The given setting was found and fetched successfully.\n @retval OT_ERROR_NOT_FOUND        The given setting was not found in the setting store.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsGet(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: crate::c_types::c_int,
        aValue: *mut u8,
        aValueLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or replaces the value of a setting.\n\n Sets or replaces the value of a setting\n identified by @p aKey.\n\n Calling this function successfully may cause unrelated\n settings with multiple values to be reordered.\n\n OpenThread stack guarantees to use `otPlatSettingsSet()`\n method for a @p aKey that was either previously set using\n `otPlatSettingsSet()` (i.e., contains a single value) or\n is empty and/or fully deleted (contains no value).\n\n Platform layer can rely and use this fact for optimizing\n its implementation.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aKey          The key associated with the setting to change.\n @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL if\n                           @p aValueLength is non-zero.\n @param[in]  aValueLength  The length of the data pointed to by aValue. May be zero.\n\n @retval OT_ERROR_NONE             The given setting was changed or staged.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.\n @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsSet(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a value to a setting.\n\n Adds the value to a setting\n identified by @p aKey, without replacing any existing\n values.\n\n Note that the underlying implementation is not required\n to maintain the order of the items associated with a\n specific key. The added value may be added to the end,\n the beginning, or even somewhere in the middle. The order\n of any pre-existing values may also change.\n\n Calling this function successfully may cause unrelated\n settings with multiple values to be reordered.\n\n OpenThread stack guarantees to use `otPlatSettingsAdd()`\n method for a @p aKey that was either previously managed by\n `otPlatSettingsAdd()` (i.e., contains one or more items) or\n is empty and/or fully deleted (contains no value).\n\n Platform layer can rely and use this fact for optimizing\n its implementation.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aKey          The key associated with the setting to change.\n @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL\n                           if @p aValueLength is non-zero.\n @param[in]  aValueLength  The length of the data pointed to by @p aValue. May be zero.\n\n @retval OT_ERROR_NONE             The given setting was added or staged to be added.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.\n @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsAdd(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a setting from the setting store.\n\n Deletes a specific value from the\n setting identified by aKey from the settings store.\n\n Note that the underlying implementation is not required\n to maintain the order of the items associated with a\n specific key.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aKey       The key associated with the requested setting.\n @param[in] aIndex     The index of the value to be removed. If set to -1, all values for this @p aKey will be\n                       removed.\n\n @retval OT_ERROR_NONE             The given key and index was found and removed successfully.\n @retval OT_ERROR_NOT_FOUND        The given key or index was not found in the setting store.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsDelete(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: crate::c_types::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes all settings from the setting store.\n\n Deletes all settings from the settings\n store, resetting it to its initial factory state.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatSettingsWipe(aInstance: *mut otInstance);
}
#[doc = " Represents a TXT record entry representing a key/value pair (RFC 6763 - section 6.3).\n\n The string buffers pointed to by `mKey` and `mValue` MUST persist and remain unchanged after an instance of such\n structure is passed to OpenThread (as part of `otSrpClientService` instance).\n\n An array of `otDnsTxtEntry` entries are used in `otSrpClientService` to specify the full TXT record (a list of\n entries).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntry {
    #[doc = " The TXT record key string.\n\n If `mKey` is not NULL, then it MUST be a null-terminated C string. The entry is treated as key/value pair with\n `mValue` buffer providing the value.\n   - The entry is encoded as follows:\n        - A single string length byte followed by \"key=value\" format (without the quotation marks).\n- In this case, the overall encoded length must be 255 bytes or less.\n   - If `mValue` is NULL, then key is treated as a boolean attribute and encoded as \"key\" (with no `=`).\n   - If `mValue` is not NULL but `mValueLength` is zero, then it is treated as empty value and encoded as \"key=\".\n\n If `mKey` is NULL, then `mValue` buffer is treated as an already encoded TXT-DATA and is appended as is in the\n DNS message.\n"]
    pub mKey: *const crate::c_types::c_char,
    #[doc = "< The TXT record value or already encoded TXT-DATA (depending on `mKey`)."]
    pub mValue: *const u8,
    #[doc = "< Number of bytes in `mValue` buffer."]
    pub mValueLength: u16,
}
#[doc = " Represents an iterator for TXT record entries (key/value pairs).\n\n The data fields in this structure are intended for use by OpenThread core and caller should not read or change them.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntryIterator {
    pub mPtr: *const crate::c_types::c_void,
    pub mData: [u16; 2usize],
    pub mChar: [crate::c_types::c_char; 65usize],
}
extern "C" {
    #[doc = " Initializes a TXT record iterator.\n\n The buffer pointer @p aTxtData and its content MUST persist and remain unchanged while @p aIterator object\n is being used.\n\n @param[in] aIterator       A pointer to the iterator to initialize (MUST NOT be NULL).\n @param[in] aTxtData        A pointer to buffer containing the encoded TXT data.\n @param[in] aTxtDataLength  The length (number of bytes) of @p aTxtData.\n"]
    pub fn otDnsInitTxtEntryIterator(
        aIterator: *mut otDnsTxtEntryIterator,
        aTxtData: *const u8,
        aTxtDataLength: u16,
    );
}
extern "C" {
    #[doc = " Parses the TXT data from an iterator and gets the next TXT record entry (key/value pair).\n\n The @p aIterator MUST be initialized using `otDnsInitTxtEntryIterator()` before calling this function and the TXT\n data buffer used to initialize the iterator MUST persist and remain unchanged. Otherwise the behavior of this\n function is undefined.\n\n If the parsed key string length is smaller than or equal to `OT_DNS_TXT_KEY_ITER_MAX_LENGTH` the key string is\n returned in `mKey` in @p aEntry. But if the key is longer, then `mKey` is set to NULL and the entire encoded TXT\n entry string is returned in `mValue` and `mValueLength`.\n\n @param[in]  aIterator   A pointer to the iterator (MUST NOT be NULL).\n @param[out] aEntry      A pointer to a `otDnsTxtEntry` structure to output the parsed/read entry (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE       The next entry was parsed successfully. @p aEntry is updated.\n @retval OT_ERROR_NOT_FOUND  No more entries in the TXT data.\n @retval OT_ERROR_PARSE      The TXT data from @p aIterator is not well-formed.\n"]
    pub fn otDnsGetNextTxtEntry(
        aIterator: *mut otDnsTxtEntryIterator,
        aEntry: *mut otDnsTxtEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " Encodes a given list of TXT record entries (key/value pairs) into TXT data (following format specified by RFC 6763).\n\n @param[in]      aTxtEntries      Pointer to an array of `otDnsTxtEntry`.\n @param[in]      aNumTxtEntries   Number of entries in @p aTxtEntries array.\n @param[out]     aTxtData         A pointer to a buffer to output the encoded TXT data.\n @param[in,out]  aTxtDataLength   On input, size of buffer @p aTxtData. On output, length of the encoded TXT data.\n\n @retval OT_ERROR_NONE          Encoded TXT data successfully, @p aTxtData and @p aTxtDataLength are updated.\n @retval OT_ERROR_INVALID_ARGS  The @p aTxtEntries is not valid.\n @retval OT_ERROR_NO_BUS        Could not fit the encoded data in @p aTxtData buffer with its @p aTxtDataLength.\n"]
    pub fn otDnsEncodeTxtData(
        aTxtEntries: *const otDnsTxtEntry,
        aNumTxtEntries: u16,
        aTxtData: *mut u8,
        aTxtDataLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables/disables the \"DNS name compression\" mode.\n\n By default DNS name compression is enabled. When disabled, DNS names are appended as full and never compressed. This\n is applicable to OpenThread's DNS and SRP client/server modules.\n\n This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.\n\n Note that in the case `OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE` is used, this mode applies to all OpenThread\n instances (i.e., calling this function enables/disables the compression mode on all OpenThread instances).\n\n @param[in] aEnabled   TRUE to enable the \"DNS name compression\" mode, FALSE to disable.\n"]
    pub fn otDnsSetNameCompressionEnabled(aEnabled: bool);
}
extern "C" {
    #[doc = " Indicates whether the \"DNS name compression\" mode is enabled or not.\n\n This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.\n\n @returns TRUE if the \"DNS name compression\" mode is enabled, FALSE otherwise.\n"]
    pub fn otDnsIsNameCompressionEnabled() -> bool;
}
#[doc = "< Item to be added/registered."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_ADD: otSrpClientItemState = 0;
#[doc = "< Item is being added/registered."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_ADDING: otSrpClientItemState = 1;
#[doc = "< Item to be refreshed (re-register to renew lease)."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_REFRESH: otSrpClientItemState = 2;
#[doc = "< Item is being refreshed."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REFRESHING: otSrpClientItemState = 3;
#[doc = "< Item to be removed."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_REMOVE: otSrpClientItemState = 4;
#[doc = "< Item is being removed."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REMOVING: otSrpClientItemState = 5;
#[doc = "< Item is registered with server."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REGISTERED: otSrpClientItemState = 6;
#[doc = "< Item is removed."]
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REMOVED: otSrpClientItemState = 7;
#[doc = " Specifies an SRP client item (service or host info) state.\n"]
pub type otSrpClientItemState = crate::c_types::c_uint;
#[doc = " Represents an SRP client host info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientHostInfo {
    #[doc = "< Host name (label) string (NULL if not yet set)."]
    pub mName: *const crate::c_types::c_char,
    #[doc = "< Array of host IPv6 addresses (NULL if not set or auto address is enabled)."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Number of IPv6 addresses in `mAddresses` array."]
    pub mNumAddresses: u8,
    #[doc = "< Indicates whether auto address mode is enabled or not."]
    pub mAutoAddress: bool,
    #[doc = "< Host info state."]
    pub mState: otSrpClientItemState,
}
#[doc = " Represents an SRP client service.\n\n The values in this structure, including the string buffers for the names and the TXT record entries, MUST persist\n and stay constant after an instance of this structure is passed to OpenThread from `otSrpClientAddService()` or\n `otSrpClientRemoveService()`.\n\n The `mState`, `mData`, `mNext` fields are used/managed by OT core only. Their value is ignored when an instance of\n `otSrpClientService` is passed in `otSrpClientAddService()` or `otSrpClientRemoveService()` or other functions. The\n caller does not need to set these fields.\n\n The `mLease` and `mKeyLease` fields specify the desired lease and key lease intervals for this service. Zero value\n indicates that the interval is unspecified and then the default lease or key lease intervals from\n `otSrpClientGetLeaseInterval()` and `otSrpClientGetKeyLeaseInterval()` are used for this service. If the key lease\n interval (whether set explicitly or determined from the default) is shorter than the lease interval for a service,\n SRP client will re-use the lease interval value for key lease interval as well. For example, if in service `mLease`\n is explicitly set to 2 days and `mKeyLease` is set to zero and default key lease is set to 1 day, then when\n registering this service, the requested key lease for this service is also set to 2 days.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientService {
    #[doc = "< The service labels (e.g., \"_mt._udp\", not the full domain name)."]
    pub mName: *const crate::c_types::c_char,
    #[doc = "< The service instance name label (not the full name)."]
    pub mInstanceName: *const crate::c_types::c_char,
    #[doc = "< Array of sub-type labels (must end with `NULL` or can be `NULL`)."]
    pub mSubTypeLabels: *const *const crate::c_types::c_char,
    #[doc = "< Array of TXT entries (`mNumTxtEntries` gives num of entries)."]
    pub mTxtEntries: *const otDnsTxtEntry,
    #[doc = "< The service port number."]
    pub mPort: u16,
    #[doc = "< The service priority."]
    pub mPriority: u16,
    #[doc = "< The service weight."]
    pub mWeight: u16,
    #[doc = "< Number of entries in the `mTxtEntries` array."]
    pub mNumTxtEntries: u8,
    #[doc = "< Service state (managed by OT core)."]
    pub mState: otSrpClientItemState,
    #[doc = "< Internal data (used by OT core)."]
    pub mData: u32,
    #[doc = "< Pointer to next entry in a linked-list (managed by OT core)."]
    pub mNext: *mut otSrpClientService,
    #[doc = "< Desired lease interval in sec - zero to use default."]
    pub mLease: u32,
    #[doc = "< Desired key lease interval in sec - zero to use default."]
    pub mKeyLease: u32,
}
#[doc = " Pointer type defines the callback used by SRP client to notify user of changes/events/errors.\n\n This callback is invoked on a successful registration of an update (i.e., add/remove of host-info and/or some\n service(s)) with the SRP server, or if there is a failure or error (e.g., server rejects a update request or client\n times out waiting for response, etc).\n\n In case of a successful reregistration of an update, `aError` parameter would be `OT_ERROR_NONE` and the host info\n and the full list of services is provided as input parameters to the callback. Note that host info and services each\n track its own state in the corresponding `mState` member variable of the related data structure (the state\n indicating whether the host-info/service is registered or removed or still being added/removed, etc).\n\n The list of removed services is passed as its own linked-list `aRemovedServices` in the callback. Note that when the\n callback is invoked, the SRP client (OpenThread implementation) is done with the removed service instances listed in\n `aRemovedServices` and no longer tracks/stores them (i.e., if from the callback we call `otSrpClientGetServices()`\n the removed services will not be present in the returned list). Providing a separate list of removed services in\n the callback helps indicate to user which items are now removed and allow user to re-claim/reuse the instances.\n\n If the server rejects an SRP update request, the DNS response code (RFC 2136) is mapped to the following errors:\n\n  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE\n  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE\n  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED\n  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND\n  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED\n  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY\n  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED\n  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED\n  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND\n  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY\n  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE\n  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE\n  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY\n  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE\n  - Other response codes                                           -> OT_ERROR_FAILED\n\n The following errors are also possible:\n\n  - OT_ERROR_RESPONSE_TIMEOUT : Timed out waiting for response from server (client would continue to retry).\n  - OT_ERROR_INVALID_ARGS     : The provided service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).\n  - OT_ERROR_NO_BUFS          : Insufficient buffer to prepare or send the update message.\n\n Note that in case of any failure, the client continues the operation, i.e. it prepares and (re)transmits the SRP\n update message to the server, after some wait interval. The retry wait interval starts from the minimum value and\n is increased by the growth factor every failure up to the max value (please see configuration parameter\n `OPENTHREAD_CONFIG_SRP_CLIENT_MIN_RETRY_WAIT_INTERVAL` and the related ones for more details).\n\n @param[in] aError            The error (see above).\n @param[in] aHostInfo         A pointer to host info.\n @param[in] aServices         The head of linked-list containing all services (excluding the ones removed). NULL if\n                              the list is empty.\n @param[in] aRemovedServices  The head of linked-list containing all removed services. NULL if the list is empty.\n @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).\n"]
pub type otSrpClientCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aHostInfo: *const otSrpClientHostInfo,
        aServices: *const otSrpClientService,
        aRemovedServices: *const otSrpClientService,
        aContext: *mut crate::c_types::c_void,
    ),
>;
#[doc = " Pointer type defines the callback used by SRP client to notify user when it is auto-started or stopped.\n\n This is only used when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n This callback is invoked when auto-start mode is enabled and the SRP client is either automatically started or\n stopped.\n\n @param[in] aServerSockAddr   A non-NULL pointer indicates SRP server was started and pointer will give the\n                              selected server socket address. A NULL pointer indicates SRP server was stopped.\n @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).\n"]
pub type otSrpClientAutoStartCallback = ::core::option::Option<
    unsafe extern "C" fn(aServerSockAddr: *const otSockAddr, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Starts the SRP client operation.\n\n SRP client will prepare and send \"SRP Update\" message to the SRP server once all the following conditions are met:\n\n  - The SRP client is started - `otSrpClientStart()` is called.\n  - Host name is set - `otSrpClientSetHostName()` is called.\n  - At least one host IPv6 address is set - `otSrpClientSetHostAddresses()` is called.\n  - At least one service is added - `otSrpClientAddService()` is called.\n\n It does not matter in which order these functions are called. When all conditions are met, the SRP client will\n wait for a short delay before preparing an \"SRP Update\" message and sending it to server. This delay allows for user\n to add multiple services and/or IPv6 addresses before the first SRP Update message is sent (ensuring a single SRP\n Update is sent containing all the info). The config `OPENTHREAD_CONFIG_SRP_CLIENT_UPDATE_TX_DELAY` specifies the\n delay interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aServerSockAddr  The socket address (IPv6 address and port number) of the SRP server.\n\n @retval OT_ERROR_NONE       SRP client operation started successfully or it is already running with same server\n                             socket address and callback.\n @retval OT_ERROR_BUSY       SRP client is busy running with a different socket address.\n @retval OT_ERROR_FAILED     Failed to open/connect the client's UDP socket.\n"]
    pub fn otSrpClientStart(
        aInstance: *mut otInstance,
        aServerSockAddr: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " Stops the SRP client operation.\n\n Stops any further interactions with the SRP server. Note that it does not remove or clear host info\n and/or list of services. It marks all services to be added/removed again once the client is (re)started.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates whether the SRP client is running or not.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n\n @returns TRUE if the SRP client is running, FALSE otherwise.\n"]
    pub fn otSrpClientIsRunning(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the socket address (IPv6 address and port number) of the SRP server which is being used by SRP\n client.\n\n If the client is not running, the address is unspecified (all zero) with zero port number.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n\n @returns A pointer to the SRP server's socket address (is always non-NULL).\n"]
    pub fn otSrpClientGetServerAddress(aInstance: *mut otInstance) -> *const otSockAddr;
}
extern "C" {
    #[doc = " Sets the callback to notify caller of events/changes from SRP client.\n\n The SRP client allows a single callback to be registered. So consecutive calls to this function will overwrite any\n previously set callback functions.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aCallback   The callback to notify of events and changes. Can be NULL if not needed.\n @param[in] aContext    An arbitrary context used with @p aCallback.\n"]
    pub fn otSrpClientSetCallback(
        aInstance: *mut otInstance,
        aCallback: otSrpClientCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Enables the auto-start mode.\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n Config option `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_DEFAULT_MODE` specifies the default auto-start mode (whether\n it is enabled or disabled at the start of OT stack).\n\n When auto-start is enabled, the SRP client will monitor the Thread Network Data to discover SRP servers and select\n the preferred server and automatically start and stop the client when an SRP server is detected.\n\n There are three categories of Network Data entries indicating presence of SRP sever. They are preferred in the\n following order:\n\n   1) Preferred unicast entries where server address is included in the service data. If there are multiple options,\n      the one with numerically lowest IPv6 address is preferred.\n\n   2) Anycast entries each having a seq number. A larger sequence number in the sense specified by Serial Number\n      Arithmetic logic in RFC-1982 is considered more recent and therefore preferred. The largest seq number using\n      serial number arithmetic is preferred if it is well-defined (i.e., the seq number is larger than all other\n      seq numbers). If it is not well-defined, then the numerically largest seq number is preferred.\n\n   3) Unicast entries where the server address info is included in server data. If there are multiple options, the\n      one with numerically lowest IPv6 address is preferred.\n\n When there is a change in the Network Data entries, client will check that the currently selected server is still\n present in the Network Data and is still the preferred one. Otherwise the client will switch to the new preferred\n server or stop if there is none.\n\n When the SRP client is explicitly started through a successful call to `otSrpClientStart()`, the given SRP server\n address in `otSrpClientStart()` will continue to be used regardless of the state of auto-start mode and whether the\n same SRP server address is discovered or not in the Thread Network Data. In this case, only an explicit\n `otSrpClientStop()` call will stop the client.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aCallback   A callback to notify when client is auto-started/stopped. Can be NULL if not needed.\n @param[in] aContext    A context to be passed when invoking @p aCallback.\n"]
    pub fn otSrpClientEnableAutoStartMode(
        aInstance: *mut otInstance,
        aCallback: otSrpClientAutoStartCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Disables the auto-start mode.\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n Disabling the auto-start mode will not stop the client if it is already running but the client stops monitoring\n the Thread Network Data to verify that the selected SRP server is still present in it.\n\n Note that a call to `otSrpClientStop()` will also disable the auto-start mode.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientDisableAutoStartMode(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates the current state of auto-start mode (enabled or disabled).\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n\n @returns TRUE if the auto-start mode is enabled, FALSE otherwise.\n"]
    pub fn otSrpClientIsAutoStartModeEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the TTL value in every record included in SRP update requests.\n\n Note that this is the TTL requested by the SRP client. The server may choose to accept a different TTL.\n\n By default, the TTL will equal the lease interval. Passing 0 or a value larger than the lease interval via\n `otSrpClientSetTtl()` will also cause the TTL to equal the lease interval.\n\n @param[in] aInstance  A pointer to the OpenThread instance.\n\n @returns The TTL (in seconds).\n"]
    pub fn otSrpClientGetTtl(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the TTL value in every record included in SRP update requests.\n\n Changing the TTL does not impact the TTL of already registered services/host-info.\n It only affects future SRP update messages (i.e., adding new services and/or refreshes of the existing services).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aTtl        The TTL (in seconds). If value is zero or greater than lease interval, the TTL is set to the\n                        lease interval.\n"]
    pub fn otSrpClientSetTtl(aInstance: *mut otInstance, aTtl: u32);
}
extern "C" {
    #[doc = " Gets the default lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.\n\n Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease\n interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The lease interval (in seconds).\n"]
    pub fn otSrpClientGetLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the default lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.\n\n Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.\n It only affects any future SRP update messages (i.e., adding new services and/or refreshes of the existing services).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aInterval   The lease interval (in seconds). If zero, the default value specified by\n                        `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_LEASE` would be used.\n"]
    pub fn otSrpClientSetLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " Gets the default key lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.\n\n Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease\n interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The key lease interval (in seconds).\n"]
    pub fn otSrpClientGetKeyLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the default key lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.\n\n Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.\n It only affects any future SRP update messages (i.e., adding new services and/or refreshes of existing services).\n\n @param[in] aInstance    A pointer to the OpenThread instance.\n @param[in] aInterval    The key lease interval (in seconds). If zero, the default value specified by\n                         `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_KEY_LEASE` would be used.\n"]
    pub fn otSrpClientSetKeyLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " Gets the host info.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns A pointer to host info structure.\n"]
    pub fn otSrpClientGetHostInfo(aInstance: *mut otInstance) -> *const otSrpClientHostInfo;
}
extern "C" {
    #[doc = " Sets the host name label.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of host info\n registration with SRP server.\n\n The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.\n OpenThread will keep the pointer to the string.\n\n The host name can be set before client is started or after start but before host info is registered with server\n (host info should be in either `STATE_TO_ADD` or `STATE_REMOVED`).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aName       A pointer to host name label string (MUST NOT be NULL). Pointer to the string buffer MUST\n                        persist and remain valid and constant after return from this function.\n\n @retval OT_ERROR_NONE            The host name label was set successfully.\n @retval OT_ERROR_INVALID_ARGS    The @p aName is NULL.\n @retval OT_ERROR_INVALID_STATE   The host name is already set and registered with the server.\n"]
    pub fn otSrpClientSetHostName(
        aInstance: *mut otInstance,
        aName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables auto host address mode.\n\n When enabled host IPv6 addresses are automatically set by SRP client using all the preferred unicast addresses on\n Thread netif excluding all link-local and mesh-local addresses. If there is no preferred address, then Mesh Local\n EID address is added. The SRP client will automatically re-register when/if addresses on Thread netif are updated\n (new addresses are added or existing addresses are removed or marked as non-preferred).\n\n The auto host address mode can be enabled before start or during operation of SRP client except when the host info\n is being removed (client is busy handling a remove request from an call to `otSrpClientRemoveHostAndServices()` and\n host info still being in  either `STATE_TO_REMOVE` or `STATE_REMOVING` states).\n\n After auto host address mode is enabled, it can be disabled by a call to `otSrpClientSetHostAddresses()` which\n then explicitly sets the host addresses.\n\n @retval OT_ERROR_NONE            Successfully enabled auto host address mode.\n @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot enable auto host address mode.\n"]
    pub fn otSrpClientEnableAutoHostAddress(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Sets/updates the list of host IPv6 address.\n\n Host IPv6 addresses can be set/changed before start or during operation of SRP client (e.g. to add/remove or change\n a previously registered host address), except when the host info is being removed (client is busy handling a remove\n request from an earlier call to `otSrpClientRemoveHostAndServices()` and host info still being in  either\n `STATE_TO_REMOVE` or `STATE_REMOVING` states).\n\n The host IPv6 address array pointed to by @p aIp6Addresses MUST persist and remain unchanged after returning from\n this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the array.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of the address\n registration with SRP server.\n\n Calling this function disables auto host address mode if it was previously enabled from a successful call to\n `otSrpClientEnableAutoHostAddress()`.\n\n @param[in] aInstance           A pointer to the OpenThread instance.\n @param[in] aIp6Addresses       A pointer to the an array containing the host IPv6 addresses.\n @param[in] aNumAddresses       The number of addresses in the @p aIp6Addresses array.\n\n @retval OT_ERROR_NONE            The host IPv6 address list change started successfully. The `otSrpClientCallback`\n                                  will be called to report the status of registering addresses with server.\n @retval OT_ERROR_INVALID_ARGS    The address list is invalid (e.g., must contain at least one address).\n @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot change host address.\n"]
    pub fn otSrpClientSetHostAddresses(
        aInstance: *mut otInstance,
        aIp6Addresses: *const otIp6Address,
        aNumAddresses: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a service to be registered with server.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of the service\n addition/registration with SRP server.\n\n The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning\n from this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the service instance.\n\n The `otSrpClientService` instance is not longer tracked by OpenThread and can be reclaimed only when\n\n  -  It is removed explicitly by a call to `otSrpClientRemoveService()` or removed along with other services by a\n     call to `otSrpClientRemoveHostAndServices() and only after the `otSrpClientCallback` is called indicating the\n     service was removed. Or,\n  -  A call to `otSrpClientClearHostAndServices()` which removes the host and all related services immediately.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to add.\n\n @retval OT_ERROR_NONE          The addition of service started successfully. The `otSrpClientCallback` will be\n                                called to report the status.\n @retval OT_ERROR_ALREADY       A service with the same service and instance names is already in the list.\n @retval OT_ERROR_INVALID_ARGS  The service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).\n"]
    pub fn otSrpClientAddService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " Requests a service to be unregistered with server.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of remove\n request with SRP server.\n\n The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning\n from this function (with `OT_ERROR_NONE`). OpenThread will keep the service instance during the remove process.\n Only after the `otSrpClientCallback` is called indicating the service instance is removed from SRP client\n service list and can be be freed/reused.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to remove.\n\n @retval OT_ERROR_NONE       The removal of service started successfully. The `otSrpClientCallback` will be called to\n                             report the status.\n @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.\n"]
    pub fn otSrpClientRemoveService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " Clears a service, immediately removing it from the client service list.\n\n Unlike `otSrpClientRemoveService()` which sends an update message to the server to remove the service, this function\n clears the service from the client's service list without any interaction with the server. On a successful call to\n this function, the `otSrpClientCallback` will NOT be called and the @p aService entry can be reclaimed and re-used\n by the caller immediately.\n\n Can be used along with a subsequent call to `otSrpClientAddService()` (potentially reusing the same @p\n aService entry with the same service and instance names) to update some of the parameters in an existing service.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to delete.\n\n @retval OT_ERROR_NONE       The @p aService is deleted successfully. It can be reclaimed and re-used immediately.\n @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.\n"]
    pub fn otSrpClientClearService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of services being managed by client.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns A pointer to the head of linked-list of all services or NULL if the list is empty.\n"]
    pub fn otSrpClientGetServices(aInstance: *mut otInstance) -> *const otSrpClientService;
}
extern "C" {
    #[doc = " Starts the remove process of the host info and all services.\n\n After returning from this function, `otSrpClientCallback` will be called to report the status of remove request with\n SRP server.\n\n If the host info is to be permanently removed from server, @p aRemoveKeyLease should be set to `true` which removes\n the key lease associated with host on server. Otherwise, the key lease record is kept as before, which ensures\n that the server holds the host name in reserve for when the client is once again able to provide and register its\n service(s).\n\n The @p aSendUnregToServer determines the behavior when the host info is not yet registered with the server. If\n @p aSendUnregToServer is set to `false` (which is the default/expected value) then the SRP client will immediately\n remove the host info and services without sending an update message to server (no need to update the server if\n nothing is yet registered with it). If @p aSendUnregToServer is set to `true` then the SRP client will send an\n update message to the server. Note that if the host info is registered then the value of @p aSendUnregToServer does\n not matter and the SRP client will always send an update message to server requesting removal of all info.\n\n One situation where @p aSendUnregToServer can be useful is on a device reset/reboot, caller may want to remove any\n previously registered services with the server. In this case, caller can `otSrpClientSetHostName()` and then request\n `otSrpClientRemoveHostAndServices()` with `aSendUnregToServer` as `true`.\n\n @param[in] aInstance          A pointer to the OpenThread instance.\n @param[in] aRemoveKeyLease    A boolean indicating whether or not the host key lease should also be removed.\n @param[in] aSendUnregToServer A boolean indicating whether to send update to server when host info is not registered.\n\n @retval OT_ERROR_NONE       The removal of host info and services started successfully. The `otSrpClientCallback`\n                             will be called to report the status.\n @retval OT_ERROR_ALREADY    The host info is already removed.\n"]
    pub fn otSrpClientRemoveHostAndServices(
        aInstance: *mut otInstance,
        aRemoveKeyLease: bool,
        aSendUnregToServer: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Clears all host info and all the services.\n\n Unlike `otSrpClientRemoveHostAndServices()` which sends an update message to the server to remove all the info, this\n function clears all the info immediately without any interaction with the server.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientClearHostAndServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the domain name being used by SRP client.\n\n Requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.\n\n If domain name is not set, \"default.service.arpa\" will be used.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The domain name string.\n"]
    pub fn otSrpClientGetDomainName(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Sets the domain name to be used by SRP client.\n\n Requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.\n\n If not set \"default.service.arpa\" will be used.\n\n The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.\n OpenThread will keep the pointer to the string.\n\n The domain name can be set before client is started or after start but before host info is registered with server\n (host info should be in either `STATE_TO_ADD` or `STATE_TO_REMOVE`).\n\n @param[in] aInstance     A pointer to the OpenThread instance.\n @param[in] aName         A pointer to the domain name string. If NULL sets it to default \"default.service.arpa\".\n\n @retval OT_ERROR_NONE            The domain name label was set successfully.\n @retval OT_ERROR_INVALID_STATE   The host info is already registered with server.\n"]
    pub fn otSrpClientSetDomainName(
        aInstance: *mut otInstance,
        aName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a `otSrpClientItemState` to a string.\n\n @param[in] aItemState  An item state.\n\n @returns A string representation of @p aItemState.\n"]
    pub fn otSrpClientItemStateToString(
        aItemState: otSrpClientItemState,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Enables/disables \"service key record inclusion\" mode.\n\n When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages\n that it sends.\n\n Is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.\n\n @note KEY record is optional in Service Description Instruction (it is required and always included in the Host\n Description Instruction). The default behavior of SRP client is to not include it. This function is intended to\n override the default behavior for testing only.\n\n @param[in] aInstance  A pointer to the OpenThread instance.\n @param[in] aEnabled   TRUE to enable, FALSE to disable the \"service key record inclusion\" mode.\n"]
    pub fn otSrpClientSetServiceKeyRecordEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Indicates whether the \"service key record inclusion\" mode is enabled or disabled.\n\n Is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.\n\n @param[in] aInstance     A pointer to the OpenThread instance.\n\n @returns TRUE if \"service key record inclusion\" mode is enabled, FALSE otherwise.\n"]
    pub fn otSrpClientIsServiceKeyRecordEnabled(aInstance: *mut otInstance) -> bool;
}
#[doc = " Represents a SRP client service pool entry.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientBuffersServiceEntry {
    #[doc = "< The SRP client service structure."]
    pub mService: otSrpClientService,
    #[doc = "< The SRP client TXT entry."]
    pub mTxtEntry: otDnsTxtEntry,
}
extern "C" {
    #[doc = " Gets the string buffer to use for SRP client host name.\n\n @param[in]  aInstance  A pointer to the OpenThread instance.\n @param[out] aSize      Pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                        NULL).\n\n @returns A pointer to char buffer to use for SRP client host name.\n"]
    pub fn otSrpClientBuffersGetHostNameString(
        aInstance: *mut otInstance,
        aSize: *mut u16,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    #[doc = " Gets the array of IPv6 address entries to use as SRP client host address list.\n\n @param[in]  aInstance     A pointer to the OpenThread instance.\n @param[out] aArrayLength  Pointer to a variable to return the array length i.e., number of IPv6 address entries in\n                           the array (MUST NOT be NULL).\n\n @returns A pointer to an array of `otIp6Address` entries (number of entries is returned in @p aArrayLength).\n"]
    pub fn otSrpClientBuffersGetHostAddressesArray(
        aInstance: *mut otInstance,
        aArrayLength: *mut u8,
    ) -> *mut otIp6Address;
}
extern "C" {
    #[doc = " Allocates a new service entry from the pool.\n\n The returned service entry instance will be initialized as follows:\n\n  - `mService.mName` will point to an allocated string buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryServiceNameString()`.\n  - `mService.mInstanceName` will point to an allocated string buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryInstanceNameString()`.\n  - `mService.mSubTypeLabels` points to an array that is returned from `otSrpClientBuffersGetSubTypeLabelsArray()`.\n  - `mService.mTxtEntries` will point to `mTxtEntry`.\n  - `mService.mNumTxtEntries` will be set to one.\n  - Other `mService` fields (port, priority, weight) are set to zero.\n  - `mTxtEntry.mKey` is set to NULL (value is treated as already encoded).\n  - `mTxtEntry.mValue` will point to an allocated buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryTxtBuffer()`.\n  - `mTxtEntry.mValueLength` is set to zero.\n  - All related data/string buffers and arrays are cleared to all zero.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n\n @returns A pointer to the newly allocated service entry or NULL if not more entry available in the pool.\n"]
    pub fn otSrpClientBuffersAllocateService(
        aInstance: *mut otInstance,
    ) -> *mut otSrpClientBuffersServiceEntry;
}
extern "C" {
    #[doc = " Frees a previously allocated service entry.\n\n The @p aService MUST be previously allocated using `otSrpClientBuffersAllocateService()` and not yet freed. Otherwise\n the behavior of this function is undefined.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aService    A pointer to the service entry to free (MUST NOT be NULL).\n"]
    pub fn otSrpClientBuffersFreeService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientBuffersServiceEntry,
    );
}
extern "C" {
    #[doc = " Frees all previously allocated service entries.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientBuffersFreeAllServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the string buffer for service name from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                      NULL).\n\n @returns A pointer to the string buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryServiceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    #[doc = " Gets the string buffer for service instance name from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                      NULL).\n\n @returns A pointer to the string buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryInstanceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    #[doc = " Gets the buffer for TXT record from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the buffer (MUST NOT be NULL).\n\n @returns A pointer to the buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryTxtBuffer(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Gets the array for service subtype labels from the service entry.\n\n @param[in]  aEntry          A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aArrayLength    A pointer to a variable to return the array length (MUST NOT be NULL).\n\n @returns A pointer to the array.\n"]
    pub fn otSrpClientBuffersGetSubTypeLabelsArray(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aArrayLength: *mut u16,
    ) -> *mut *const crate::c_types::c_char;
}
pub type __builtin_va_list = *mut crate::c_types::c_void;
