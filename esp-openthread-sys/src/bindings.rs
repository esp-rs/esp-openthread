/* automatically generated by rust-bindgen 0.59.2 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const OT_LOG_LEVEL_NONE: u32 = 0;
pub const OT_LOG_LEVEL_CRIT: u32 = 1;
pub const OT_LOG_LEVEL_WARN: u32 = 2;
pub const OT_LOG_LEVEL_NOTE: u32 = 3;
pub const OT_LOG_LEVEL_INFO: u32 = 4;
pub const OT_LOG_LEVEL_DEBG: u32 = 5;
pub const OPENTHREAD_API_VERSION: u32 = 257;
pub const OT_UPTIME_STRING_SIZE: u32 = 24;
pub const OT_PANID_BROADCAST: u32 = 65535;
pub const OT_EXT_ADDRESS_SIZE: u32 = 8;
pub const CSL_IE_HEADER_BYTES_LO: u32 = 4;
pub const CSL_IE_HEADER_BYTES_HI: u32 = 13;
pub const OT_MAC_KEY_SIZE: u32 = 16;
pub const OT_IP6_PREFIX_SIZE: u32 = 8;
pub const OT_IP6_PREFIX_BITSIZE: u32 = 64;
pub const OT_IP6_IID_SIZE: u32 = 8;
pub const OT_IP6_ADDRESS_SIZE: u32 = 16;
pub const OT_IP6_ADDRESS_STRING_SIZE: u32 = 40;
pub const OT_IP6_SOCK_ADDR_STRING_SIZE: u32 = 48;
pub const OT_IP6_PREFIX_STRING_SIZE: u32 = 45;
pub const OT_IP6_MAX_MLR_ADDRESSES: u32 = 15;
pub const OT_NETWORK_KEY_SIZE: u32 = 16;
pub const OT_NETWORK_NAME_MAX_SIZE: u32 = 16;
pub const OT_EXT_PAN_ID_SIZE: u32 = 8;
pub const OT_MESH_LOCAL_PREFIX_SIZE: u32 = 8;
pub const OT_PSKC_MAX_SIZE: u32 = 16;
pub const OT_CHANNEL_1_MASK: u32 = 2;
pub const OT_CHANNEL_2_MASK: u32 = 4;
pub const OT_CHANNEL_3_MASK: u32 = 8;
pub const OT_CHANNEL_4_MASK: u32 = 16;
pub const OT_CHANNEL_5_MASK: u32 = 32;
pub const OT_CHANNEL_6_MASK: u32 = 64;
pub const OT_CHANNEL_7_MASK: u32 = 128;
pub const OT_CHANNEL_8_MASK: u32 = 256;
pub const OT_CHANNEL_9_MASK: u32 = 512;
pub const OT_CHANNEL_10_MASK: u32 = 1024;
pub const OT_CHANNEL_11_MASK: u32 = 2048;
pub const OT_CHANNEL_12_MASK: u32 = 4096;
pub const OT_CHANNEL_13_MASK: u32 = 8192;
pub const OT_CHANNEL_14_MASK: u32 = 16384;
pub const OT_CHANNEL_15_MASK: u32 = 32768;
pub const OT_CHANNEL_16_MASK: u32 = 65536;
pub const OT_CHANNEL_17_MASK: u32 = 131072;
pub const OT_CHANNEL_18_MASK: u32 = 262144;
pub const OT_CHANNEL_19_MASK: u32 = 524288;
pub const OT_CHANNEL_20_MASK: u32 = 1048576;
pub const OT_CHANNEL_21_MASK: u32 = 2097152;
pub const OT_CHANNEL_22_MASK: u32 = 4194304;
pub const OT_CHANNEL_23_MASK: u32 = 8388608;
pub const OT_CHANNEL_24_MASK: u32 = 16777216;
pub const OT_CHANNEL_25_MASK: u32 = 33554432;
pub const OT_CHANNEL_26_MASK: u32 = 67108864;
pub const OT_OPERATIONAL_DATASET_MAX_LENGTH: u32 = 254;
pub const OT_JOINER_MAX_DISCERNER_LENGTH: u32 = 64;
pub const OT_COMMISSIONING_PASSPHRASE_MIN_SIZE: u32 = 6;
pub const OT_COMMISSIONING_PASSPHRASE_MAX_SIZE: u32 = 255;
pub const OT_PROVISIONING_URL_MAX_SIZE: u32 = 64;
pub const OT_STEERING_DATA_MAX_LENGTH: u32 = 16;
pub const OT_JOINER_MAX_PSKD_LENGTH: u32 = 32;
pub const OT_US_PER_TEN_SYMBOLS: u32 = 160;
pub const OT_MAC_FILTER_FIXED_RSS_DISABLED: u32 = 127;
pub const OT_MAC_FILTER_ITERATOR_INIT: u32 = 0;
pub const OT_NETWORK_BASE_TLV_MAX_LENGTH: u32 = 254;
pub const OT_NETWORK_MAX_ROUTER_ID: u32 = 62;
pub const OT_NEIGHBOR_INFO_ITERATOR_INIT: u32 = 0;
pub const OT_JOINER_ADVDATA_MAX_LENGTH: u32 = 64;
pub type size_t = crate::c_types::c_uint;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type wint_t = crate::c_types::c_uint;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type __blkcnt_t = crate::c_types::c_long;
pub type __blksize_t = crate::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::c_types::c_long;
pub type __pid_t = crate::c_types::c_int;
pub type __dev_t = crate::c_types::c_short;
pub type __uid_t = crate::c_types::c_ushort;
pub type __gid_t = crate::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::c_types::c_long;
pub type _fpos_t = crate::c_types::c_long;
pub type __size_t = crate::c_types::c_uint;
pub type _ssize_t = crate::c_types::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::c_types::c_void;
pub type __clock_t = crate::c_types::c_ulong;
pub type __time_t = crate::c_types::c_long;
pub type __clockid_t = crate::c_types::c_ulong;
pub type __timer_t = crate::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::c_types::c_int;
pub type __nlink_t = crate::c_types::c_ushort;
pub type __suseconds_t = crate::c_types::c_long;
pub type __useconds_t = crate::c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::c_types::c_int,
    pub _maxwds: crate::c_types::c_int,
    pub _sign: crate::c_types::c_int,
    pub _wds: crate::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::c_types::c_int,
    pub __tm_min: crate::c_types::c_int,
    pub __tm_hour: crate::c_types::c_int,
    pub __tm_mday: crate::c_types::c_int,
    pub __tm_mon: crate::c_types::c_int,
    pub __tm_year: crate::c_types::c_int,
    pub __tm_wday: crate::c_types::c_int,
    pub __tm_yday: crate::c_types::c_int,
    pub __tm_isdst: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::c_types::c_uchar,
    pub _size: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *mut crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::c_types::c_uchar,
    pub _ur: crate::c_types::c_int,
    pub _ubuf: [crate::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::c_types::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::c_types::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::c_types::c_ushort; 3usize],
    pub _mult: [crate::c_types::c_ushort; 3usize],
    pub _add: crate::c_types::c_ushort,
    pub _rand_next: crate::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::c_types::c_char; 8usize],
    pub _getdate_err: crate::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: crate::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::c_types::c_int,
    pub _emergency: *mut crate::c_types::c_char,
    pub __sdidinit: crate::c_types::c_int,
    pub _unspecified_locale_info: crate::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::c_types::c_int,
    pub _cvtlen: crate::c_types::c_int,
    pub _cvtbuf: *mut crate::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::c_types::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::c_types::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: crate::c_types::c_int,
    pub rem: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::c_types::c_long,
    pub rem: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::c_types::c_longlong,
    pub rem: crate::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::c_types::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::c_types::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::c_types::c_void,
        __base: *const crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn div(__numer: crate::c_types::c_int, __denom: crate::c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::c_types::c_int);
}
extern "C" {
    pub fn free(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::c_types::c_char,
        arg2: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const *mut crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::c_types::c_long) -> crate::c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: crate::c_types::c_long, __denom: crate::c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::c_types::c_uint) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const crate::c_types::c_char, arg2: size_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut crate::c_types::c_char, arg2: wchar_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut crate::c_types::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut crate::c_types::c_void, arg2: size_t)
        -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::c_types::c_char,
        resolved_path: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::c_types::c_long) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::c_types::c_long,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::c_types::c_int, arg2: *mut crate::c_types::c_void),
        >,
        __arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::c_types::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::c_types::c_uint) -> crate::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut crate::c_types::c_ushort) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::c_types::c_longlong) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::c_types::c_longlong,
        __denom: crate::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
        arg5: *mut crate::c_types::c_int,
        arg6: *mut crate::c_types::c_int,
        arg7: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut crate::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *const crate::c_types::c_void,
                arg3: *const crate::c_types::c_void,
            ) -> crate::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::c_types::c_char,
        arg2: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::c_types::c_int);
}
#[doc = " No error."]
pub const otError_OT_ERROR_NONE: otError = 0;
#[doc = " Operational failed."]
pub const otError_OT_ERROR_FAILED: otError = 1;
#[doc = " Message was dropped."]
pub const otError_OT_ERROR_DROP: otError = 2;
#[doc = " Insufficient buffers."]
pub const otError_OT_ERROR_NO_BUFS: otError = 3;
#[doc = " No route available."]
pub const otError_OT_ERROR_NO_ROUTE: otError = 4;
#[doc = " Service is busy and could not service the operation."]
pub const otError_OT_ERROR_BUSY: otError = 5;
#[doc = " Failed to parse message."]
pub const otError_OT_ERROR_PARSE: otError = 6;
#[doc = " Input arguments are invalid."]
pub const otError_OT_ERROR_INVALID_ARGS: otError = 7;
#[doc = " Security checks failed."]
pub const otError_OT_ERROR_SECURITY: otError = 8;
#[doc = " Address resolution requires an address query operation."]
pub const otError_OT_ERROR_ADDRESS_QUERY: otError = 9;
#[doc = " Address is not in the source match table."]
pub const otError_OT_ERROR_NO_ADDRESS: otError = 10;
#[doc = " Operation was aborted."]
pub const otError_OT_ERROR_ABORT: otError = 11;
#[doc = " Function or method is not implemented."]
pub const otError_OT_ERROR_NOT_IMPLEMENTED: otError = 12;
#[doc = " Cannot complete due to invalid state."]
pub const otError_OT_ERROR_INVALID_STATE: otError = 13;
#[doc = " No acknowledgment was received after macMaxFrameRetries (IEEE 802.15.4-2006)."]
pub const otError_OT_ERROR_NO_ACK: otError = 14;
#[doc = " A transmission could not take place due to activity on the channel, i.e., the CSMA-CA mechanism has failed"]
#[doc = " (IEEE 802.15.4-2006)."]
pub const otError_OT_ERROR_CHANNEL_ACCESS_FAILURE: otError = 15;
#[doc = " Not currently attached to a Thread Partition."]
pub const otError_OT_ERROR_DETACHED: otError = 16;
#[doc = " FCS check failure while receiving."]
pub const otError_OT_ERROR_FCS: otError = 17;
#[doc = " No frame received."]
pub const otError_OT_ERROR_NO_FRAME_RECEIVED: otError = 18;
#[doc = " Received a frame from an unknown neighbor."]
pub const otError_OT_ERROR_UNKNOWN_NEIGHBOR: otError = 19;
#[doc = " Received a frame from an invalid source address."]
pub const otError_OT_ERROR_INVALID_SOURCE_ADDRESS: otError = 20;
#[doc = " Received a frame filtered by the address filter (allowlisted or denylisted)."]
pub const otError_OT_ERROR_ADDRESS_FILTERED: otError = 21;
#[doc = " Received a frame filtered by the destination address check."]
pub const otError_OT_ERROR_DESTINATION_ADDRESS_FILTERED: otError = 22;
#[doc = " The requested item could not be found."]
pub const otError_OT_ERROR_NOT_FOUND: otError = 23;
#[doc = " The operation is already in progress."]
pub const otError_OT_ERROR_ALREADY: otError = 24;
#[doc = " The creation of IPv6 address failed."]
pub const otError_OT_ERROR_IP6_ADDRESS_CREATION_FAILURE: otError = 26;
#[doc = " Operation prevented by mode flags"]
pub const otError_OT_ERROR_NOT_CAPABLE: otError = 27;
#[doc = " Coap response or acknowledgment or DNS, SNTP response not received."]
pub const otError_OT_ERROR_RESPONSE_TIMEOUT: otError = 28;
#[doc = " Received a duplicated frame."]
pub const otError_OT_ERROR_DUPLICATED: otError = 29;
#[doc = " Message is being dropped from reassembly list due to timeout."]
pub const otError_OT_ERROR_REASSEMBLY_TIMEOUT: otError = 30;
#[doc = " Message is not a TMF Message."]
pub const otError_OT_ERROR_NOT_TMF: otError = 31;
#[doc = " Received a non-lowpan data frame."]
pub const otError_OT_ERROR_NOT_LOWPAN_DATA_FRAME: otError = 32;
#[doc = " The link margin was too low."]
pub const otError_OT_ERROR_LINK_MARGIN_LOW: otError = 34;
#[doc = " Input (CLI) command is invalid."]
pub const otError_OT_ERROR_INVALID_COMMAND: otError = 35;
#[doc = " Special error code used to indicate success/error status is pending and not yet known."]
#[doc = ""]
pub const otError_OT_ERROR_PENDING: otError = 36;
#[doc = " Request rejected."]
pub const otError_OT_ERROR_REJECTED: otError = 37;
#[doc = " The number of defined errors."]
pub const otError_OT_NUM_ERRORS: otError = 38;
#[doc = " Generic error (should not use)."]
pub const otError_OT_ERROR_GENERIC: otError = 255;
#[doc = " This enumeration represents error codes used throughout OpenThread."]
#[doc = ""]
pub type otError = crate::c_types::c_uint;
extern "C" {
    #[doc = " This function converts an otError enum into a string."]
    #[doc = ""]
    #[doc = " @param[in]  aError     An otError enum."]
    #[doc = ""]
    #[doc = " @returns  A string representation of an otError."]
    #[doc = ""]
    pub fn otThreadErrorToString(aError: otError) -> *const crate::c_types::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
#[doc = " This type represents the log level."]
#[doc = ""]
pub type otLogLevel = crate::c_types::c_int;
#[doc = "< OpenThread API"]
pub const otLogRegion_OT_LOG_REGION_API: otLogRegion = 1;
#[doc = "< MLE"]
pub const otLogRegion_OT_LOG_REGION_MLE: otLogRegion = 2;
#[doc = "< EID-to-RLOC mapping."]
pub const otLogRegion_OT_LOG_REGION_ARP: otLogRegion = 3;
#[doc = "< Network Data"]
pub const otLogRegion_OT_LOG_REGION_NET_DATA: otLogRegion = 4;
#[doc = "< ICMPv6"]
pub const otLogRegion_OT_LOG_REGION_ICMP: otLogRegion = 5;
#[doc = "< IPv6"]
pub const otLogRegion_OT_LOG_REGION_IP6: otLogRegion = 6;
#[doc = "< TCP"]
pub const otLogRegion_OT_LOG_REGION_TCP: otLogRegion = 7;
#[doc = "< IEEE 802.15.4 MAC"]
pub const otLogRegion_OT_LOG_REGION_MAC: otLogRegion = 8;
#[doc = "< Memory"]
pub const otLogRegion_OT_LOG_REGION_MEM: otLogRegion = 9;
#[doc = "< NCP"]
pub const otLogRegion_OT_LOG_REGION_NCP: otLogRegion = 10;
#[doc = "< Mesh Commissioning Protocol"]
pub const otLogRegion_OT_LOG_REGION_MESH_COP: otLogRegion = 11;
#[doc = "< Network Diagnostic"]
pub const otLogRegion_OT_LOG_REGION_NET_DIAG: otLogRegion = 12;
#[doc = "< Platform"]
pub const otLogRegion_OT_LOG_REGION_PLATFORM: otLogRegion = 13;
#[doc = "< CoAP"]
pub const otLogRegion_OT_LOG_REGION_COAP: otLogRegion = 14;
#[doc = "< CLI"]
pub const otLogRegion_OT_LOG_REGION_CLI: otLogRegion = 15;
#[doc = "< OpenThread Core"]
pub const otLogRegion_OT_LOG_REGION_CORE: otLogRegion = 16;
#[doc = "< Utility module"]
pub const otLogRegion_OT_LOG_REGION_UTIL: otLogRegion = 17;
#[doc = "< Backbone Router (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_BBR: otLogRegion = 18;
#[doc = "< Multicast Listener Registration (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_MLR: otLogRegion = 19;
#[doc = "< Domain Unicast Address (available since Thread 1.2)"]
pub const otLogRegion_OT_LOG_REGION_DUA: otLogRegion = 20;
#[doc = "< Border Router"]
pub const otLogRegion_OT_LOG_REGION_BR: otLogRegion = 21;
#[doc = "< Service Registration Protocol (SRP)"]
pub const otLogRegion_OT_LOG_REGION_SRP: otLogRegion = 22;
#[doc = "< DNS"]
pub const otLogRegion_OT_LOG_REGION_DNS: otLogRegion = 23;
#[doc = " This enumeration represents log regions."]
#[doc = ""]
#[doc = " The support for log region is removed and instead each core module can define its own name to appended to the logs."]
#[doc = " However, the `otLogRegion` enumeration is still defined as before to help with platforms which we may be using it"]
#[doc = " in their `otPlatLog()` implementation. The OT core will always emit all logs with `OT_LOG_REGION_CORE`."]
#[doc = ""]
pub type otLogRegion = crate::c_types::c_uint;
extern "C" {
    #[doc = " This function outputs logs."]
    #[doc = ""]
    #[doc = " Note that the support for log region is removed. The OT core will always emit all logs with `OT_LOG_REGION_CORE`"]
    #[doc = " as @p aLogRegion."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel   The log level."]
    #[doc = " @param[in]  aLogRegion  The log region."]
    #[doc = " @param[in]  aFormat     A pointer to the format string."]
    #[doc = " @param[in]  ...         Arguments for the format specification."]
    #[doc = ""]
    pub fn otPlatLog(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const crate::c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " This function handles OpenThread log level changes."]
    #[doc = ""]
    #[doc = " This platform function is called whenever the OpenThread log level changes."]
    #[doc = " This platform function is optional since an empty weak implementation has been provided."]
    #[doc = ""]
    #[doc = " @note Only applicable when `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel  The new OpenThread log level."]
    #[doc = ""]
    pub fn otPlatLogHandleLevelChanged(aLogLevel: otLogLevel);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otInstance {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " This function initializes the OpenThread library."]
    #[doc = ""]
    #[doc = " This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be"]
    #[doc = " called before any other calls to OpenThread."]
    #[doc = ""]
    #[doc = " This function is available and can only be used when support for multiple OpenThread instances is enabled."]
    #[doc = ""]
    #[doc = " @param[in]     aInstanceBuffer      The buffer for OpenThread to use for allocating the otInstance structure."]
    #[doc = " @param[in,out] aInstanceBufferSize  On input, the size of aInstanceBuffer. On output, if not enough space for"]
    #[doc = "                                     otInstance, the number of bytes required for otInstance."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the new OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otInstanceFinalize"]
    #[doc = ""]
    pub fn otInstanceInit(
        aInstanceBuffer: *mut crate::c_types::c_void,
        aInstanceBufferSize: *mut size_t,
    ) -> *mut otInstance;
}
extern "C" {
    #[doc = " This function initializes the static single instance of the OpenThread library."]
    #[doc = ""]
    #[doc = " This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be"]
    #[doc = " called before any other calls to OpenThread."]
    #[doc = ""]
    #[doc = " This function is available and can only be used when support for multiple OpenThread instances is disabled."]
    #[doc = ""]
    #[doc = " @returns A pointer to the single OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceInitSingle() -> *mut otInstance;
}
extern "C" {
    #[doc = " This function indicates whether or not the instance is valid/initialized."]
    #[doc = ""]
    #[doc = " The instance is considered valid if it is acquired and initialized using either `otInstanceInitSingle()` (in single"]
    #[doc = " instance case) or `otInstanceInit()` (in multi instance case). A subsequent call to `otInstanceFinalize()` causes"]
    #[doc = " the instance to be considered as uninitialized."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if the given instance is valid/initialized, FALSE otherwise."]
    #[doc = ""]
    pub fn otInstanceIsInitialized(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function disables the OpenThread library."]
    #[doc = ""]
    #[doc = " Call this function when OpenThread is no longer in use."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceFinalize(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns the current instance uptime (in msec)."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The uptime is given as number of milliseconds since OpenThread instance was initialized."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The uptime (number of milliseconds)."]
    #[doc = ""]
    pub fn otInstanceGetUptime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " This function returns the current instance uptime as a human-readable string."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The string follows the format \"<hh>:<mm>:<ss>.<mmmm>\" for hours, minutes, seconds and millisecond (if uptime is"]
    #[doc = " shorter than one day) or \"<dd>d.<hh>:<mm>:<ss>.<mmmm>\" (if longer than a day)."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_UPTIME_STRING_SIZE`."]
    #[doc = ""]
    pub fn otInstanceGetUptimeAsString(
        aInstance: *mut otInstance,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
#[doc = "< IPv6 address was added"]
pub const OT_CHANGED_IP6_ADDRESS_ADDED: crate::c_types::c_uint = 1;
#[doc = "< IPv6 address was removed"]
pub const OT_CHANGED_IP6_ADDRESS_REMOVED: crate::c_types::c_uint = 2;
#[doc = "< Role (disabled, detached, child, router, leader) changed"]
pub const OT_CHANGED_THREAD_ROLE: crate::c_types::c_uint = 4;
#[doc = "< The link-local address changed"]
pub const OT_CHANGED_THREAD_LL_ADDR: crate::c_types::c_uint = 8;
#[doc = "< The mesh-local address changed"]
pub const OT_CHANGED_THREAD_ML_ADDR: crate::c_types::c_uint = 16;
#[doc = "< RLOC was added"]
pub const OT_CHANGED_THREAD_RLOC_ADDED: crate::c_types::c_uint = 32;
#[doc = "< RLOC was removed"]
pub const OT_CHANGED_THREAD_RLOC_REMOVED: crate::c_types::c_uint = 64;
#[doc = "< Partition ID changed"]
pub const OT_CHANGED_THREAD_PARTITION_ID: crate::c_types::c_uint = 128;
#[doc = "< Thread Key Sequence changed"]
pub const OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER: crate::c_types::c_uint = 256;
#[doc = "< Thread Network Data changed"]
pub const OT_CHANGED_THREAD_NETDATA: crate::c_types::c_uint = 512;
#[doc = "< Child was added"]
pub const OT_CHANGED_THREAD_CHILD_ADDED: crate::c_types::c_uint = 1024;
#[doc = "< Child was removed"]
pub const OT_CHANGED_THREAD_CHILD_REMOVED: crate::c_types::c_uint = 2048;
#[doc = "< Subscribed to a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_SUBSCRIBED: crate::c_types::c_uint = 4096;
#[doc = "< Unsubscribed from a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_UNSUBSCRIBED: crate::c_types::c_uint = 8192;
#[doc = "< Thread network channel changed"]
pub const OT_CHANGED_THREAD_CHANNEL: crate::c_types::c_uint = 16384;
#[doc = "< Thread network PAN Id changed"]
pub const OT_CHANGED_THREAD_PANID: crate::c_types::c_uint = 32768;
#[doc = "< Thread network name changed"]
pub const OT_CHANGED_THREAD_NETWORK_NAME: crate::c_types::c_uint = 65536;
#[doc = "< Thread network extended PAN ID changed"]
pub const OT_CHANGED_THREAD_EXT_PANID: crate::c_types::c_uint = 131072;
#[doc = "< Network key changed"]
pub const OT_CHANGED_NETWORK_KEY: crate::c_types::c_uint = 262144;
#[doc = "< PSKc changed"]
pub const OT_CHANGED_PSKC: crate::c_types::c_uint = 524288;
#[doc = "< Security Policy changed"]
pub const OT_CHANGED_SECURITY_POLICY: crate::c_types::c_uint = 1048576;
#[doc = "< Channel Manager new pending Thread channel changed"]
pub const OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL: crate::c_types::c_uint = 2097152;
#[doc = "< Supported channel mask changed"]
pub const OT_CHANGED_SUPPORTED_CHANNEL_MASK: crate::c_types::c_uint = 4194304;
#[doc = "< Commissioner state changed"]
pub const OT_CHANGED_COMMISSIONER_STATE: crate::c_types::c_uint = 8388608;
#[doc = "< Thread network interface state changed"]
pub const OT_CHANGED_THREAD_NETIF_STATE: crate::c_types::c_uint = 16777216;
#[doc = "< Backbone Router state changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE: crate::c_types::c_uint = 33554432;
#[doc = "< Local Backbone Router configuration changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_LOCAL: crate::c_types::c_uint = 67108864;
#[doc = "< Joiner state changed"]
pub const OT_CHANGED_JOINER_STATE: crate::c_types::c_uint = 134217728;
#[doc = "< Active Operational Dataset changed"]
pub const OT_CHANGED_ACTIVE_DATASET: crate::c_types::c_uint = 268435456;
#[doc = "< Pending Operational Dataset changed"]
pub const OT_CHANGED_PENDING_DATASET: crate::c_types::c_uint = 536870912;
#[doc = " This enumeration defines flags that are passed as part of `otStateChangedCallback`."]
#[doc = ""]
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[doc = " This type represents a bit-field indicating specific state/configuration that has changed. See `OT_CHANGED_*`"]
#[doc = " definitions."]
#[doc = ""]
pub type otChangedFlags = u32;
#[doc = " This function pointer is called to notify certain configuration or state changes within OpenThread."]
#[doc = ""]
#[doc = " @param[in]  aFlags    A bit-field indicating specific state that has changed.  See `OT_CHANGED_*` definitions."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otStateChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(aFlags: otChangedFlags, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to indicate when certain configuration or state changes within OpenThread."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called with certain configuration or state changes."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Added the callback to the list of callbacks."]
    #[doc = " @retval OT_ERROR_ALREADY  The callback was already registered."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Could not add the callback due to resource constraints."]
    #[doc = ""]
    pub fn otSetStateChangedCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a callback to indicate when certain configuration or state changes within OpenThread."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback   A pointer to a function that is called with certain configuration or state changes."]
    #[doc = " @param[in]  aContext    A pointer to application-specific context."]
    #[doc = ""]
    pub fn otRemoveStateChangeCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " This method triggers a platform reset."]
    #[doc = ""]
    #[doc = " The reset process ensures that all the OpenThread state/info (stored in volatile memory) is erased. Note that the"]
    #[doc = " `otPlatformReset` does not erase any persistent state/info saved in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Deletes all the settings stored on non-volatile memory, and then triggers a platform reset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceFactoryReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method resets the internal states of the OpenThread radio stack."]
    #[doc = ""]
    #[doc = " Callbacks and configurations are preserved."]
    #[doc = ""]
    #[doc = " This API is only available under radio builds (`OPENTHREAD_RADIO = 1`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceResetRadioStack(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function erases all the OpenThread persistent info (network settings) stored on non-volatile memory."]
    #[doc = " Erase is successful only if the device is in `disabled` state/role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           All persistent info/state was erased successfully."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in `disabled` state/role."]
    #[doc = ""]
    pub fn otInstanceErasePersistentInfo(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the OpenThread version string."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread version."]
    #[doc = ""]
    pub fn otGetVersionString() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " This function gets the OpenThread radio version string."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread radio version."]
    #[doc = ""]
    pub fn otGetRadioVersionString(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessage {
    _unused: [u8; 0],
}
#[doc = "< Low priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_LOW: otMessagePriority = 0;
#[doc = "< Normal priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_NORMAL: otMessagePriority = 1;
#[doc = "< High priority level."]
pub const otMessagePriority_OT_MESSAGE_PRIORITY_HIGH: otMessagePriority = 2;
#[doc = " This enumeration defines the OpenThread message priority levels."]
#[doc = ""]
pub type otMessagePriority = crate::c_types::c_uint;
#[doc = " This structure represents a message settings."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageSettings {
    #[doc = "< TRUE if the message should be secured at Layer 2."]
    pub mLinkSecurityEnabled: bool,
    #[doc = "< Priority level (MUST be a `OT_MESSAGE_PRIORITY_*` from `otMessagePriority`)."]
    pub mPriority: u8,
}
extern "C" {
    #[doc = " Free an allocated message buffer."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageFree(aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Get the message length in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @returns The message length in bytes."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = ""]
    pub fn otMessageGetLength(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message length in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aLength   A length in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully set the message length."]
    #[doc = " @retval OT_ERROR_NO_BUFS  No available buffers to grow the message."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageSetLength(aMessage: *mut otMessage, aLength: u16) -> otError;
}
extern "C" {
    #[doc = " Get the message offset in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @returns The message offset value."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageGetOffset(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message offset in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageSetOffset(aMessage: *mut otMessage, aOffset: u16);
}
extern "C" {
    #[doc = " This function indicates whether or not link security is enabled for the message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @retval TRUE   If link security is enabled."]
    #[doc = " @retval FALSE  If link security is not enabled."]
    #[doc = ""]
    pub fn otMessageIsLinkSecurityEnabled(aMessage: *const otMessage) -> bool;
}
extern "C" {
    #[doc = " This function sets/forces the message to be forwarded using direct transmission."]
    #[doc = " Default setting for a new message is `false`."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aEnabled  If `true`, the message is forced to use direct transmission. If `false`, the message follows"]
    #[doc = "                       the normal procedure."]
    #[doc = ""]
    pub fn otMessageSetDirectTransmission(aMessage: *mut otMessage, aEnabled: bool);
}
extern "C" {
    #[doc = " This function returns the average RSS (received signal strength) associated with the message."]
    #[doc = ""]
    #[doc = " @returns The average RSS value (in dBm) or OT_RADIO_RSSI_INVALID if no average RSS is available."]
    #[doc = ""]
    pub fn otMessageGetRss(aMessage: *const otMessage) -> i8;
}
extern "C" {
    #[doc = " Append bytes to a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aBuf      A pointer to the data to append."]
    #[doc = " @param[in]  aLength   Number of bytes to append."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully appended to the message"]
    #[doc = " @retval OT_ERROR_NO_BUFS  No available buffers to grow the message."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageAppend(
        aMessage: *mut otMessage,
        aBuf: *const crate::c_types::c_void,
        aLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Read bytes from a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = " @param[in]  aBuf      A pointer to a buffer that message bytes are read to."]
    #[doc = " @param[in]  aLength   Number of bytes to read."]
    #[doc = ""]
    #[doc = " @returns The number of bytes read."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageRead(
        aMessage: *const otMessage,
        aOffset: u16,
        aBuf: *mut crate::c_types::c_void,
        aLength: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Write bytes to a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = " @param[in]  aBuf      A pointer to a buffer that message bytes are written from."]
    #[doc = " @param[in]  aLength   Number of bytes to write."]
    #[doc = ""]
    #[doc = " @returns The number of bytes written."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = ""]
    pub fn otMessageWrite(
        aMessage: *mut otMessage,
        aOffset: u16,
        aBuf: *const crate::c_types::c_void,
        aLength: u16,
    ) -> crate::c_types::c_int;
}
#[doc = " This structure represents an OpenThread message queue."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageQueue {
    #[doc = "< Opaque data used by the implementation."]
    pub mData: *mut crate::c_types::c_void,
}
#[doc = " This structure represents information about a message queue."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageQueueInfo {
    #[doc = "< Number of messages in the queue."]
    pub mNumMessages: u16,
    #[doc = "< Number of data buffers used by messages in the queue."]
    pub mNumBuffers: u16,
    #[doc = "< Total number of bytes used by all messages in the queue."]
    pub mTotalBytes: u32,
}
#[doc = " This structure represents the message buffer information for different queues used by OpenThread stack."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBufferInfo {
    #[doc = "< The total number of buffers in the messages pool (0xffff if unknown)."]
    pub mTotalBuffers: u16,
    #[doc = "< The number of free buffers (0xffff if unknown)."]
    pub mFreeBuffers: u16,
    #[doc = "< Info about 6LoWPAN send queue."]
    pub m6loSendQueue: otMessageQueueInfo,
    #[doc = "< Info about 6LoWPAN reassembly queue."]
    pub m6loReassemblyQueue: otMessageQueueInfo,
    #[doc = "< Info about IPv6 send queue."]
    pub mIp6Queue: otMessageQueueInfo,
    #[doc = "< Info about MPL send queue."]
    pub mMplQueue: otMessageQueueInfo,
    #[doc = "< Info about MLE delayed message queue."]
    pub mMleQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP/TMF send queue."]
    pub mCoapQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP secure send queue."]
    pub mCoapSecureQueue: otMessageQueueInfo,
    #[doc = "< Info about application CoAP send queue."]
    pub mApplicationCoapQueue: otMessageQueueInfo,
}
extern "C" {
    #[doc = " Initialize the message queue."]
    #[doc = ""]
    #[doc = " This function MUST be called once and only once for a `otMessageQueue` instance before any other `otMessageQueue`"]
    #[doc = " functions. The behavior is undefined if other queue APIs are used with an `otMessageQueue` before it being"]
    #[doc = " initialized or if it is initialized more than once."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue     A pointer to a message queue."]
    #[doc = ""]
    pub fn otMessageQueueInit(aQueue: *mut otMessageQueue);
}
extern "C" {
    #[doc = " This function adds a message to the end of the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to add."]
    #[doc = ""]
    pub fn otMessageQueueEnqueue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function adds a message at the head/front of the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to add."]
    #[doc = ""]
    pub fn otMessageQueueEnqueueAtHead(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function removes a message from the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to remove."]
    #[doc = ""]
    pub fn otMessageQueueDequeue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function returns a pointer to the message at the head of the queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to a message queue."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the message at the head of queue or NULL if queue is empty."]
    #[doc = ""]
    pub fn otMessageQueueGetHead(aQueue: *mut otMessageQueue) -> *mut otMessage;
}
extern "C" {
    #[doc = " This function returns a pointer to the next message in the queue by iterating forward (from head to tail)."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to a message queue."]
    #[doc = " @param[in]  aMessage  A pointer to current message buffer."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the next message in the queue after `aMessage` or NULL if `aMessage is the tail of queue."]
    #[doc = "           NULL is returned if `aMessage` is not in the queue `aQueue`."]
    #[doc = ""]
    pub fn otMessageQueueGetNext(
        aQueue: *mut otMessageQueue,
        aMessage: *const otMessage,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Get the Message Buffer information."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to the OpenThread instance."]
    #[doc = " @param[out]  aBufferInfo  A pointer where the message buffer information is written."]
    #[doc = ""]
    pub fn otMessageGetBufferInfo(aInstance: *mut otInstance, aBufferInfo: *mut otBufferInfo);
}
#[doc = "< Key Type: Raw Data."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_RAW: otCryptoKeyType = 0;
#[doc = "< Key Type: AES."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_AES: otCryptoKeyType = 1;
#[doc = "< Key Type: HMAC."]
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_HMAC: otCryptoKeyType = 2;
#[doc = " This enumeration defines the key types."]
#[doc = ""]
pub type otCryptoKeyType = crate::c_types::c_uint;
#[doc = "< Key Algorithm: Vendor Defined."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_VENDOR: otCryptoKeyAlgorithm = 0;
#[doc = "< Key Algorithm: AES ECB."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_AES_ECB: otCryptoKeyAlgorithm = 1;
#[doc = "< Key Algorithm: HMAC SHA-256."]
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_HMAC_SHA_256: otCryptoKeyAlgorithm = 2;
#[doc = " This enumeration defines the key algorithms."]
#[doc = ""]
pub type otCryptoKeyAlgorithm = crate::c_types::c_uint;
#[doc = "< Key Usage: Key Usage is empty."]
pub const OT_CRYPTO_KEY_USAGE_NONE: crate::c_types::c_uint = 0;
#[doc = "< Key Usage: Key can be exported."]
pub const OT_CRYPTO_KEY_USAGE_EXPORT: crate::c_types::c_uint = 1;
#[doc = "< Key Usage: Encryption (vendor defined)."]
pub const OT_CRYPTO_KEY_USAGE_ENCRYPT: crate::c_types::c_uint = 2;
#[doc = "< Key Usage: AES ECB."]
pub const OT_CRYPTO_KEY_USAGE_DECRYPT: crate::c_types::c_uint = 4;
#[doc = "< Key Usage: HMAC SHA-256."]
pub const OT_CRYPTO_KEY_USAGE_SIGN_HASH: crate::c_types::c_uint = 8;
#[doc = " This enumeration defines the key usage flags."]
#[doc = ""]
pub type _bindgen_ty_2 = crate::c_types::c_uint;
#[doc = "< Key Persistence: Key is volatile."]
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_VOLATILE: otCryptoKeyStorage = 0;
#[doc = "< Key Persistence: Key is persistent."]
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_PERSISTENT: otCryptoKeyStorage = 1;
#[doc = " This enumeration defines the key storage types."]
#[doc = ""]
pub type otCryptoKeyStorage = crate::c_types::c_uint;
#[doc = " This datatype represents the key reference."]
#[doc = ""]
pub type otCryptoKeyRef = u32;
#[doc = " @struct otCryptoKey"]
#[doc = ""]
#[doc = " This structure represents the Key Material required for Crypto operations."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCryptoKey {
    #[doc = "< Pointer to the buffer containing key. NULL indicates to use `mKeyRef`."]
    pub mKey: *const u8,
    #[doc = "< The key length in bytes (applicable when `mKey` is not NULL)."]
    pub mKeyLength: u16,
    #[doc = "< The PSA key ref (requires `mKey` to be NULL)."]
    pub mKeyRef: u32,
}
#[doc = " @struct otCryptoContext"]
#[doc = ""]
#[doc = " This structure stores the context object for platform APIs."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCryptoContext {
    #[doc = "< Pointer to the context."]
    pub mContext: *mut crate::c_types::c_void,
    #[doc = "< The length of the context in bytes."]
    pub mContextSize: u16,
}
extern "C" {
    #[doc = " Initialize the Crypto module."]
    #[doc = ""]
    pub fn otPlatCryptoInit();
}
extern "C" {
    #[doc = " Import a key into PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in,out] aKeyRef           Pointer to the key ref to be used for crypto operations."]
    #[doc = " @param[in]     aKeyType          Key Type encoding for the key."]
    #[doc = " @param[in]     aKeyAlgorithm     Key algorithm encoding for the key."]
    #[doc = " @param[in]     aKeyUsage         Key Usage encoding for the key (combinations of `OT_CRYPTO_KEY_USAGE_*`)."]
    #[doc = " @param[in]     aKeyPersistence   Key Persistence for this key"]
    #[doc = " @param[in]     aKey              Actual key to be imported."]
    #[doc = " @param[in]     aKeyLen           Length of the key to be imported."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully imported the key."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to import the key."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aKey was set to NULL."]
    #[doc = ""]
    #[doc = " @note If OT_CRYPTO_KEY_STORAGE_PERSISTENT is passed for aKeyPersistence then @p aKeyRef is input and platform"]
    #[doc = "       should use the given aKeyRef and MUST not change it."]
    #[doc = ""]
    #[doc = "       If OT_CRYPTO_KEY_STORAGE_VOLATILE is passed for aKeyPersistence then @p aKeyRef is output, the initial"]
    #[doc = "       value does not matter and platform API MUST update it to return the new key ref."]
    #[doc = ""]
    #[doc = "       This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoImportKey(
        aKeyRef: *mut otCryptoKeyRef,
        aKeyType: otCryptoKeyType,
        aKeyAlgorithm: otCryptoKeyAlgorithm,
        aKeyUsage: crate::c_types::c_int,
        aKeyPersistence: otCryptoKeyStorage,
        aKey: *const u8,
        aKeyLen: size_t,
    ) -> otError;
}
extern "C" {
    #[doc = " Export a key stored in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]   aKeyRef           The key ref to be used for crypto operations."]
    #[doc = " @param[out]  aBuffer           Pointer to the buffer where key needs to be exported."]
    #[doc = " @param[in]   aBufferLen        Length of the buffer passed to store the exported key."]
    #[doc = " @param[out]  aKeyLen           Pointer to return the length of the exported key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully exported  @p aKeyRef."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to export @p aKeyRef."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aBuffer was NULL"]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoExportKey(
        aKeyRef: otCryptoKeyRef,
        aBuffer: *mut u8,
        aBufferLen: size_t,
        aKeyLen: *mut size_t,
    ) -> otError;
}
extern "C" {
    #[doc = " Destroy a key stored in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]   aKeyRef          The key ref to be destroyed"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully destroyed the key."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to destroy the key."]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoDestroyKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Check if the key ref passed has an associated key in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]  aKeyRef          The Key Ref to check."]
    #[doc = ""]
    #[doc = " @retval TRUE                 There is an associated key with @p aKeyRef."]
    #[doc = " @retval FALSE                There is no associated key with @p aKeyRef."]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoHasKey(aKeyRef: otCryptoKeyRef) -> bool;
}
extern "C" {
    #[doc = " Initialize the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext          Context for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully initialized HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to initialize HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_mac_operation_t or"]
    #[doc = "       mbedtls_md_context_t."]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext          Context for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully uninitialized HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to uninitialized HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[in]  aKey               Key material to be used for for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully started HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to start HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Start(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Update the HMAC operation with new input."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[in]  aBuf               A pointer to the input buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated HMAC with new input operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to update HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const crate::c_types::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Complete the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[out] aBuf               A pointer to the output buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully completed HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to complete HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Finish(
        aContext: *mut otCryptoContext,
        aBuf: *mut u8,
        aBufLength: size_t,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialise the AES operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully Initialised AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to Initialise AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = " @retval OT_ERROR_NO_BUFS       Cannot allocate the context."]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_key_id"]
    #[doc = "       or mbedtls_aes_context_t."]
    #[doc = ""]
    pub fn otPlatCryptoAesInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Set the key for AES operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = " @param[out] aKey               Key to use for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the key for AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to set the key for AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesSetKey(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Encrypt the given data."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = " @param[in]  aInput             Pointer to the input buffer."]
    #[doc = " @param[in]  aOutput            Pointer to the output buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully encrypted @p aInput."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to encrypt @p aInput."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey or @p aOutput were NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesEncrypt(
        aContext: *mut otCryptoContext,
        aInput: *const u8,
        aOutput: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Free the AES context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully freed AES context."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to free AES context."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesFree(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the HKDF context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HKDF operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully Initialised AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to Initialise AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_key_derivation_operation_t"]
    #[doc = "       or HmacSha256::Hash"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Expand step."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Operation context for HKDF operation."]
    #[doc = " @param[in]  aInfo              Pointer to the Info sequence."]
    #[doc = " @param[in]  aInfoLength        Length of the Info sequence."]
    #[doc = " @param[out] aOutputKey         Pointer to the output Key."]
    #[doc = " @param[in]  aOutputKeyLength   Size of the output key buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          HKDF Expand was successful."]
    #[doc = " @retval OT_ERROR_FAILED        HKDF Expand failed."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfExpand(
        aContext: *mut otCryptoContext,
        aInfo: *const u8,
        aInfoLength: u16,
        aOutputKey: *mut u8,
        aOutputKeyLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Extract step."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Operation context for HKDF operation."]
    #[doc = " @param[in]  aSalt              Pointer to the Salt for HKDF."]
    #[doc = " @param[in]  aSaltLength        Length of Salt."]
    #[doc = " @param[in]  aInputKey          Pointer to the input key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          HKDF Extract was successful."]
    #[doc = " @retval OT_ERROR_FAILED        HKDF Extract failed."]
    #[doc = ""]
    pub fn otPlatCryptoHkdfExtract(
        aContext: *mut otCryptoContext,
        aSalt: *const u8,
        aSaltLength: u16,
        aInputKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HKDF context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HKDF operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully un-initialised HKDF operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to un-initialised HKDF operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfDeinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to initialise SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_hash_operation_t"]
    #[doc = "       or mbedtls_sha256_context."]
    pub fn otPlatCryptoSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully un-initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to un-initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully started SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to start SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Start(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Update SHA-256 operation with new input."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = " @param[in]  aBuf               A pointer to the input buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated SHA-256 with new input operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to update SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const crate::c_types::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Finish SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = " @param[in]  aHash              A pointer to the output buffer, where hash needs to be stored."]
    #[doc = " @param[in]  aHashSize          The length of @p aHash in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully completed the SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to complete SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aHash was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Finish(
        aContext: *mut otCryptoContext,
        aHash: *mut u8,
        aHashSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialize cryptographically-secure pseudorandom number generator (CSPRNG)."]
    #[doc = ""]
    pub fn otPlatCryptoRandomInit();
}
extern "C" {
    #[doc = " Deinitialize cryptographically-secure pseudorandom number generator (CSPRNG)."]
    #[doc = ""]
    pub fn otPlatCryptoRandomDeinit();
}
extern "C" {
    #[doc = " Fills a given buffer with cryptographically secure random bytes."]
    #[doc = ""]
    #[doc = " @param[out] aBuffer  A pointer to a buffer to fill with the random bytes."]
    #[doc = " @param[in]  aSize    Size of buffer (number of bytes to fill)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully filled buffer with random values."]
    #[doc = " @retval OT_ERROR_FAILED   Operation failed."]
    #[doc = ""]
    pub fn otPlatCryptoRandomGet(aBuffer: *mut u8, aSize: u16) -> otError;
}
#[doc = "< aMaxPHYPacketSize (IEEE 802.15.4-2006)"]
pub const OT_RADIO_FRAME_MAX_SIZE: crate::c_types::c_uint = 127;
#[doc = "< Minimal size of frame FCS + CONTROL"]
pub const OT_RADIO_FRAME_MIN_SIZE: crate::c_types::c_uint = 3;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_SYMBOLS_PER_OCTET: crate::c_types::c_uint = 2;
#[doc = "< 2.4 GHz IEEE 802.15.4 (bits per second)"]
pub const OT_RADIO_BIT_RATE: crate::c_types::c_uint = 250000;
#[doc = "< Number of bits per octet"]
pub const OT_RADIO_BITS_PER_OCTET: crate::c_types::c_uint = 8;
pub const OT_RADIO_SYMBOL_TIME: crate::c_types::c_uint = 16;
#[doc = "< LQI measurement not supported"]
pub const OT_RADIO_LQI_NONE: crate::c_types::c_uint = 0;
#[doc = "< Invalid or unknown RSSI value"]
pub const OT_RADIO_RSSI_INVALID: crate::c_types::c_uint = 127;
#[doc = "< Invalid or unknown power value"]
pub const OT_RADIO_POWER_INVALID: crate::c_types::c_uint = 127;
#[doc = " @defgroup radio-types Radio Types"]
#[doc = ""]
#[doc = " @brief"]
#[doc = "   This module includes the platform abstraction for a radio frame."]
#[doc = ""]
#[doc = " @{"]
#[doc = ""]
pub type _bindgen_ty_3 = crate::c_types::c_uint;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0: crate::c_types::c_uint = 0;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0_MASK: crate::c_types::c_uint = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2: crate::c_types::c_uint = 2;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2_MASK: crate::c_types::c_uint = 4;
#[doc = " This enumeration defines the channel page."]
#[doc = ""]
pub type _bindgen_ty_4 = crate::c_types::c_uint;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MIN: crate::c_types::c_uint = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MAX: crate::c_types::c_uint = 10;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MASK: crate::c_types::c_uint = 2046;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MIN: crate::c_types::c_uint = 11;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MAX: crate::c_types::c_uint = 26;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MASK: crate::c_types::c_uint = 134215680;
#[doc = " This enumeration defines the frequency band channel range."]
#[doc = ""]
pub type _bindgen_ty_5 = crate::c_types::c_uint;
#[doc = " This type represents radio capabilities."]
#[doc = ""]
#[doc = " The value is a bit-field indicating the capabilities supported by the radio. See `OT_RADIO_CAPS_*` definitions."]
#[doc = ""]
pub type otRadioCaps = u8;
#[doc = "< Radio supports no capability."]
pub const OT_RADIO_CAPS_NONE: crate::c_types::c_uint = 0;
#[doc = "< Radio supports AckTime event."]
pub const OT_RADIO_CAPS_ACK_TIMEOUT: crate::c_types::c_uint = 1;
#[doc = "< Radio supports Energy Scans."]
pub const OT_RADIO_CAPS_ENERGY_SCAN: crate::c_types::c_uint = 2;
#[doc = "< Radio supports tx retry logic with collision avoidance (CSMA)."]
pub const OT_RADIO_CAPS_TRANSMIT_RETRIES: crate::c_types::c_uint = 4;
#[doc = "< Radio supports CSMA backoff for frame transmission (but no retry)."]
pub const OT_RADIO_CAPS_CSMA_BACKOFF: crate::c_types::c_uint = 8;
#[doc = "< Radio supports direct transition from sleep to TX with CSMA."]
pub const OT_RADIO_CAPS_SLEEP_TO_TX: crate::c_types::c_uint = 16;
#[doc = "< Radio supports tx security."]
pub const OT_RADIO_CAPS_TRANSMIT_SEC: crate::c_types::c_uint = 32;
#[doc = "< Radio supports tx at specific time."]
pub const OT_RADIO_CAPS_TRANSMIT_TIMING: crate::c_types::c_uint = 64;
#[doc = "< Radio supports rx at specific time."]
pub const OT_RADIO_CAPS_RECEIVE_TIMING: crate::c_types::c_uint = 128;
#[doc = " This enumeration defines constants that are used to indicate different radio capabilities. See `otRadioCaps`."]
#[doc = ""]
pub type _bindgen_ty_6 = crate::c_types::c_uint;
#[doc = " This type represents the IEEE 802.15.4 PAN ID."]
#[doc = ""]
pub type otPanId = u16;
#[doc = " This type represents the IEEE 802.15.4 Short Address."]
#[doc = ""]
pub type otShortAddress = u16;
#[doc = "< Size of IE header in bytes."]
pub const OT_IE_HEADER_SIZE: crate::c_types::c_uint = 2;
#[doc = "< Size of CSL IE content in bytes."]
pub const OT_CSL_IE_SIZE: crate::c_types::c_uint = 4;
#[doc = "< Max length for header IE in ACK."]
pub const OT_ACK_IE_MAX_SIZE: crate::c_types::c_uint = 16;
#[doc = "< Max length of Link Metrics data in Vendor-Specific IE."]
pub const OT_ENH_PROBING_IE_DATA_MAX_SIZE: crate::c_types::c_uint = 2;
#[doc = " This enumeration defines constants about size of header IE in ACK."]
#[doc = ""]
pub type _bindgen_ty_7 = crate::c_types::c_uint;
#[doc = " @struct otExtAddress"]
#[doc = ""]
#[doc = " This structure represents the IEEE 802.15.4 Extended Address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otExtAddress {
    #[doc = "< IEEE 802.15.4 Extended Address bytes"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otMacKey"]
#[doc = ""]
#[doc = " This structure represents a MAC Key."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otMacKey {
    #[doc = "< MAC Key bytes."]
    pub m8: [u8; 16usize],
}
#[doc = " This type represents a MAC Key Ref used by PSA."]
#[doc = ""]
pub type otMacKeyRef = otCryptoKeyRef;
#[doc = " @struct otMacKeyMaterial"]
#[doc = ""]
#[doc = " This structure represents a MAC Key."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacKeyMaterial {
    pub mKeyMaterial: otMacKeyMaterial__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otMacKeyMaterial__bindgen_ty_1 {
    #[doc = "< Reference to the key stored."]
    pub mKeyRef: otMacKeyRef,
    #[doc = "< Key stored as literal."]
    pub mKey: otMacKey,
}
#[doc = "< Use Literal Keys."]
pub const otRadioKeyType_OT_KEY_TYPE_LITERAL_KEY: otRadioKeyType = 0;
#[doc = "< Use Reference to Key."]
pub const otRadioKeyType_OT_KEY_TYPE_KEY_REF: otRadioKeyType = 1;
#[doc = " This enumeration defines constants about key types."]
#[doc = ""]
pub type otRadioKeyType = crate::c_types::c_uint;
#[doc = " This structure represents the IEEE 802.15.4 Header IE (Information Element) related information of a radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioIeInfo {
    #[doc = "< The time offset to the Thread network time."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< The Time IE offset from the start of PSDU."]
    pub mTimeIeOffset: u8,
    #[doc = "< The Time sync sequence."]
    pub mTimeSyncSeq: u8,
}
#[doc = " This structure represents an IEEE 802.15.4 radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame {
    #[doc = "< The PSDU."]
    pub mPsdu: *mut u8,
    #[doc = "< Length of the PSDU."]
    pub mLength: u16,
    #[doc = "< Channel used to transmit/receive the frame."]
    pub mChannel: u8,
    #[doc = "< Radio link type - should be ignored by radio driver."]
    pub mRadioType: u8,
    pub mInfo: otRadioFrame__bindgen_ty_1,
}
#[doc = " The union of transmit and receive information for a radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union otRadioFrame__bindgen_ty_1 {
    pub mTxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_1,
    pub mRxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Structure representing radio frame transmit information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The key material used for AES-CCM frame security."]
    pub mAesKey: *const otMacKeyMaterial,
    #[doc = "< The pointer to the Header IE(s) related information."]
    pub mIeInfo: *mut otRadioIeInfo,
    #[doc = "< The delay time for this transmission (based on `mTxDelayBaseTime`)."]
    pub mTxDelay: u32,
    #[doc = "< The base time for the transmission delay."]
    pub mTxDelayBaseTime: u32,
    #[doc = "< Maximum number of backoffs attempts before declaring CCA failure."]
    pub mMaxCsmaBackoffs: u8,
    #[doc = "< Maximum number of retries allowed after a transmission failure."]
    pub mMaxFrameRetries: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mIsHeaderUpdated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHeaderUpdated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsARetx(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsARetx(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCsmaCaEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCsmaCaEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCslPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCslPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityProcessed(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityProcessed(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsHeaderUpdated: bool,
        mIsARetx: bool,
        mCsmaCaEnabled: bool,
        mCslPresent: bool,
        mIsSecurityProcessed: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsHeaderUpdated: u8 = unsafe { ::core::mem::transmute(mIsHeaderUpdated) };
            mIsHeaderUpdated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsARetx: u8 = unsafe { ::core::mem::transmute(mIsARetx) };
            mIsARetx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mCsmaCaEnabled: u8 = unsafe { ::core::mem::transmute(mCsmaCaEnabled) };
            mCsmaCaEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mCslPresent: u8 = unsafe { ::core::mem::transmute(mCslPresent) };
            mCslPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsSecurityProcessed: u8 = unsafe { ::core::mem::transmute(mIsSecurityProcessed) };
            mIsSecurityProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure representing radio frame receive information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The timestamp when the frame was received in microseconds."]
    #[doc = ""]
    #[doc = " The value SHALL be the time when the SFD was received when TIME_SYNC or CSL is enabled."]
    #[doc = " Otherwise, the time when the MAC frame was fully received is also acceptable."]
    #[doc = ""]
    pub mTimestamp: u64,
    #[doc = "< ACK security frame counter (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckFrameCounter: u32,
    #[doc = "< ACK security key index (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckKeyId: u8,
    #[doc = "< Received signal strength indicator in dBm for received frames."]
    pub mRssi: i8,
    #[doc = "< Link Quality Indicator for received frames."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn mAckedWithFramePending(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithFramePending(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAckedWithSecEnhAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithSecEnhAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAckedWithFramePending: bool,
        mAckedWithSecEnhAck: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAckedWithFramePending: u8 =
                unsafe { ::core::mem::transmute(mAckedWithFramePending) };
            mAckedWithFramePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mAckedWithSecEnhAck: u8 = unsafe { ::core::mem::transmute(mAckedWithSecEnhAck) };
            mAckedWithSecEnhAck as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const otRadioState_OT_RADIO_STATE_DISABLED: otRadioState = 0;
pub const otRadioState_OT_RADIO_STATE_SLEEP: otRadioState = 1;
pub const otRadioState_OT_RADIO_STATE_RECEIVE: otRadioState = 2;
pub const otRadioState_OT_RADIO_STATE_TRANSMIT: otRadioState = 3;
pub const otRadioState_OT_RADIO_STATE_INVALID: otRadioState = 255;
#[doc = " This structure represents the state of a radio."]
#[doc = " Initially, a radio is in the Disabled state."]
pub type otRadioState = crate::c_types::c_uint;
#[doc = " This structure represents radio coexistence metrics."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioCoexMetrics {
    #[doc = "< Number of grant glitches."]
    pub mNumGrantGlitch: u32,
    #[doc = "< Number of tx requests."]
    pub mNumTxRequest: u32,
    #[doc = "< Number of tx requests while grant was active."]
    pub mNumTxGrantImmediate: u32,
    #[doc = "< Number of tx requests while grant was inactive."]
    pub mNumTxGrantWait: u32,
    #[doc = "< Number of tx requests while grant was inactive that were ultimately granted."]
    pub mNumTxGrantWaitActivated: u32,
    #[doc = "< Number of tx requests while grant was inactive that timed out."]
    pub mNumTxGrantWaitTimeout: u32,
    #[doc = "< Number of tx that were in progress when grant was deactivated."]
    pub mNumTxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of tx requests that were not granted within 50us."]
    pub mNumTxDelayedGrant: u32,
    #[doc = "< Average time in usec from tx request to grant."]
    pub mAvgTxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests."]
    pub mNumRxRequest: u32,
    #[doc = "< Number of rx requests while grant was active."]
    pub mNumRxGrantImmediate: u32,
    #[doc = "< Number of rx requests while grant was inactive."]
    pub mNumRxGrantWait: u32,
    #[doc = "< Number of rx requests while grant was inactive that were ultimately granted."]
    pub mNumRxGrantWaitActivated: u32,
    #[doc = "< Number of rx requests while grant was inactive that timed out."]
    pub mNumRxGrantWaitTimeout: u32,
    #[doc = "< Number of rx that were in progress when grant was deactivated."]
    pub mNumRxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of rx requests that were not granted within 50us."]
    pub mNumRxDelayedGrant: u32,
    #[doc = "< Average time in usec from rx request to grant."]
    pub mAvgRxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests that completed without receiving grant."]
    pub mNumRxGrantNone: u32,
    #[doc = "< Stats collection stopped due to saturation."]
    pub mStopped: bool,
}
#[doc = " This structure represents what metrics are specified to query."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otLinkMetrics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkMetrics {
    #[inline]
    pub fn mPduCount(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPduCount(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLqi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLqi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkMargin(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkMargin(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRssi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRssi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mReserved(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mReserved(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPduCount: bool,
        mLqi: bool,
        mLinkMargin: bool,
        mRssi: bool,
        mReserved: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPduCount: u8 = unsafe { ::core::mem::transmute(mPduCount) };
            mPduCount as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLqi: u8 = unsafe { ::core::mem::transmute(mLqi) };
            mLqi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mLinkMargin: u8 = unsafe { ::core::mem::transmute(mLinkMargin) };
            mLinkMargin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRssi: u8 = unsafe { ::core::mem::transmute(mRssi) };
            mRssi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mReserved: u8 = unsafe { ::core::mem::transmute(mReserved) };
            mReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the radio capabilities."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio capability bit vector (see `OT_RADIO_CAP_*` definitions)."]
    #[doc = ""]
    pub fn otPlatRadioGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
extern "C" {
    #[doc = " Get the radio version string."]
    #[doc = ""]
    #[doc = " This is an optional radio driver platform function. If not provided by platform radio driver, OpenThread uses"]
    #[doc = " the OpenThread version instead (@sa otGetVersionString())."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread radio version."]
    #[doc = ""]
    pub fn otPlatRadioGetVersionString(aInstance: *mut otInstance)
        -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Get the radio receive sensitivity value."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio receive sensitivity value in dBm."]
    #[doc = ""]
    pub fn otPlatRadioGetReceiveSensitivity(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Gets the factory-assigned IEEE EUI-64 for this interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64."]
    #[doc = ""]
    pub fn otPlatRadioGetIeeeEui64(aInstance: *mut otInstance, aIeeeEui64: *mut u8);
}
extern "C" {
    #[doc = " Set the PAN ID for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aPanId     The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    pub fn otPlatRadioSetPanId(aInstance: *mut otInstance, aPanId: otPanId);
}
extern "C" {
    #[doc = " Set the Extended Address for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    The OpenThread instance structure."]
    #[doc = " @param[in] aExtAddress  A pointer to the IEEE 802.15.4 Extended Address stored in little-endian byte order."]
    #[doc = ""]
    #[doc = ""]
    pub fn otPlatRadioSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    );
}
extern "C" {
    #[doc = " Set the Short Address for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      The OpenThread instance structure."]
    #[doc = " @param[in] aShortAddress  The IEEE 802.15.4 Short Address."]
    #[doc = ""]
    pub fn otPlatRadioSetShortAddress(aInstance: *mut otInstance, aShortAddress: otShortAddress);
}
extern "C" {
    #[doc = " Get the radio's transmit power in dBm."]
    #[doc = ""]
    #[doc = " @note The transmit power returned will be no larger than the power specified in the max power table for"]
    #[doc = " the current channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[out] aPower    The transmit power in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the transmit power."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aPower was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetTransmitPower(aInstance: *mut otInstance, aPower: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Set the radio's transmit power in dBm."]
    #[doc = ""]
    #[doc = " @note The real transmit power will be no larger than the power specified in the max power table for"]
    #[doc = " the current channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aPower     The transmit power in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the transmit power."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetTransmitPower(aInstance: *mut otInstance, aPower: i8) -> otError;
}
extern "C" {
    #[doc = " Get the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    The OpenThread instance structure."]
    #[doc = " @param[out] aThreshold  The CCA ED threshold in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the CCA ED threshold."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aThreshold was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance structure."]
    #[doc = " @param[in] aThreshold  The CCA ED threshold in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the transmit power."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     Given threshold is out of range."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[out] aGain     The external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the external FEM's LNA gain."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGain was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA setting is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetFemLnaGain(aInstance: *mut otInstance, aGain: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Sets the external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aGain      The external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the external FEM's LNA gain."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA gain setting is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetFemLnaGain(aInstance: *mut otInstance, aGain: i8) -> otError;
}
extern "C" {
    #[doc = " Get the status of promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval TRUE   Promiscuous mode is enabled."]
    #[doc = " @retval FALSE  Promiscuous mode is disabled."]
    #[doc = ""]
    pub fn otPlatRadioGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enable or disable promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable   TRUE to enable or FALSE to disable promiscuous mode."]
    #[doc = ""]
    pub fn otPlatRadioSetPromiscuous(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Update MAC keys and key index"]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_TRANSMIT_SEC capability."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aKeyIdMode   The key ID mode."]
    #[doc = " @param[in]   aKeyId       Current MAC key index."]
    #[doc = " @param[in]   aPrevKey     A pointer to the previous MAC key."]
    #[doc = " @param[in]   aCurrKey     A pointer to the current MAC key."]
    #[doc = " @param[in]   aNextKey     A pointer to the next MAC key."]
    #[doc = " @param[in]   aKeyType     Key Type used."]
    #[doc = ""]
    pub fn otPlatRadioSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKeyMaterial,
        aCurrKey: *const otMacKeyMaterial,
        aNextKey: *const otMacKeyMaterial,
        aKeyType: otRadioKeyType,
    );
}
extern "C" {
    #[doc = " This method sets the current MAC frame counter value."]
    #[doc = ""]
    #[doc = " This function is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aMacFrameCounter  The MAC frame counter value."]
    #[doc = ""]
    pub fn otPlatRadioSetMacFrameCounter(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " Get the current estimated time (in microseconds) of the radio chip."]
    #[doc = ""]
    #[doc = " This microsecond timer must be a free-running timer. The timer must continue to advance with microsecond precision"]
    #[doc = " even when the radio is in the sleep state."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current time in microseconds. UINT64_MAX when platform does not support or radio time is not ready."]
    #[doc = ""]
    pub fn otPlatRadioGetNow(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " Get the bus speed in bits/second between the host and the radio chip."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The bus speed in bits/second between the host and the radio chip."]
    #[doc = "          Return 0 when the MAC and above layer and Radio layer resides on the same chip."]
    #[doc = ""]
    pub fn otPlatRadioGetBusSpeed(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get current state of the radio."]
    #[doc = ""]
    #[doc = " This function is not required by OpenThread. It may be used for debugging and/or application-specific purposes."]
    #[doc = ""]
    #[doc = " @note This function may be not implemented. It does not affect OpenThread."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @return  Current state of the radio."]
    #[doc = ""]
    pub fn otPlatRadioGetState(aInstance: *mut otInstance) -> otRadioState;
}
extern "C" {
    #[doc = " Enable the radio."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enabled."]
    #[doc = " @retval OT_ERROR_FAILED   The radio could not be enabled."]
    #[doc = ""]
    pub fn otPlatRadioEnable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Disable the radio."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully transitioned to Disabled."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The radio was not in sleep state."]
    #[doc = ""]
    pub fn otPlatRadioDisable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Check whether radio is enabled or not."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns TRUE if the radio is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatRadioIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep (turn off the radio)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Sleep."]
    #[doc = " @retval OT_ERROR_BUSY          The radio was transmitting."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was disabled."]
    #[doc = ""]
    pub fn otPlatRadioSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Sleep to Receive (turn on the radio)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[in]  aChannel   The channel to use for receiving."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Receive."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was disabled or transmitting."]
    #[doc = ""]
    pub fn otPlatRadioReceive(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Schedule a radio reception window at a specific time and duration."]
    #[doc = ""]
    #[doc = " @param[in]  aChannel   The radio channel on which to receive."]
    #[doc = " @param[in]  aStart     The receive window start time, in microseconds."]
    #[doc = " @param[in]  aDuration  The receive window duration, in microseconds"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully scheduled receive window."]
    #[doc = " @retval OT_ERROR_FAILED  The receive window could not be scheduled."]
    pub fn otPlatRadioReceiveAt(
        aInstance: *mut otInstance,
        aChannel: u8,
        aStart: u32,
        aDuration: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread of a received frame."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed."]
    #[doc = " @param[in]  aError    OT_ERROR_NONE when successfully received a frame,"]
    #[doc = "                       OT_ERROR_ABORT when reception was aborted and a frame was not received,"]
    #[doc = "                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space."]
    #[doc = ""]
    pub fn otPlatRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module of a received frame."]
    #[doc = ""]
    #[doc = " This function is used when diagnostics is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed."]
    #[doc = " @param[in]  aError    OT_ERROR_NONE when successfully received a frame,"]
    #[doc = "                       OT_ERROR_ABORT when reception was aborted and a frame was not received,"]
    #[doc = "                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space."]
    #[doc = ""]
    pub fn otPlatDiagRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the radio transmit frame buffer."]
    #[doc = ""]
    #[doc = " OpenThread forms the IEEE 802.15.4 frame in this buffer then calls `otPlatRadioTransmit()` to request transmission."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns A pointer to the transmit frame buffer."]
    #[doc = ""]
    pub fn otPlatRadioGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
extern "C" {
    #[doc = " Begin the transmit sequence on the radio."]
    #[doc = ""]
    #[doc = " The caller must form the IEEE 802.15.4 frame in the buffer provided by `otPlatRadioGetTransmitBuffer()` before"]
    #[doc = " requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure."]
    #[doc = ""]
    #[doc = " The transmit sequence consists of:"]
    #[doc = " 1. Transitioning the radio to Transmit from one of the following states:"]
    #[doc = "    - Receive if RX is on when the device is idle or OT_RADIO_CAPS_SLEEP_TO_TX is not supported"]
    #[doc = "    - Sleep if RX is off when the device is idle and OT_RADIO_CAPS_SLEEP_TO_TX is supported."]
    #[doc = " 2. Transmits the psdu on the given channel and at the given transmit power."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aFrame     A pointer to the frame to be transmitted."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Transmit."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state."]
    #[doc = ""]
    pub fn otPlatRadioTransmit(aInstance: *mut otInstance, aFrame: *mut otRadioFrame) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the transmission has started."]
    #[doc = ""]
    #[doc = " @note  This function should be called by the same thread that executes all of the other OpenThread code. It should"]
    #[doc = "        not be called by ISR or any other task."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to the OpenThread instance structure."]
    #[doc = " @param[in]  aFrame     A pointer to the frame that is being transmitted."]
    #[doc = ""]
    pub fn otPlatRadioTxStarted(aInstance: *mut otInstance, aFrame: *mut otRadioFrame);
}
extern "C" {
    #[doc = " The radio driver calls this function to notify OpenThread that the transmit operation has completed,"]
    #[doc = " providing both the transmitted frame and, if applicable, the received ack frame."]
    #[doc = ""]
    #[doc = " When radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability, radio platform layer updates @p aFrame"]
    #[doc = " with the security frame counter and key index values maintained by the radio."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame     A pointer to the frame that was transmitted."]
    #[doc = " @param[in]  aAckFrame  A pointer to the ACK frame, NULL if no ACK was received."]
    #[doc = " @param[in]  aError     OT_ERROR_NONE when the frame was transmitted,"]
    #[doc = "                        OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received,"]
    #[doc = "                        OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,"]
    #[doc = "                        OT_ERROR_ABORT when transmission was aborted for other reasons."]
    #[doc = ""]
    pub fn otPlatRadioTxDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed."]
    #[doc = ""]
    #[doc = " This function is used when diagnostics is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame         A pointer to the frame that was transmitted."]
    #[doc = " @param[in]  aError         OT_ERROR_NONE when the frame was transmitted,"]
    #[doc = "                            OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,"]
    #[doc = "                            OT_ERROR_ABORT when transmission was aborted for other reasons."]
    #[doc = ""]
    pub fn otPlatDiagRadioTransmitDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid."]
    #[doc = ""]
    pub fn otPlatRadioGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Begin the energy scan sequence on the radio."]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      The OpenThread instance structure."]
    #[doc = " @param[in] aScanChannel   The channel to perform the energy scan on."]
    #[doc = " @param[in] aScanDuration  The duration, in milliseconds, for the channel to be scanned."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully started scanning the channel."]
    #[doc = " @retval OT_ERROR_BUSY             The radio is performing enery scanning."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning."]
    #[doc = ""]
    pub fn otPlatRadioEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the energy scan is complete."]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           The OpenThread instance structure."]
    #[doc = " @param[in]  aEnergyScanMaxRssi  The maximum RSSI encountered on the scanned channel."]
    #[doc = ""]
    pub fn otPlatRadioEnergyScanDone(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8);
}
extern "C" {
    #[doc = " Enable/Disable source address match feature."]
    #[doc = ""]
    #[doc = " The source address match feature controls how the radio layer decides the \"frame pending\" bit for acks sent in"]
    #[doc = " response to data request commands from children."]
    #[doc = ""]
    #[doc = " If disabled, the radio layer must set the \"frame pending\" on all acks to data request commands."]
    #[doc = ""]
    #[doc = " If enabled, the radio layer uses the source address match table to determine whether to set or clear the \"frame"]
    #[doc = " pending\" bit in an ack to a data request command."]
    #[doc = ""]
    #[doc = " The source address match table provides the list of children for which there is a pending frame. Either a short"]
    #[doc = " address or an extended/long address can be added to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable     Enable/disable source address match feature."]
    #[doc = ""]
    pub fn otPlatRadioEnableSrcMatch(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Add a short address to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aShortAddress  The short address to be added."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully added short address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS   No available entry in the source match table."]
    #[doc = ""]
    pub fn otPlatRadioAddSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an extended address to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aExtAddress  The extended address to be added stored in little-endian byte order."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully added extended address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS   No available entry in the source match table."]
    #[doc = ""]
    pub fn otPlatRadioAddSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a short address from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aShortAddress  The short address to be removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Successfully removed short address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS  The short address is not in source address match table."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an extended address from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aExtAddress  The extended address to be removed stored in little-endian byte order."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Successfully removed the extended address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS  The extended address is not in source address match table."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all short addresses from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchShortEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Clear all the extended/long addresses from source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchExtEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the radio supported channel mask that the device is allowed to be on."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio supported channel mask."]
    #[doc = ""]
    pub fn otPlatRadioGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the radio preferred channel mask that the device prefers to form on."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio preferred channel mask."]
    #[doc = ""]
    pub fn otPlatRadioGetPreferredChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Enable the radio coex."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aEnabled   TRUE to enable the radio coex, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enabled."]
    #[doc = " @retval OT_ERROR_FAILED   The radio coex could not be enabled."]
    #[doc = ""]
    pub fn otPlatRadioSetCoexEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Check whether radio coex is enabled or not."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns TRUE if the radio coex is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatRadioIsCoexEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the radio coexistence metrics."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[out] aCoexMetrics  A pointer to the coexistence metrics structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the coex metrics."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aCoexMetrics was NULL."]
    pub fn otPlatRadioGetCoexMetrics(
        aInstance: *mut otInstance,
        aCoexMetrics: *mut otRadioCoexMetrics,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable or disable CSL receiver."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aCslPeriod    CSL period, 0 for disabling CSL."]
    #[doc = " @param[in]  aShortAddr    The short source address of CSL receiver's peer."]
    #[doc = " @param[in]  aExtAddr      The extended source address of CSL receiver's peer."]
    #[doc = ""]
    #[doc = " @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks."]
    #[doc = ""]
    #[doc = " @retval  kErrorNotImplemented Radio driver doesn't support CSL."]
    #[doc = " @retval  kErrorFailed         Other platform specific errors."]
    #[doc = " @retval  kErrorNone           Successfully enabled or disabled CSL."]
    #[doc = ""]
    pub fn otPlatRadioEnableCsl(
        aInstance: *mut otInstance,
        aCslPeriod: u32,
        aShortAddr: otShortAddress,
        aExtAddr: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Update CSL sample time in radio driver."]
    #[doc = ""]
    #[doc = " Sample time is stored in radio driver as a copy to calculate phase when sending ACK with CSL IE."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         The OpenThread instance structure."]
    #[doc = " @param[in]  aCslSampleTime    The latest sample time."]
    #[doc = ""]
    pub fn otPlatRadioUpdateCslSampleTime(aInstance: *mut otInstance, aCslSampleTime: u32);
}
extern "C" {
    #[doc = " Get the current accuracy, in units of  ppm, of the clock used for scheduling CSL operations."]
    #[doc = ""]
    #[doc = " @note Platforms may optimize this value based on operational conditions (i.e.: temperature)."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current CSL rx/tx scheduling drift, in units of  ppm."]
    #[doc = ""]
    pub fn otPlatRadioGetCslAccuracy(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The fixed uncertainty of the Device for scheduling CSL Transmissions in units of 10 microseconds."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL Uncertainty in units of 10 us."]
    #[doc = ""]
    pub fn otPlatRadioGetCslUncertainty(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the max transmit power for a specific channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aChannel     The radio channel."]
    #[doc = " @param[in]  aMaxPower    The max power in dBm, passing OT_RADIO_RSSI_INVALID will disable this channel."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented"]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     The specified channel is not valid."]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully set max transmit power."]
    #[doc = ""]
    pub fn otPlatRadioSetChannelMaxTransmitPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aMaxPower: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the region code."]
    #[doc = ""]
    #[doc = " The radio region format is the 2-bytes ascii representation of the"]
    #[doc = " ISO 3166 alpha-2 code."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aRegionCode  The radio region."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully set region code."]
    #[doc = ""]
    pub fn otPlatRadioSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
extern "C" {
    #[doc = " Get the region code."]
    #[doc = ""]
    #[doc = " The radio region format is the 2-bytes ascii representation of the"]
    #[doc = " ISO 3166 alpha-2 code."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[out] aRegionCode  The radio region."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr."]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully got region code."]
    #[doc = ""]
    pub fn otPlatRadioGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
extern "C" {
    #[doc = " Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator."]
    #[doc = ""]
    #[doc = " After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that"]
    #[doc = " node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to"]
    #[doc = " collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that"]
    #[doc = " Probing Initiator."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics"]
    #[doc = "                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0."]
    #[doc = " @param[in]  aShortAddress The short address of the Probing Initiator."]
    #[doc = " @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND       The Initiator indicated by @p aShortAddress is not found when trying to clear."]
    #[doc = " @retval  OT_ERROR_NO_BUFS         No more Initiator can be supported."]
    #[doc = ""]
    pub fn otPlatRadioConfigureEnhAckProbing(
        aInstance: *mut otInstance,
        aLinkMetrics: otLinkMetrics,
        aShortAddress: otShortAddress,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
#[doc = " @struct otIp6InterfaceIdentifier"]
#[doc = ""]
#[doc = " This structure represents the Interface Identifier of an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6InterfaceIdentifier {
    #[doc = "< The Interface Identifier accessor fields"]
    pub mFields: otIp6InterfaceIdentifier__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6InterfaceIdentifier__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 8usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 4usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 2usize],
}
#[doc = " @struct otIp6NetworkPrefix"]
#[doc = ""]
#[doc = " This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address)."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6NetworkPrefix {
    #[doc = "< The Network Prefix."]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6AddressComponents"]
#[doc = ""]
#[doc = " This structure represents the components of an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6AddressComponents {
    #[doc = "< The Network Prefix (most significant 64 bits of the address)"]
    pub mNetworkPrefix: otIp6NetworkPrefix,
    #[doc = "< The Interface Identifier (least significant 64 bits of the address)"]
    pub mIid: otIp6InterfaceIdentifier,
}
#[doc = " @struct otIp6Address"]
#[doc = ""]
#[doc = " This structure represents an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Address {
    #[doc = "< IPv6 accessor fields"]
    pub mFields: otIp6Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 16usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 8usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 4usize],
    #[doc = "< IPv6 address components"]
    pub mComponents: otIp6AddressComponents,
}
#[doc = " This structure represents an IPv6 prefix."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Prefix {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Address,
    #[doc = "< The IPv6 prefix length (in bits)."]
    pub mLength: u8,
}
#[doc = "< Thread assigned address (ALOC, RLOC, MLEID, etc)"]
pub const OT_ADDRESS_ORIGIN_THREAD: crate::c_types::c_uint = 0;
#[doc = "< SLAAC assigned address"]
pub const OT_ADDRESS_ORIGIN_SLAAC: crate::c_types::c_uint = 1;
#[doc = "< DHCPv6 assigned address"]
pub const OT_ADDRESS_ORIGIN_DHCPV6: crate::c_types::c_uint = 2;
#[doc = "< Manually assigned address"]
pub const OT_ADDRESS_ORIGIN_MANUAL: crate::c_types::c_uint = 3;
#[doc = " IPv6 Address origins"]
#[doc = ""]
pub type _bindgen_ty_8 = crate::c_types::c_uint;
#[doc = " This structure represents an IPv6 network interface unicast address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifAddress {
    #[doc = "< The IPv6 unicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< The Prefix length (in bits)."]
    pub mPrefixLength: u8,
    #[doc = "< The IPv6 address origin."]
    pub mAddressOrigin: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< A pointer to the next network interface address."]
    pub mNext: *mut otNetifAddress,
}
impl otNetifAddress {
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverrideValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mScopeOverrideValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverride(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mScopeOverride(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mRloc(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRloc(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreferred: bool,
        mValid: bool,
        mScopeOverrideValid: bool,
        mScopeOverride: crate::c_types::c_uint,
        mRloc: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValid: u8 = unsafe { ::core::mem::transmute(mValid) };
            mValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mScopeOverrideValid: u8 = unsafe { ::core::mem::transmute(mScopeOverrideValid) };
            mScopeOverrideValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let mScopeOverride: u32 = unsafe { ::core::mem::transmute(mScopeOverride) };
            mScopeOverride as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mRloc: u8 = unsafe { ::core::mem::transmute(mRloc) };
            mRloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an IPv6 network interface multicast address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifMulticastAddress {
    #[doc = "< The IPv6 multicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< A pointer to the next network interface multicast address."]
    pub mNext: *const otNetifMulticastAddress,
}
#[doc = " This structure represents an IPv6 socket address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSockAddr {
    #[doc = "< An IPv6 address."]
    pub mAddress: otIp6Address,
    #[doc = "< A transport-layer port."]
    pub mPort: u16,
}
#[doc = "< Non-ECT"]
pub const OT_ECN_NOT_CAPABLE: crate::c_types::c_uint = 0;
#[doc = "< ECT(0)"]
pub const OT_ECN_CAPABLE_0: crate::c_types::c_uint = 2;
#[doc = "< ECT(1)"]
pub const OT_ECN_CAPABLE_1: crate::c_types::c_uint = 1;
#[doc = "< Congestion encountered (CE)"]
pub const OT_ECN_MARKED: crate::c_types::c_uint = 3;
#[doc = " ECN statuses, represented as in the IP header."]
#[doc = ""]
pub type _bindgen_ty_9 = crate::c_types::c_uint;
#[doc = " This structure represents the local and peer IPv6 socket addresses."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageInfo {
    #[doc = "< The local IPv6 address."]
    pub mSockAddr: otIp6Address,
    #[doc = "< The peer IPv6 address."]
    pub mPeerAddr: otIp6Address,
    #[doc = "< The local transport-layer port."]
    pub mSockPort: u16,
    #[doc = "< The peer transport-layer port."]
    pub mPeerPort: u16,
    #[doc = "< A pointer to link-specific information."]
    pub mLinkInfo: *const crate::c_types::c_void,
    #[doc = "< The IPv6 Hop Limit value. Only applies if `mAllowZeroHopLimit` is FALSE."]
    #[doc = "< If `0`, IPv6 Hop Limit is default value `OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT`."]
    #[doc = "< Otherwise, specifies the IPv6 Hop Limit."]
    pub mHopLimit: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otMessageInfo {
    #[inline]
    pub fn mEcn(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mEcn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsHostInterface(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHostInterface(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAllowZeroHopLimit(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllowZeroHopLimit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMulticastLoop(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMulticastLoop(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mEcn: u8,
        mIsHostInterface: bool,
        mAllowZeroHopLimit: bool,
        mMulticastLoop: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mEcn: u8 = unsafe { ::core::mem::transmute(mEcn) };
            mEcn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsHostInterface: u8 = unsafe { ::core::mem::transmute(mIsHostInterface) };
            mIsHostInterface as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mAllowZeroHopLimit: u8 = unsafe { ::core::mem::transmute(mAllowZeroHopLimit) };
            mAllowZeroHopLimit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mMulticastLoop: u8 = unsafe { ::core::mem::transmute(mMulticastLoop) };
            mMulticastLoop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< IPv6 Hop-by-Hop Option"]
pub const OT_IP6_PROTO_HOP_OPTS: crate::c_types::c_uint = 0;
#[doc = "< Transmission Control Protocol"]
pub const OT_IP6_PROTO_TCP: crate::c_types::c_uint = 6;
#[doc = "< User Datagram"]
pub const OT_IP6_PROTO_UDP: crate::c_types::c_uint = 17;
#[doc = "< IPv6 encapsulation"]
pub const OT_IP6_PROTO_IP6: crate::c_types::c_uint = 41;
#[doc = "< Routing Header for IPv6"]
pub const OT_IP6_PROTO_ROUTING: crate::c_types::c_uint = 43;
#[doc = "< Fragment Header for IPv6"]
pub const OT_IP6_PROTO_FRAGMENT: crate::c_types::c_uint = 44;
#[doc = "< ICMP for IPv6"]
pub const OT_IP6_PROTO_ICMP6: crate::c_types::c_uint = 58;
#[doc = "< No Next Header for IPv6"]
pub const OT_IP6_PROTO_NONE: crate::c_types::c_uint = 59;
#[doc = "< Destination Options for IPv6"]
pub const OT_IP6_PROTO_DST_OPTS: crate::c_types::c_uint = 60;
#[doc = " Internet Protocol Numbers."]
#[doc = ""]
pub type _bindgen_ty_10 = crate::c_types::c_uint;
extern "C" {
    #[doc = " Brings the IPv6 interface up or down."]
    #[doc = ""]
    #[doc = " Call this to enable or disable IPv6 communication."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE to enable IPv6, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully brought the IPv6 interface up/down."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   IPv6 interface is not available since device is operating in raw-link mode"]
    #[doc = "                                  (applicable only when `OPENTHREAD_CONFIG_LINK_RAW_ENABLE` feature is enabled)."]
    #[doc = ""]
    pub fn otIp6SetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not the IPv6 interface is up."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   The IPv6 interface is enabled."]
    #[doc = " @retval FALSE  The IPv6 interface is disabled."]
    #[doc = ""]
    pub fn otIp6IsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Adds a Network Interface Address to the Thread interface."]
    #[doc = ""]
    #[doc = " The passed-in instance @p aAddress is copied by the Thread interface. The Thread interface only"]
    #[doc = " supports a fixed number of externally added unicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_UCAST_ADDRS`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to a Network Interface Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added (or updated) the Network Interface Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The Network Interface is already storing the maximum allowed external addresses."]
    pub fn otIp6AddUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otNetifAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Network Interface Address from the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Network Interface Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found."]
    pub fn otIp6RemoveUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 addresses assigned to the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first Network Interface Address."]
    pub fn otIp6GetUnicastAddresses(aInstance: *mut otInstance) -> *const otNetifAddress;
}
extern "C" {
    #[doc = " Subscribes the Thread interface to a Network Interface Multicast Address."]
    #[doc = ""]
    #[doc = " The passed in instance @p aAddress will be copied by the Thread interface. The Thread interface only"]
    #[doc = " supports a fixed number of externally added multicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_MCAST_ADDRS`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully subscribed to the Network Interface Multicast Address."]
    #[doc = " @retval OT_ERROR_ALREADY        The multicast address is already subscribed."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The IP Address indicated by @p aAddress is an invalid multicast address."]
    #[doc = " @retval OT_ERROR_REJECTED       The IP Address indicated by @p aAddress is an internal multicast address."]
    #[doc = " @retval OT_ERROR_NO_BUFS        The Network Interface is already storing the maximum allowed external multicast"]
    #[doc = "                                 addresses."]
    #[doc = ""]
    pub fn otIp6SubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Unsubscribes the Thread interface to a Network Interface Multicast Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully unsubscribed to the Network Interface Multicast Address."]
    #[doc = " @retval OT_ERROR_REJECTED      The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found."]
    #[doc = ""]
    pub fn otIp6UnsubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 multicast addresses subscribed to the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first Network Interface Multicast Address."]
    #[doc = ""]
    pub fn otIp6GetMulticastAddresses(aInstance: *mut otInstance)
        -> *const otNetifMulticastAddress;
}
extern "C" {
    #[doc = " Checks if multicast promiscuous mode is enabled on the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otIp6SetMulticastPromiscuousEnabled"]
    #[doc = ""]
    pub fn otIp6IsMulticastPromiscuousEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enables or disables multicast promiscuous mode on the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   TRUE to enable Multicast Promiscuous mode, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6IsMulticastPromiscuousEnabled"]
    #[doc = ""]
    pub fn otIp6SetMulticastPromiscuousEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv6 message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otIp6NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Allocate a new message buffer and write the IPv6 datagram to the message buffer for sending an IPv6 message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is NULL, the link layer security is enabled and the message priority is obtained from IPv6"]
    #[doc = "       message itself."]
    #[doc = "       If @p aSettings is not NULL, the @p aSetting->mPriority is ignored and obtained from IPv6 message itself."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aData        A pointer to the IPv6 datagram buffer."]
    #[doc = " @param[in]  aDataLength  The size of the IPv6 datagram buffer pointed by @p aData."]
    #[doc = " @param[in]  aSettings    A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message or NULL if malformed IPv6 header or insufficient message buffers are available."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otIp6NewMessageFromBuffer(
        aInstance: *mut otInstance,
        aData: *const u8,
        aDataLength: u16,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
#[doc = " This function pointer is called when an IPv6 datagram is received."]
#[doc = ""]
#[doc = " @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers"]
#[doc = "                       the ownership of the @p aMessage to the receiver of the callback. The message should be"]
#[doc = "                       freed by the receiver of the callback after it is processed (see otMessageFree())."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otIp6ReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received IPv6 datagrams."]
    #[doc = ""]
    #[doc = " By default, this callback does not pass Thread control traffic.  See otIp6SetReceiveFilterEnabled() to"]
    #[doc = " change the Thread control traffic filter setting."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when an IPv6 datagram is received or"]
    #[doc = "                               NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @sa otIp6IsReceiveFilterEnabled"]
    #[doc = " @sa otIp6SetReceiveFilterEnabled"]
    #[doc = ""]
    pub fn otIp6SetReceiveCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6ReceiveCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
#[doc = " @struct otIp6AddressInfo"]
#[doc = ""]
#[doc = " This structure represents IPv6 address information."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIp6AddressInfo {
    #[doc = "< A pointer to the IPv6 address."]
    pub mAddress: *const otIp6Address,
    #[doc = "< The prefix length of mAddress if it is a unicast address."]
    pub mPrefixLength: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otIp6AddressInfo {
    #[inline]
    pub fn mScope(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mScope(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mScope: u8, mPreferred: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mScope: u8 = unsafe { ::core::mem::transmute(mScope) };
            mScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called when an internal IPv6 address is added or removed."]
#[doc = ""]
#[doc = " @param[in]   aAddressInfo        A pointer to the IPv6 address information."]
#[doc = " @param[in]   aIsAdded            TRUE if the @p aAddress was added, FALSE if @p aAddress was removed."]
#[doc = " @param[in]   aContext            A pointer to application-specific context."]
#[doc = ""]
pub type otIp6AddressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aAddressInfo: *const otIp6AddressInfo,
        aIsAdded: bool,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to notify internal IPv6 address changes."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aCallback           A pointer to a function that is called when an internal IPv6 address is added or"]
    #[doc = "                                  removed. NULL to disable the callback."]
    #[doc = " @param[in]   aCallbackContext    A pointer to application-specific context."]
    #[doc = ""]
    pub fn otIp6SetAddressCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6AddressCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not Thread control traffic is filtered out when delivering IPv6 datagrams"]
    #[doc = " via the callback specified in otIp6SetReceiveCallback()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  TRUE if Thread control traffic is filtered out, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6SetReceiveCallback"]
    #[doc = " @sa otIp6SetReceiveFilterEnabled"]
    #[doc = ""]
    pub fn otIp6IsReceiveFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sets whether or not Thread control traffic is filtered out when delivering IPv6 datagrams"]
    #[doc = " via the callback specified in otIp6SetReceiveCallback()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled  TRUE if Thread control traffic is filtered out, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6SetReceiveCallback"]
    #[doc = " @sa otIsReceiveIp6FilterEnabled"]
    #[doc = ""]
    pub fn otIp6SetReceiveFilterEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function sends an IPv6 datagram via the Thread interface."]
    #[doc = ""]
    #[doc = " The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when"]
    #[doc = " processing is complete, including when a value other than `OT_ERROR_NONE` is returned."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage  A pointer to the message buffer containing the IPv6 datagram."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE                    Successfully processed the message."]
    #[doc = " @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing"]
    #[doc = " rules."]
    #[doc = " @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram."]
    #[doc = " @retval OT_ERROR_NO_ROUTE                No route to host."]
    #[doc = " @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address."]
    #[doc = " @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message."]
    #[doc = ""]
    pub fn otIp6Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " This function adds a port to the allowed unsecured port list."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort     The port value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         The port was successfully added to the allowed unsecure port list."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use)."]
    #[doc = " @retval OT_ERROR_NO_BUFS      The unsecure port list is full."]
    #[doc = ""]
    pub fn otIp6AddUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes a port from the allowed unsecure port list."]
    #[doc = ""]
    #[doc = " @note This function removes @p aPort by overwriting @p aPort with the element after @p aPort in the internal port"]
    #[doc = "       list. Be careful when calling otIp6GetUnsecurePorts() followed by otIp6RemoveUnsecurePort() to remove unsecure"]
    #[doc = "       ports."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort     The port value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         The port was successfully removed from the allowed unsecure port list."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use)."]
    #[doc = " @retval OT_ERROR_NOT_FOUND    The port was not found in the unsecure port list."]
    #[doc = ""]
    pub fn otIp6RemoveUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes all ports from the allowed unsecure port list."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otIp6RemoveAllUnsecurePorts(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns a pointer to the unsecure port list."]
    #[doc = ""]
    #[doc = " @note Port value 0 is used to indicate an invalid entry."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumEntries  The number of entries in the list."]
    #[doc = ""]
    #[doc = " @returns A pointer to the unsecure port list."]
    #[doc = ""]
    pub fn otIp6GetUnsecurePorts(aInstance: *mut otInstance, aNumEntries: *mut u8) -> *const u16;
}
extern "C" {
    #[doc = " Test if two IPv6 addresses are the same."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 address to compare."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 address to compare."]
    #[doc = ""]
    #[doc = " @retval TRUE   The two IPv6 addresses are the same."]
    #[doc = " @retval FALSE  The two IPv6 addresses are not the same."]
    #[doc = ""]
    pub fn otIp6IsAddressEqual(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " Test if two IPv6 prefixes are the same."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 prefix to compare."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 prefix to compare."]
    #[doc = ""]
    #[doc = " @retval TRUE   The two IPv6 prefixes are the same."]
    #[doc = " @retval FALSE  The two IPv6 prefixes are not the same."]
    #[doc = ""]
    pub fn otIp6ArePrefixesEqual(aFirst: *const otIp6Prefix, aSecond: *const otIp6Prefix) -> bool;
}
extern "C" {
    #[doc = " This function converts a human-readable IPv6 address string into a binary representation."]
    #[doc = ""]
    #[doc = " @param[in]   aString   A pointer to a NULL-terminated string."]
    #[doc = " @param[out]  aAddress  A pointer to an IPv6 address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully parsed the string."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  Failed to parse the string."]
    #[doc = ""]
    pub fn otIp6AddressFromString(
        aString: *const crate::c_types::c_char,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IPv6 address to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 address string is formatted as 16 hex values separated by ':' (i.e., \"%x:%x:%x:...:%x\")."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress  A pointer to an IPv6 address (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_ADDRESS_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6AddressToString(
        aAddress: *const otIp6Address,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 socket address to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 socket address string is formatted as [`address`]:`port` where `address` is shown"]
    #[doc = " as 16 hex values separated by `:` and `port` is the port number in decimal format,"]
    #[doc = " for example \"[%x:%x:...:%x]:%u\"."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aSockAddr A pointer to an IPv6 socket address (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_SOCK_ADDR_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6SockAddrToString(
        aSockAddr: *const otSockAddr,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 prefix to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 address string is formatted as \"%x:%x:%x:...[::]/plen\"."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aPrefix   A pointer to an IPv6 prefix (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_PREFIX_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6PrefixToString(
        aPrefix: *const otIp6Prefix,
        aBuffer: *mut crate::c_types::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function returns the prefix match length (bits) for two IPv6 addresses."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 address."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 address."]
    #[doc = ""]
    #[doc = " @returns  The prefix match length in bits."]
    #[doc = ""]
    pub fn otIp6PrefixMatch(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> u8;
}
extern "C" {
    #[doc = " This method gets a prefix with @p aLength from @p aAddress."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress   A pointer to an IPv6 address."]
    #[doc = " @param[in]  aLength    The length of prefix in bits."]
    #[doc = " @param[out] aPrefix    A pointer to output the IPv6 prefix."]
    #[doc = ""]
    pub fn otIp6GetPrefix(aAddress: *const otIp6Address, aLength: u8, aPrefix: *mut otIp6Prefix);
}
extern "C" {
    #[doc = " This function indicates whether or not a given IPv6 address is the Unspecified Address."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress   A pointer to an IPv6 address."]
    #[doc = ""]
    #[doc = " @retval TRUE   If the IPv6 address is the Unspecified Address."]
    #[doc = " @retval FALSE  If the IPv6 address is not the Unspecified Address."]
    #[doc = ""]
    pub fn otIp6IsAddressUnspecified(aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " This function perform OpenThread source address selection."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aMessageInfo  A pointer to the message information."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       Found a source address and is filled into mSockAddr of @p aMessageInfo."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  No source address was found and @p aMessageInfo is unchanged."]
    #[doc = ""]
    pub fn otIp6SelectSourceAddress(
        aInstance: *mut otInstance,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether the SLAAC module is enabled or not."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @retval TRUE    SLAAC module is enabled."]
    #[doc = " @retval FALSE   SLAAC module is disabled."]
    #[doc = ""]
    pub fn otIp6IsSlaacEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables/disables the SLAAC module."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " When SLAAC module is enabled, SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface."]
    #[doc = " When SLAAC module is disabled any previously added SLAAC address is removed."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE to enable, FALSE to disable."]
    #[doc = ""]
    pub fn otIp6SetSlaacEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
#[doc = " This function pointer allows user to filter prefixes and not allow an SLAAC address based on a prefix to be added."]
#[doc = ""]
#[doc = " `otIp6SetSlaacPrefixFilter()` can be used to set the filter handler. The filter handler is invoked by SLAAC module"]
#[doc = " when it is about to add a SLAAC address based on a prefix. Its boolean return value determines whether the address"]
#[doc = " is filtered (not added) or not."]
#[doc = ""]
#[doc = " @param[in] aInstance   A pointer to an OpenThread instance."]
#[doc = " @param[in] aPrefix     A pointer to prefix for which SLAAC address is about to be added."]
#[doc = ""]
#[doc = " @retval TRUE    Indicates that the SLAAC address based on the prefix should be filtered and NOT added."]
#[doc = " @retval FALSE   Indicates that the SLAAC address based on the prefix should be added."]
#[doc = ""]
pub type otIp6SlaacPrefixFilter = ::core::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aPrefix: *const otIp6Prefix) -> bool,
>;
extern "C" {
    #[doc = " This function sets the SLAAC module filter handler."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The filter handler is called by SLAAC module when it is about to add a SLAAC address based on a prefix to decide"]
    #[doc = " whether the address should be added or not."]
    #[doc = ""]
    #[doc = " A NULL filter handler disables filtering and allows all SLAAC addresses to be added."]
    #[doc = ""]
    #[doc = " If this function is not called, the default filter used by SLAAC module will be NULL (filtering is disabled)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in] aFilter      A pointer to SLAAC prefix filter handler, or NULL to disable filtering."]
    #[doc = ""]
    pub fn otIp6SetSlaacPrefixFilter(aInstance: *mut otInstance, aFilter: otIp6SlaacPrefixFilter);
}
#[doc = " This function pointer is called with results of `otIp6RegisterMulticastListeners`."]
#[doc = ""]
#[doc = " @param[in]  aContext  A pointer to the user context."]
#[doc = " @param[in]  aError    OT_ERROR_NONE when successfully sent MLR.req and received MLR.rsp,"]
#[doc = "                       OT_ERROR_RESPONSE_TIMEOUT when failed to receive MLR.rsp,"]
#[doc = "                       OT_ERROR_PARSE when failed to parse MLR.rsp."]
#[doc = " @param[in]  aMlrStatus         The Multicast Listener Registration status when @p aError is OT_ERROR_NONE."]
#[doc = " @param[in]  aFailedAddresses   A pointer to the failed IPv6 addresses when @p aError is OT_ERROR_NONE."]
#[doc = " @param[in]  aFailedAddressNum  The number of failed IPv6 addresses when @p aError is OT_ERROR_NONE."]
#[doc = ""]
#[doc = " @sa otIp6RegisterMulticastListeners"]
#[doc = ""]
pub type otIp6RegisterMulticastListenersCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aError: otError,
        aMlrStatus: u8,
        aFailedAddresses: *const otIp6Address,
        aFailedAddressNum: u8,
    ),
>;
extern "C" {
    #[doc = " This function registers Multicast Listeners to Primary Backbone Router."]
    #[doc = ""]
    #[doc = " Note: only available when both `OPENTHREAD_CONFIG_TMF_PROXY_MLR_ENABLE` and"]
    #[doc = " `OPENTHREAD_CONFIG_COMMISSIONER_ENABLE` are enabled)"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddresses   A Multicast Address Array to register."]
    #[doc = " @param[in]  aAddressNum  The number of Multicast Address to register (0 if @p aAddresses is NULL)."]
    #[doc = " @param[in]  aTimeout     A pointer to the timeout value (in seconds) to be included in MLR.req. A timeout value of 0"]
    #[doc = "                          removes the corresponding Multicast Listener. If NULL, MLR.req would have no Timeout Tlv by"]
    #[doc = "                          default."]
    #[doc = " @param[in]  aCallback    A pointer to the callback function."]
    #[doc = " @param[in]  aContext     A pointer to the user context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent MLR.req. The @p aCallback will be called iff this method"]
    #[doc = "                                 returns OT_ERROR_NONE."]
    #[doc = " @retval OT_ERROR_BUSY           If a previous registration was ongoing."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If one or more arguments are invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  If the device was not in a valid state to send MLR.req (e.g. Commissioner not"]
    #[doc = "                                 started, Primary Backbone Router not found)."]
    #[doc = " @retval OT_ERROR_NO_BUFS        If insufficient message buffers available."]
    #[doc = ""]
    #[doc = " @sa otIp6RegisterMulticastListenersCallback"]
    #[doc = ""]
    pub fn otIp6RegisterMulticastListeners(
        aInstance: *mut otInstance,
        aAddresses: *const otIp6Address,
        aAddressNum: u8,
        aTimeout: *const u32,
        aCallback: otIp6RegisterMulticastListenersCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Mesh Local IID (for test purpose)."]
    #[doc = ""]
    #[doc = " Only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aIid        A pointer to the Mesh Local IID to set."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the Mesh Local IID."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otIp6SetMeshLocalIid(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IP protocol number to a human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aIpProto   An IP protocol number (`OT_IP6_PROTO_*` enumeration)."]
    #[doc = ""]
    #[doc = " @returns A string representing @p aIpProto."]
    #[doc = ""]
    pub fn otIp6ProtoToString(aIpProto: u8) -> *const crate::c_types::c_char;
}
#[doc = " This callback allows OpenThread to provide specific handlers for certain UDP messages."]
#[doc = ""]
#[doc = " @retval  true    The message is handled by this receiver and should not be further processed."]
#[doc = " @retval  false   The message is not handled by this receiver."]
#[doc = ""]
pub type otUdpHandler = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aMessage: *const otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> bool,
>;
#[doc = " This structure represents a UDP receiver."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpReceiver {
    #[doc = "< A pointer to the next UDP receiver (internal use only)."]
    pub mNext: *mut otUdpReceiver,
    #[doc = "< A function pointer to the receiver callback."]
    pub mHandler: otUdpHandler,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " This function adds a UDP receiver."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aUdpReceiver    A pointer to the UDP receiver."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       The receiver is successfully added."]
    #[doc = " @retval  OT_ERROR_ALREADY    The UDP receiver was already added."]
    #[doc = ""]
    pub fn otUdpAddReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a UDP receiver."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aUdpReceiver    A pointer to the UDP receiver."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       The receiver is successfully removed."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  The UDP receiver was not added."]
    #[doc = ""]
    pub fn otUdpRemoveReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a UDP message without socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A pointer to a message without UDP header."]
    #[doc = " @param[in]  aMessageInfo  A pointer to a message info associated with @p aMessage."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the message into an output interface."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient available buffer to add the IPv6 headers."]
    #[doc = ""]
    pub fn otUdpSendDatagram(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
#[doc = " This callback allows OpenThread to inform the application of a received UDP message."]
#[doc = ""]
pub type otUdpReceive = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " This structure represents a UDP socket."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpSocket {
    #[doc = "< The local IPv6 socket address."]
    pub mSockName: otSockAddr,
    #[doc = "< The peer IPv6 socket address."]
    pub mPeerName: otSockAddr,
    #[doc = "< A function pointer to the application callback."]
    pub mHandler: otUdpReceive,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut crate::c_types::c_void,
    #[doc = "< A handle to platform's UDP."]
    pub mHandle: *mut crate::c_types::c_void,
    #[doc = "< A pointer to the next UDP socket (internal use only)."]
    pub mNext: *mut otUdpSocket,
}
#[doc = "< Unspecified network interface."]
pub const otNetifIdentifier_OT_NETIF_UNSPECIFIED: otNetifIdentifier = 0;
#[doc = "< The Thread interface."]
pub const otNetifIdentifier_OT_NETIF_THREAD: otNetifIdentifier = 1;
#[doc = "< The Backbone interface."]
pub const otNetifIdentifier_OT_NETIF_BACKBONE: otNetifIdentifier = 2;
#[doc = " This enumeration defines the OpenThread network interface identifiers."]
#[doc = ""]
pub type otNetifIdentifier = crate::c_types::c_uint;
extern "C" {
    #[doc = " Allocate a new message buffer for sending a UDP message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to use default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otUdpNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Open a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aCallback  A pointer to the application callback function."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully opened the socket."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to open the socket."]
    #[doc = ""]
    pub fn otUdpOpen(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aCallback: otUdpReceive,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if a UDP socket is open."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = ""]
    #[doc = " @returns Whether the UDP socket is open."]
    #[doc = ""]
    pub fn otUdpIsOpen(aInstance: *mut otInstance, aSocket: *const otUdpSocket) -> bool;
}
extern "C" {
    #[doc = " Close a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Successfully closed the socket."]
    #[doc = " @retval OT_ERROR_FAILED Failed to close UDP Socket."]
    #[doc = ""]
    pub fn otUdpClose(aInstance: *mut otInstance, aSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " Bind a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aSockName  A pointer to an IPv6 socket address structure."]
    #[doc = " @param[in]  aNetif     The network interface to bind."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Bind operation was successful."]
    #[doc = " @retval OT_ERROR_FAILED Failed to bind UDP socket."]
    #[doc = ""]
    pub fn otUdpBind(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
        aNetif: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Connect a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aSockName  A pointer to an IPv6 socket address structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Connect operation was successful."]
    #[doc = " @retval OT_ERROR_FAILED Failed to connect UDP socket."]
    #[doc = ""]
    pub fn otUdpConnect(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a UDP/IPv6 message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket       A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aMessage      A pointer to a message buffer."]
    #[doc = " @param[in]  aMessageInfo  A pointer to a message info structure."]
    #[doc = ""]
    #[doc = " If the return value is OT_ERROR_NONE, OpenThread takes ownership of @p aMessage, and the caller should no longer"]
    #[doc = " reference @p aMessage. If the return value is not OT_ERROR_NONE, the caller retains ownership of @p aMessage,"]
    #[doc = " including freeing @p aMessage if the message buffer is no longer needed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The message is successfully scheduled for sending."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid arguments are given."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient available buffer to add the UDP and IPv6 headers."]
    #[doc = ""]
    pub fn otUdpSend(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the head of linked list of UDP Sockets."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the head of UDP Socket linked list."]
    #[doc = ""]
    pub fn otUdpGetSockets(aInstance: *mut otInstance) -> *mut otUdpSocket;
}
#[doc = " This function pointer delivers the UDP packet to host and host should send the packet through its own network stack."]
#[doc = ""]
#[doc = " @param[in]  aMessage   A pointer to the UDP Message."]
#[doc = " @param[in]  aPeerPort  The destination UDP port."]
#[doc = " @param[in]  aPeerAddr  A pointer to the destination IPv6 address."]
#[doc = " @param[in]  aSockPort  The source UDP port."]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = ""]
pub type otUdpForwarder = ::core::option::Option<
    unsafe extern "C" fn(
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *mut otIp6Address,
        aSockPort: u16,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " Set UDP forward callback to deliver UDP packets to host."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aForwarder           A pointer to a function called to forward UDP packet to host."]
    #[doc = " @param[in]  aContext             A pointer to application-specific context."]
    #[doc = ""]
    pub fn otUdpForwardSetForwarder(
        aInstance: *mut otInstance,
        aForwarder: otUdpForwarder,
        aContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " Handle a UDP packet received from host."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage             A pointer to the UDP Message."]
    #[doc = " @param[in]  aPeerPort            The source UDP port."]
    #[doc = " @param[in]  aPeerAddr            A pointer to the source address."]
    #[doc = " @param[in]  aSockPort            The destination UDP port."]
    #[doc = ""]
    #[doc = " @warning No matter the call success or fail, the message is freed."]
    #[doc = ""]
    pub fn otUdpForwardReceive(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *const otIp6Address,
        aSockPort: u16,
    );
}
extern "C" {
    #[doc = " Determines if the given UDP port is exclusively opened by OpenThread API."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  port                 UDP port number to verify."]
    #[doc = ""]
    #[doc = " @retval true    The port is being used exclusively by OpenThread."]
    #[doc = " @retval false   The port is not used by any of the OpenThread API or is shared (e.g. is Backbone socket)."]
    #[doc = ""]
    pub fn otUdpIsPortInUse(aInstance: *mut otInstance, port: u16) -> bool;
}
#[doc = " @struct otNetworkKey"]
#[doc = ""]
#[doc = " This structure represents a Thread Network Key."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otNetworkKey {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to NetworkKey."]
#[doc = ""]
pub type otNetworkKeyRef = otCryptoKeyRef;
#[doc = " This structure represents a Network Name."]
#[doc = ""]
#[doc = " The `otNetworkName` is a null terminated C string (i.e., `m8` char array MUST end with null char `\\0`)."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkName {
    #[doc = "< Byte values. The `+ 1` is for null char."]
    pub m8: [crate::c_types::c_char; 17usize],
}
#[doc = " This structure represents an Extended PAN ID."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otExtendedPanId {
    #[doc = "< Byte values"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6NetworkPrefix"]
#[doc = ""]
#[doc = " This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address)."]
#[doc = ""]
pub type otMeshLocalPrefix = otIp6NetworkPrefix;
#[doc = " This structure represents PSKc."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otPskc {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to PSKc."]
#[doc = ""]
pub type otPskcRef = otCryptoKeyRef;
#[doc = " This structure represent Security Policy."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSecurityPolicy {
    #[doc = "< The value for thrKeyRotation in units of hours."]
    pub mRotationTime: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otSecurityPolicy {
    #[inline]
    pub fn mObtainNetworkKeyEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mObtainNetworkKeyEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNativeCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNativeCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mExternalCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mExternalCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCommercialCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCommercialCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAutonomousEnrollmentEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAutonomousEnrollmentEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkKeyProvisioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkKeyProvisioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mTobleLinkEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mTobleLinkEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNonCcmRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNonCcmRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mVersionThresholdForRouting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mVersionThresholdForRouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mObtainNetworkKeyEnabled: bool,
        mNativeCommissioningEnabled: bool,
        mRoutersEnabled: bool,
        mExternalCommissioningEnabled: bool,
        mCommercialCommissioningEnabled: bool,
        mAutonomousEnrollmentEnabled: bool,
        mNetworkKeyProvisioningEnabled: bool,
        mTobleLinkEnabled: bool,
        mNonCcmRoutersEnabled: bool,
        mVersionThresholdForRouting: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mObtainNetworkKeyEnabled: u8 =
                unsafe { ::core::mem::transmute(mObtainNetworkKeyEnabled) };
            mObtainNetworkKeyEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mNativeCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNativeCommissioningEnabled) };
            mNativeCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mRoutersEnabled: u8 = unsafe { ::core::mem::transmute(mRoutersEnabled) };
            mRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mExternalCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mExternalCommissioningEnabled) };
            mExternalCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mCommercialCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mCommercialCommissioningEnabled) };
            mCommercialCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mAutonomousEnrollmentEnabled: u8 =
                unsafe { ::core::mem::transmute(mAutonomousEnrollmentEnabled) };
            mAutonomousEnrollmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mNetworkKeyProvisioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNetworkKeyProvisioningEnabled) };
            mNetworkKeyProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mTobleLinkEnabled: u8 = unsafe { ::core::mem::transmute(mTobleLinkEnabled) };
            mTobleLinkEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mNonCcmRoutersEnabled: u8 =
                unsafe { ::core::mem::transmute(mNonCcmRoutersEnabled) };
            mNonCcmRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mVersionThresholdForRouting: u8 =
                unsafe { ::core::mem::transmute(mVersionThresholdForRouting) };
            mVersionThresholdForRouting as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This type represents Channel Mask."]
#[doc = ""]
pub type otChannelMask = u32;
#[doc = " This structure represents presence of different components in Active or Pending Operational Dataset."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otOperationalDatasetComponents {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otOperationalDatasetComponents {
    #[inline]
    pub fn mIsActiveTimestampPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsActiveTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPendingTimestampPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPendingTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkKeyPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkKeyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkNamePresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkNamePresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsExtendedPanIdPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsExtendedPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsMeshLocalPrefixPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsMeshLocalPrefixPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDelayPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDelayPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPanIdPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPskcPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPskcPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityPolicyPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityPolicyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelMaskPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelMaskPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsActiveTimestampPresent: bool,
        mIsPendingTimestampPresent: bool,
        mIsNetworkKeyPresent: bool,
        mIsNetworkNamePresent: bool,
        mIsExtendedPanIdPresent: bool,
        mIsMeshLocalPrefixPresent: bool,
        mIsDelayPresent: bool,
        mIsPanIdPresent: bool,
        mIsChannelPresent: bool,
        mIsPskcPresent: bool,
        mIsSecurityPolicyPresent: bool,
        mIsChannelMaskPresent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsActiveTimestampPresent: u8 =
                unsafe { ::core::mem::transmute(mIsActiveTimestampPresent) };
            mIsActiveTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsPendingTimestampPresent: u8 =
                unsafe { ::core::mem::transmute(mIsPendingTimestampPresent) };
            mIsPendingTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsNetworkKeyPresent: u8 = unsafe { ::core::mem::transmute(mIsNetworkKeyPresent) };
            mIsNetworkKeyPresent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsNetworkNamePresent: u8 =
                unsafe { ::core::mem::transmute(mIsNetworkNamePresent) };
            mIsNetworkNamePresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsExtendedPanIdPresent: u8 =
                unsafe { ::core::mem::transmute(mIsExtendedPanIdPresent) };
            mIsExtendedPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mIsMeshLocalPrefixPresent: u8 =
                unsafe { ::core::mem::transmute(mIsMeshLocalPrefixPresent) };
            mIsMeshLocalPrefixPresent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsDelayPresent: u8 = unsafe { ::core::mem::transmute(mIsDelayPresent) };
            mIsDelayPresent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mIsPanIdPresent: u8 = unsafe { ::core::mem::transmute(mIsPanIdPresent) };
            mIsPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mIsChannelPresent: u8 = unsafe { ::core::mem::transmute(mIsChannelPresent) };
            mIsChannelPresent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mIsPskcPresent: u8 = unsafe { ::core::mem::transmute(mIsPskcPresent) };
            mIsPskcPresent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mIsSecurityPolicyPresent: u8 =
                unsafe { ::core::mem::transmute(mIsSecurityPolicyPresent) };
            mIsSecurityPolicyPresent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mIsChannelMaskPresent: u8 =
                unsafe { ::core::mem::transmute(mIsChannelMaskPresent) };
            mIsChannelMaskPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Thread Dataset timestamp component."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTimestamp {
    pub mSeconds: u64,
    pub mTicks: u16,
    pub mAuthoritative: bool,
}
#[doc = " This structure represents an Active or Pending Operational Dataset."]
#[doc = ""]
#[doc = " Components in Dataset are optional. `mComponets` structure specifies which components are present in the Dataset."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otOperationalDataset {
    #[doc = "< Active Timestamp"]
    pub mActiveTimestamp: otTimestamp,
    #[doc = "< Pending Timestamp"]
    pub mPendingTimestamp: otTimestamp,
    #[doc = "< Network Key"]
    pub mNetworkKey: otNetworkKey,
    #[doc = "< Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Mesh Local Prefix"]
    pub mMeshLocalPrefix: otMeshLocalPrefix,
    #[doc = "< Delay Timer"]
    pub mDelay: u32,
    #[doc = "< PAN ID"]
    pub mPanId: otPanId,
    #[doc = "< Channel"]
    pub mChannel: u16,
    #[doc = "< PSKc"]
    pub mPskc: otPskc,
    #[doc = "< Security Policy"]
    pub mSecurityPolicy: otSecurityPolicy,
    #[doc = "< Channel Mask"]
    pub mChannelMask: otChannelMask,
    #[doc = "< Specifies which components are set in the Dataset."]
    pub mComponents: otOperationalDatasetComponents,
}
#[doc = " This structure represents an Active or Pending Operational Dataset."]
#[doc = ""]
#[doc = " The Operational Dataset is TLV encoded as specified by Thread."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otOperationalDatasetTlvs {
    #[doc = "< Operational Dataset TLVs."]
    pub mTlvs: [u8; 254usize],
    #[doc = "< Size of Operational Dataset in bytes."]
    pub mLength: u8,
}
#[doc = "< meshcop Channel TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNEL: otMeshcopTlvType = 0;
#[doc = "< meshcop Pan Id TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PANID: otMeshcopTlvType = 1;
#[doc = "< meshcop Extended Pan Id TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_EXTPANID: otMeshcopTlvType = 2;
#[doc = "< meshcop Network Name TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKNAME: otMeshcopTlvType = 3;
#[doc = "< meshcop PSKc TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PSKC: otMeshcopTlvType = 4;
#[doc = "< meshcop Network Key TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKKEY: otMeshcopTlvType = 5;
#[doc = "< meshcop Network Key Sequence TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORK_KEY_SEQUENCE: otMeshcopTlvType = 6;
#[doc = "< meshcop Mesh Local Prefix TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_MESHLOCALPREFIX: otMeshcopTlvType = 7;
#[doc = "< meshcop Steering Data TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STEERING_DATA: otMeshcopTlvType = 8;
#[doc = "< meshcop Border Agent Locator TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_BORDER_AGENT_RLOC: otMeshcopTlvType = 9;
#[doc = "< meshcop Commissioner ID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_ID: otMeshcopTlvType = 10;
#[doc = "< meshcop Commissioner Session ID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMM_SESSION_ID: otMeshcopTlvType = 11;
#[doc = "< meshcop Security Policy TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SECURITYPOLICY: otMeshcopTlvType = 12;
#[doc = "< meshcop Get TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_GET: otMeshcopTlvType = 13;
#[doc = "< meshcop Active Timestamp TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ACTIVETIMESTAMP: otMeshcopTlvType = 14;
#[doc = "< meshcop Commissioner UDP Port TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_UDP_PORT: otMeshcopTlvType = 15;
#[doc = "< meshcop State TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STATE: otMeshcopTlvType = 16;
#[doc = "< meshcop Joiner DTLS Encapsulation TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_DTLS: otMeshcopTlvType = 17;
#[doc = "< meshcop Joiner UDP Port TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_UDP_PORT: otMeshcopTlvType = 18;
#[doc = "< meshcop Joiner IID TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_IID: otMeshcopTlvType = 19;
#[doc = "< meshcop Joiner Router Locator TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_RLOC: otMeshcopTlvType = 20;
#[doc = "< meshcop Joiner Router KEK TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_ROUTER_KEK: otMeshcopTlvType = 21;
#[doc = "< meshcop Provisioning URL TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PROVISIONING_URL: otMeshcopTlvType = 32;
#[doc = "< meshcop Vendor Name TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_NAME_TLV: otMeshcopTlvType = 33;
#[doc = "< meshcop Vendor Model TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_MODEL_TLV: otMeshcopTlvType = 34;
#[doc = "< meshcop Vendor SW Version TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_SW_VERSION_TLV: otMeshcopTlvType = 35;
#[doc = "< meshcop Vendor Data TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_DATA_TLV: otMeshcopTlvType = 36;
#[doc = "< meshcop Vendor Stack Version TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_STACK_VERSION_TLV: otMeshcopTlvType = 37;
#[doc = "< meshcop UDP encapsulation TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_UDP_ENCAPSULATION_TLV: otMeshcopTlvType = 48;
#[doc = "< meshcop IPv6 address TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_IPV6_ADDRESS_TLV: otMeshcopTlvType = 49;
#[doc = "< meshcop Pending Timestamp TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PENDINGTIMESTAMP: otMeshcopTlvType = 51;
#[doc = "< meshcop Delay Timer TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DELAYTIMER: otMeshcopTlvType = 52;
#[doc = "< meshcop Channel Mask TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNELMASK: otMeshcopTlvType = 53;
#[doc = "< meshcop Count TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COUNT: otMeshcopTlvType = 54;
#[doc = "< meshcop Period TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PERIOD: otMeshcopTlvType = 55;
#[doc = "< meshcop Scan Duration TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SCAN_DURATION: otMeshcopTlvType = 56;
#[doc = "< meshcop Energy List TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ENERGY_LIST: otMeshcopTlvType = 57;
#[doc = "< meshcop Discovery Request TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYREQUEST: otMeshcopTlvType = 128;
#[doc = "< meshcop Discovery Response TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYRESPONSE: otMeshcopTlvType = 129;
#[doc = "< meshcop Joiner Advertisement TLV"]
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINERADVERTISEMENT: otMeshcopTlvType = 241;
#[doc = " This enumeration represents meshcop TLV types."]
#[doc = ""]
pub type otMeshcopTlvType = crate::c_types::c_uint;
#[doc = " This function pointer is called when a response to a MGMT_SET request is received or times out."]
#[doc = ""]
#[doc = " @param[in]  aResult   A result of the operation."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE              The request was accepted by the leader."]
#[doc = " @retval  OT_ERROR_REJECTED          The request was rejected by the leader."]
#[doc = " @retval  OT_ERROR_PARSE             An error occurred during parsing the response."]
#[doc = " @retval  OT_ERROR_ABORT             The request was reset by peer."]
#[doc = " @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period."]
#[doc = ""]
pub type otDatasetMgmtSetCallback = ::core::option::Option<
    unsafe extern "C" fn(aResult: otError, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function indicates whether a valid network is present in the Active Operational Dataset or not."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if a valid network is present in the Active Operational Dataset, FALSE otherwise."]
    #[doc = ""]
    pub fn otDatasetIsCommissioned(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetActive(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " If the dataset does not include an Active Timestamp, the dataset is only partially complete."]
    #[doc = ""]
    #[doc = " If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to"]
    #[doc = " an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to"]
    #[doc = " attach to a network."]
    #[doc = ""]
    #[doc = " If channel is not included in the dataset, the device will send MLE Announce messages across different channels to"]
    #[doc = " find neighbors on other channels."]
    #[doc = ""]
    #[doc = " If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from"]
    #[doc = " its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a"]
    #[doc = " complete Active Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetActive(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " If the dataset does not include an Active Timestamp, the dataset is only partially complete."]
    #[doc = ""]
    #[doc = " If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to"]
    #[doc = " an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to"]
    #[doc = " attach to a network."]
    #[doc = ""]
    #[doc = " If channel is not included in the dataset, the device will send MLE Announce messages across different channels to"]
    #[doc = " find neighbors on other channels."]
    #[doc = ""]
    #[doc = " If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from"]
    #[doc = " its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a"]
    #[doc = " complete Active Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetPending(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetPending(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request."]
    #[doc = " @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested."]
    #[doc = " @param[in]  aLength             The length of @p aTlvTypes."]
    #[doc = " @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = ""]
    pub fn otDatasetSendMgmtActiveGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to operational dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called on response reception or timeout."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context for @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_BUSY          A previous request is ongoing."]
    #[doc = ""]
    pub fn otDatasetSendMgmtActiveSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request."]
    #[doc = " @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested."]
    #[doc = " @param[in]  aLength             The length of @p aTlvTypes."]
    #[doc = " @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = ""]
    pub fn otDatasetSendMgmtPendingGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to operational dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called on response reception or timeout."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context for @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_BUSY          A previous request is ongoing."]
    #[doc = ""]
    pub fn otDatasetSendMgmtPendingSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function generates PSKc from a given pass-phrase, network name, and extended PAN ID."]
    #[doc = ""]
    #[doc = " PSKc is used to establish the Commissioner Session."]
    #[doc = ""]
    #[doc = " @param[in]  aPassPhrase   The commissioning pass-phrase."]
    #[doc = " @param[in]  aNetworkName  The network name for PSKc computation."]
    #[doc = " @param[in]  aExtPanId     The extended PAN ID for PSKc computation."]
    #[doc = " @param[out] aPskc         A pointer to variable to output the generated PSKc."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully generate PSKc."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  If any of the input arguments is invalid."]
    #[doc = ""]
    pub fn otDatasetGeneratePskc(
        aPassPhrase: *const crate::c_types::c_char,
        aNetworkName: *const otNetworkName,
        aExtPanId: *const otExtendedPanId,
        aPskc: *mut otPskc,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets an `otNetworkName` instance from a given null terminated C string."]
    #[doc = ""]
    #[doc = " @p aNameString must follow UTF-8 encoding and the Network Name length must not be longer than"]
    #[doc = " `OT_NETWORK_NAME_MAX_SIZE`."]
    #[doc = ""]
    #[doc = " @param[out] aNetworkName        A pointer to the `otNetworkName` to set."]
    #[doc = " @param[in]  aNameString         A name C string."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set @p aNetworkName from @p aNameString."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aNameStrng is invalid (too long or does not follow UTF-8 encoding)."]
    #[doc = ""]
    pub fn otNetworkNameFromString(
        aNetworkName: *mut otNetworkName,
        aNameString: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function parses an Operational Dataset from a `otOperationalDatasetTlvs`."]
    #[doc = ""]
    #[doc = " @param[in]  aDatasetTlvs  A pointer to dataset TLVs."]
    #[doc = " @param[out] aDataset      A pointer to where the dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set @p aDataset from @p aDatasetTlvs."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDatasetTlvs is invalid."]
    #[doc = ""]
    pub fn otDatasetParseTlvs(
        aDatasetTlvs: *const otOperationalDatasetTlvs,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
pub const otJoinerState_OT_JOINER_STATE_IDLE: otJoinerState = 0;
pub const otJoinerState_OT_JOINER_STATE_DISCOVER: otJoinerState = 1;
pub const otJoinerState_OT_JOINER_STATE_CONNECT: otJoinerState = 2;
pub const otJoinerState_OT_JOINER_STATE_CONNECTED: otJoinerState = 3;
pub const otJoinerState_OT_JOINER_STATE_ENTRUST: otJoinerState = 4;
pub const otJoinerState_OT_JOINER_STATE_JOINED: otJoinerState = 5;
#[doc = " This enumeration defines the Joiner State."]
#[doc = ""]
pub type otJoinerState = crate::c_types::c_uint;
#[doc = " This structure represents a Joiner Discerner."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerDiscerner {
    #[doc = "< Discerner value (the lowest `mLength` bits specify the discerner)."]
    pub mValue: u64,
    #[doc = "< Length (number of bits) - must be non-zero and at most `OT_JOINER_MAX_DISCERNER_LENGTH`."]
    pub mLength: u8,
}
#[doc = " This function pointer is called to notify the completion of a join operation."]
#[doc = ""]
#[doc = " @param[in]  aError    OT_ERROR_NONE if the join process succeeded."]
#[doc = "                       OT_ERROR_SECURITY if the join process failed due to security credentials."]
#[doc = "                       OT_ERROR_NOT_FOUND if no joinable network was discovered."]
#[doc = "                       OT_ERROR_RESPONSE_TIMEOUT if a response timed out."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " Enables the Thread Joiner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPskd             A pointer to the PSKd."]
    #[doc = " @param[in]  aProvisioningUrl  A pointer to the Provisioning URL (may be NULL)."]
    #[doc = " @param[in]  aVendorName       A pointer to the Vendor Name (may be NULL)."]
    #[doc = " @param[in]  aVendorModel      A pointer to the Vendor Model (may be NULL)."]
    #[doc = " @param[in]  aVendorSwVersion  A pointer to the Vendor SW Version (may be NULL)."]
    #[doc = " @param[in]  aVendorData       A pointer to the Vendor Data (may be NULL)."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when the join operation completes."]
    #[doc = " @param[in]  aContext          A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE              Successfully started the Joiner role."]
    #[doc = " @retval OT_ERROR_BUSY              The previous attempt is still on-going."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS      @p aPskd or @p aProvisioningUrl is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE     The IPv6 stack is not enabled or Thread stack is fully enabled."]
    #[doc = ""]
    pub fn otJoinerStart(
        aInstance: *mut otInstance,
        aPskd: *const crate::c_types::c_char,
        aProvisioningUrl: *const crate::c_types::c_char,
        aVendorName: *const crate::c_types::c_char,
        aVendorModel: *const crate::c_types::c_char,
        aVendorSwVersion: *const crate::c_types::c_char,
        aVendorData: *const crate::c_types::c_char,
        aCallback: otJoinerCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Disables the Thread Joiner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otJoinerStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Joiner State."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_JOINER_STATE_IDLE"]
    #[doc = " @retval OT_JOINER_STATE_DISCOVER"]
    #[doc = " @retval OT_JOINER_STATE_CONNECT"]
    #[doc = " @retval OT_JOINER_STATE_CONNECTED"]
    #[doc = " @retval OT_JOINER_STATE_ENTRUST"]
    #[doc = " @retval OT_JOINER_STATE_JOINED"]
    #[doc = ""]
    pub fn otJoinerGetState(aInstance: *mut otInstance) -> otJoinerState;
}
extern "C" {
    #[doc = " Gets the Joiner ID."]
    #[doc = ""]
    #[doc = " If a Joiner Discerner is not set, Joiner ID is the first 64 bits of the result of computing SHA-256 over"]
    #[doc = " factory-assigned IEEE EUI-64. Otherwise the Joiner ID is calculated from the Joiner Discerner value."]
    #[doc = ""]
    #[doc = " The Joiner ID is also used as the device's IEEE 802.15.4 Extended Address during the commissioning process."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Joiner ID."]
    #[doc = ""]
    pub fn otJoinerGetId(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the Joiner Discerner."]
    #[doc = ""]
    #[doc = " The Joiner Discerner is used to calculate the Joiner ID during the Thread Commissioning process. For more"]
    #[doc = " information, refer to #otJoinerGetId."]
    #[doc = " @note The Joiner Discerner takes the place of the Joiner EUI-64 during the joiner session of Thread Commissioning."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to the OpenThread instance."]
    #[doc = " @param[in]   aDiscerner   A pointer to a Joiner Discerner. If NULL clears any previously set discerner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The Joiner Discerner updated successfully."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aDiscerner is not valid (specified length is not within valid range)."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  There is an ongoing Joining process so Joiner Discerner could not be changed."]
    #[doc = ""]
    pub fn otJoinerSetDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *mut otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Joiner Discerner. For more information, refer to #otJoinerSetDiscerner."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Joiner Discerner or NULL if none is set."]
    #[doc = ""]
    pub fn otJoinerGetDiscerner(aInstance: *mut otInstance) -> *const otJoinerDiscerner;
}
extern "C" {
    #[doc = " This function converts a given joiner state enumeration value to a human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aState   The joiner state."]
    #[doc = ""]
    #[doc = " @returns A human-readable string representation of @p aState."]
    #[doc = ""]
    pub fn otJoinerStateToString(aState: otJoinerState) -> *const crate::c_types::c_char;
}
#[doc = "< Commissioner role is disabled."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_DISABLED: otCommissionerState = 0;
#[doc = "< Currently petitioning to become a Commissioner."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_PETITION: otCommissionerState = 1;
#[doc = "< Commissioner role is active."]
pub const otCommissionerState_OT_COMMISSIONER_STATE_ACTIVE: otCommissionerState = 2;
#[doc = " This enumeration defines the Commissioner State."]
#[doc = ""]
pub type otCommissionerState = crate::c_types::c_uint;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_START: otCommissionerJoinerEvent = 0;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_CONNECTED: otCommissionerJoinerEvent = 1;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_FINALIZE: otCommissionerJoinerEvent = 2;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_END: otCommissionerJoinerEvent = 3;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_REMOVED: otCommissionerJoinerEvent = 4;
#[doc = " This enumeration defines a Joiner Event on the Commissioner."]
#[doc = ""]
pub type otCommissionerJoinerEvent = crate::c_types::c_uint;
#[doc = " This structure represents the steering data."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSteeringData {
    #[doc = "< Length of steering data (bytes)"]
    pub mLength: u8,
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This structure represents a Commissioning Dataset."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCommissioningDataset {
    #[doc = "< Border Router RLOC16"]
    pub mLocator: u16,
    #[doc = "< Commissioner Session Id"]
    pub mSessionId: u16,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otCommissioningDataset {
    #[inline]
    pub fn mIsLocatorSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsLocatorSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSessionIdSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSessionIdSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSteeringDataSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSteeringDataSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinerUdpPortSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinerUdpPortSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsLocatorSet: bool,
        mIsSessionIdSet: bool,
        mIsSteeringDataSet: bool,
        mIsJoinerUdpPortSet: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsLocatorSet: u8 = unsafe { ::core::mem::transmute(mIsLocatorSet) };
            mIsLocatorSet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsSessionIdSet: u8 = unsafe { ::core::mem::transmute(mIsSessionIdSet) };
            mIsSessionIdSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsSteeringDataSet: u8 = unsafe { ::core::mem::transmute(mIsSteeringDataSet) };
            mIsSteeringDataSet as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsJoinerUdpPortSet: u8 = unsafe { ::core::mem::transmute(mIsJoinerUdpPortSet) };
            mIsJoinerUdpPortSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Joiner PSKd."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerPskd {
    #[doc = "< Char string array (must be null terminated - +1 is for null char)."]
    pub m8: [crate::c_types::c_char; 33usize],
}
#[doc = "< Accept any Joiner (no EUI64 or Discerner is specified)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_ANY: otJoinerInfoType = 0;
#[doc = "< Joiner EUI-64 is specified (`mSharedId.mEui64` in `otJoinerInfo`)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_EUI64: otJoinerInfoType = 1;
#[doc = "< Joiner Discerner is specified (`mSharedId.mDiscerner` in `otJoinerInfo`)."]
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_DISCERNER: otJoinerInfoType = 2;
#[doc = " This enumeration defines a Joiner Info Type."]
#[doc = ""]
pub type otJoinerInfoType = crate::c_types::c_uint;
#[doc = " This structure represents a Joiner Info."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerInfo {
    #[doc = "< Joiner type."]
    pub mType: otJoinerInfoType,
    #[doc = "< Shared fields"]
    pub mSharedId: otJoinerInfo__bindgen_ty_1,
    #[doc = "< Joiner PSKd"]
    pub mPskd: otJoinerPskd,
    #[doc = "< Joiner expiration time in msec"]
    pub mExpirationTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otJoinerInfo__bindgen_ty_1 {
    #[doc = "< Joiner EUI64 (when `mType` is `OT_JOINER_INFO_TYPE_EUI64`)"]
    pub mEui64: otExtAddress,
    #[doc = "< Joiner Discerner (when `mType` is `OT_JOINER_INFO_TYPE_DISCERNER`)"]
    pub mDiscerner: otJoinerDiscerner,
}
#[doc = " This function pointer is called whenever the commissioner state changes."]
#[doc = ""]
#[doc = " @param[in]  aState    The Commissioner state."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerStateCallback = ::core::option::Option<
    unsafe extern "C" fn(aState: otCommissionerState, aContext: *mut crate::c_types::c_void),
>;
#[doc = " This function pointer is called whenever the joiner state changes."]
#[doc = ""]
#[doc = " @param[in]  aEvent       The joiner event type."]
#[doc = " @param[in]  aJoinerInfo  A pointer to the Joiner Info."]
#[doc = " @param[in]  aJoinerId    A pointer to the Joiner ID (if not known, it will be NULL)."]
#[doc = " @param[in]  aContext     A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aEvent: otCommissionerJoinerEvent,
        aJoinerInfo: *const otJoinerInfo,
        aJoinerId: *const otExtAddress,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function enables the Thread Commissioner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aStateCallback    A pointer to a function that is called when the commissioner state changes."]
    #[doc = " @param[in]  aJoinerCallback   A pointer to a function that is called with a joiner event occurs."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started the Commissioner service."]
    #[doc = " @retval OT_ERROR_ALREADY        Commissioner is already started."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not currently attached to a network."]
    #[doc = ""]
    pub fn otCommissionerStart(
        aInstance: *mut otInstance,
        aStateCallback: otCommissionerStateCallback,
        aJoinerCallback: otCommissionerJoinerCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function disables the Thread Commissioner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully stopped the Commissioner service."]
    #[doc = " @retval OT_ERROR_ALREADY  Commissioner is already stopped."]
    #[doc = ""]
    pub fn otCommissionerStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Id."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Commissioner Id."]
    #[doc = ""]
    pub fn otCommissionerGetId(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " This function sets the Commissioner Id."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aId           A pointer to a string character array. Must be null terminated."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Commissioner Id."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    Given name is too long."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The commissioner is active and id cannot be changed."]
    #[doc = ""]
    pub fn otCommissionerSetId(
        aInstance: *mut otInstance,
        aId: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner."]
    #[doc = " @param[in]  aPskd              A pointer to the PSKd."]
    #[doc = " @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the Joiner."]
    #[doc = " @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aEui64 or @p aPskd is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAddJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
        aPskd: *const crate::c_types::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry with a given Joiner Discerner value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDiscerner         A pointer to the Joiner Discerner."]
    #[doc = " @param[in]  aPskd              A pointer to the PSKd."]
    #[doc = " @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the Joiner."]
    #[doc = " @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDiscerner or @p aPskd is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAddJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
        aPskd: *const crate::c_types::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This method get joiner info at aIterator position."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance   A pointer to instance."]
    #[doc = " @param[in,out]  aIterator   A pointer to the Joiner Info iterator context."]
    #[doc = " @param[out]     aJoiner     A reference to Joiner info."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully get the Joiner info."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Not found next Joiner."]
    #[doc = ""]
    pub fn otCommissionerGetNextJoinerInfo(
        aInstance: *mut otInstance,
        aIterator: *mut u16,
        aJoiner: *mut otJoinerInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Joiner."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aEui64 is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerRemoveJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDiscerner         A pointer to the Joiner Discerner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Joiner."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDiscerner is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerRemoveJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Provisioning URL."]
    #[doc = ""]
    #[doc = " @param[in]    aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the URL string."]
    #[doc = ""]
    pub fn otCommissionerGetProvisioningUrl(
        aInstance: *mut otInstance,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " This function sets the Provisioning URL."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aProvisioningUrl      A pointer to the Provisioning URL (may be NULL to set as empty string)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the Provisioning URL."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aProvisioningUrl is invalid (too long)."]
    #[doc = ""]
    pub fn otCommissionerSetProvisioningUrl(
        aInstance: *mut otInstance,
        aProvisioningUrl: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an Announce Begin message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aCount                The number of Announcement messages per channel."]
    #[doc = " @param[in]  aPeriod               The time between two successive MLE Announce transmissions (in milliseconds)."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the Announce Begin message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Announce Begin message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAnnounceBegin(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aAddress: *const otIp6Address,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives an Energy Report."]
#[doc = ""]
#[doc = " @param[in]  aChannelMask       The channel mask value."]
#[doc = " @param[in]  aEnergyList        A pointer to the energy measurement list."]
#[doc = " @param[in]  aEnergyListLength  Number of entries in @p aEnergyListLength."]
#[doc = " @param[in]  aContext           A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerEnergyReportCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aChannelMask: u32,
        aEnergyList: *const u8,
        aEnergyListLength: u8,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends an Energy Scan Query message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aCount                The number of energy measurements per channel."]
    #[doc = " @param[in]  aPeriod               The time between energy measurements (milliseconds)."]
    #[doc = " @param[in]  aScanDuration         The scan duration for each energy measurement (milliseconds)."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = " @param[in]  aCallback             A pointer to a function called on receiving an Energy Report message."]
    #[doc = " @param[in]  aContext              A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the Energy Scan Query message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Energy Scan Query message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerEnergyScan(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aScanDuration: u16,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerEnergyReportCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives a PAN ID Conflict message."]
#[doc = ""]
#[doc = " @param[in]  aPanId             The PAN ID value."]
#[doc = " @param[in]  aChannelMask       The channel mask value."]
#[doc = " @param[in]  aContext           A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerPanIdConflictCallback = ::core::option::Option<
    unsafe extern "C" fn(aPanId: u16, aChannelMask: u32, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function sends a PAN ID Query message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPanId                The PAN ID to query."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = " @param[in]  aCallback             A pointer to a function called on receiving a PAN ID Conflict message."]
    #[doc = " @param[in]  aContext              A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the PAN ID Query message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate a PAN ID Query message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerPanIdQuery(
        aInstance: *mut otInstance,
        aPanId: u16,
        aChannelMask: u32,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerPanIdConflictCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    pub fn otCommissionerSendMgmtGet(
        aInstance: *mut otInstance,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to commissioning dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    pub fn otCommissionerSendMgmtSet(
        aInstance: *mut otInstance,
        aDataset: *const otCommissioningDataset,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Session ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current commissioner session id."]
    #[doc = ""]
    pub fn otCommissionerGetSessionId(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function returns the Commissioner State."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_COMMISSIONER_STATE_DISABLED  Commissioner disabled."]
    #[doc = " @retval OT_COMMISSIONER_STATE_PETITION  Becoming the commissioner."]
    #[doc = " @retval OT_COMMISSIONER_STATE_ACTIVE    Commissioner enabled."]
    #[doc = ""]
    pub fn otCommissionerGetState(aInstance: *mut otInstance) -> otCommissionerState;
}
#[doc = " This structure represents link-specific information for messages received from the Thread radio."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadLinkInfo {
    #[doc = "< Source PAN ID"]
    pub mPanId: u16,
    #[doc = "< 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< Received Signal Strength in dBm."]
    pub mRss: i8,
    #[doc = "< Link Quality Indicator for a received message."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< The time sync sequence."]
    pub mTimeSyncSeq: u8,
    #[doc = "< The time offset to the Thread network time, in microseconds."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< Radio link type."]
    pub mRadioType: u8,
}
impl otThreadLinkInfo {
    #[inline]
    pub fn mLinkSecurity(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkSecurity(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDstPanIdBroadcast(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDstPanIdBroadcast(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkSecurity: bool,
        mIsDstPanIdBroadcast: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mLinkSecurity: u8 = unsafe { ::core::mem::transmute(mLinkSecurity) };
            mLinkSecurity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsDstPanIdBroadcast: u8 = unsafe { ::core::mem::transmute(mIsDstPanIdBroadcast) };
            mIsDstPanIdBroadcast as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otMacFilterIterator = u8;
#[doc = "< Address filter is disabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DISABLED: otMacFilterAddressMode = 0;
#[doc = "< Allowlist address filter mode is enabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_ALLOWLIST: otMacFilterAddressMode = 1;
#[doc = "< Denylist address filter mode is enabled."]
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DENYLIST: otMacFilterAddressMode = 2;
#[doc = " Defines address mode of the mac filter."]
#[doc = ""]
pub type otMacFilterAddressMode = crate::c_types::c_uint;
#[doc = " This structure represents a Mac Filter entry."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacFilterEntry {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Received signal strength"]
    pub mRssIn: i8,
}
#[doc = " This structure represents the MAC layer counters."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacCounters {
    #[doc = " The total number of unique MAC frame transmission requests."]
    #[doc = ""]
    #[doc = " Note that this counter is incremented for each MAC transmission request only by one,"]
    #[doc = " regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions."]
    #[doc = ""]
    #[doc = " This increment rule applies to the following counters:"]
    #[doc = "   - @p mTxUnicast"]
    #[doc = "   - @p mTxBroadcast"]
    #[doc = "   - @p mTxAckRequested"]
    #[doc = "   - @p mTxNoAckRequested"]
    #[doc = "   - @p mTxData"]
    #[doc = "   - @p mTxDataPoll"]
    #[doc = "   - @p mTxBeacon"]
    #[doc = "   - @p mTxBeaconRequest"]
    #[doc = "   - @p mTxOther"]
    #[doc = "   - @p mTxErrAbort"]
    #[doc = "   - @p mTxErrBusyChannel"]
    #[doc = ""]
    #[doc = " The following equations are valid:"]
    #[doc = "   - @p mTxTotal = @p mTxUnicast + @p mTxBroadcast"]
    #[doc = "   - @p mTxTotal = @p mTxAckRequested + @p mTxNoAckRequested"]
    #[doc = "   - @p mTxTotal = @p mTxData + @p mTxDataPoll + @p mTxBeacon + @p mTxBeaconRequest + @p mTxOther"]
    #[doc = ""]
    pub mTxTotal: u32,
    #[doc = " The total number of unique unicast MAC frame transmission requests."]
    #[doc = ""]
    pub mTxUnicast: u32,
    #[doc = " The total number of unique broadcast MAC frame transmission requests."]
    #[doc = ""]
    pub mTxBroadcast: u32,
    #[doc = " The total number of unique MAC frame transmission requests with requested acknowledgment."]
    #[doc = ""]
    pub mTxAckRequested: u32,
    #[doc = " The total number of unique MAC frame transmission requests that were acked."]
    #[doc = ""]
    pub mTxAcked: u32,
    #[doc = " The total number of unique MAC frame transmission requests without requested acknowledgment."]
    #[doc = ""]
    pub mTxNoAckRequested: u32,
    #[doc = " The total number of unique MAC Data frame transmission requests."]
    #[doc = ""]
    pub mTxData: u32,
    #[doc = " The total number of unique MAC Data Poll frame transmission requests."]
    #[doc = ""]
    pub mTxDataPoll: u32,
    #[doc = " The total number of unique MAC Beacon frame transmission requests."]
    #[doc = ""]
    pub mTxBeacon: u32,
    #[doc = " The total number of unique MAC Beacon Request frame transmission requests."]
    #[doc = ""]
    pub mTxBeaconRequest: u32,
    #[doc = " The total number of unique other MAC frame transmission requests."]
    #[doc = ""]
    #[doc = " This counter is currently used for counting out-of-band frames."]
    #[doc = ""]
    pub mTxOther: u32,
    #[doc = " The total number of MAC retransmission attempts."]
    #[doc = ""]
    #[doc = " Note that this counter is incremented by one for each retransmission attempt that may be"]
    #[doc = " triggered by lack of acknowledgement, CSMA/CA failure, or other type of transmission error."]
    #[doc = " The @p mTxRetry counter is incremented both for unicast and broadcast MAC frames."]
    #[doc = ""]
    #[doc = " Modify the following configuration parameters to control the amount of retransmissions in the system:"]
    #[doc = ""]
    #[doc = " - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_DIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_INDIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_TX_NUM_BCAST"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_DIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_INDIRECT"]
    #[doc = ""]
    #[doc = " Currently, this counter is invalid if the platform's radio driver capability includes"]
    #[doc = " @ref OT_RADIO_CAPS_TRANSMIT_RETRIES."]
    #[doc = ""]
    pub mTxRetry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for direct packets."]
    #[doc = ""]
    pub mTxDirectMaxRetryExpiry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for indirect packets."]
    #[doc = ""]
    pub mTxIndirectMaxRetryExpiry: u32,
    #[doc = " The total number of CCA failures."]
    #[doc = ""]
    #[doc = " The meaning of this counter can be different and it depends on the platform's radio driver capabilities."]
    #[doc = ""]
    #[doc = " If @ref OT_RADIO_CAPS_CSMA_BACKOFF is enabled, this counter represents the total number of full CSMA/CA"]
    #[doc = " failed attempts and it is incremented by one also for each retransmission (in case of a CSMA/CA fail)."]
    #[doc = ""]
    #[doc = " If @ref OT_RADIO_CAPS_TRANSMIT_RETRIES is enabled, this counter represents the total number of full CSMA/CA"]
    #[doc = " failed attempts and it is incremented by one for each individual data frame request (regardless of the"]
    #[doc = " amount of retransmissions)."]
    #[doc = ""]
    pub mTxErrCca: u32,
    #[doc = " The total number of unique MAC transmission request failures cause by an abort error."]
    #[doc = ""]
    pub mTxErrAbort: u32,
    #[doc = " The total number of unique MAC transmission requests failures caused by a busy channel (a CSMA/CA fail)."]
    #[doc = ""]
    pub mTxErrBusyChannel: u32,
    #[doc = " The total number of received frames."]
    #[doc = ""]
    #[doc = " This counter counts all frames reported by the platform's radio driver, including frames"]
    #[doc = " that were dropped, for example because of an FCS error."]
    #[doc = ""]
    pub mRxTotal: u32,
    #[doc = " The total number of unicast frames received."]
    #[doc = ""]
    pub mRxUnicast: u32,
    #[doc = " The total number of broadcast frames received."]
    #[doc = ""]
    pub mRxBroadcast: u32,
    #[doc = " The total number of MAC Data frames received."]
    #[doc = ""]
    pub mRxData: u32,
    #[doc = " The total number of MAC Data Poll frames received."]
    #[doc = ""]
    pub mRxDataPoll: u32,
    #[doc = " The total number of MAC Beacon frames received."]
    #[doc = ""]
    pub mRxBeacon: u32,
    #[doc = " The total number of MAC Beacon Request frames received."]
    #[doc = ""]
    pub mRxBeaconRequest: u32,
    #[doc = " The total number of other types of frames received."]
    #[doc = ""]
    pub mRxOther: u32,
    #[doc = " The total number of frames dropped by MAC Filter module, for example received from denylisted node."]
    #[doc = ""]
    pub mRxAddressFiltered: u32,
    #[doc = " The total number of frames dropped by destination address check, for example received frame for other node."]
    #[doc = ""]
    pub mRxDestAddrFiltered: u32,
    #[doc = " The total number of frames dropped due to duplication, that is when the frame has been already received."]
    #[doc = ""]
    #[doc = " This counter may be incremented, for example when ACK frame generated by the receiver hasn't reached"]
    #[doc = " transmitter node which performed retransmission."]
    #[doc = ""]
    pub mRxDuplicated: u32,
    #[doc = " The total number of frames dropped because of missing or malformed content."]
    #[doc = ""]
    pub mRxErrNoFrame: u32,
    #[doc = " The total number of frames dropped due to unknown neighbor."]
    #[doc = ""]
    pub mRxErrUnknownNeighbor: u32,
    #[doc = " The total number of frames dropped due to invalid source address."]
    #[doc = ""]
    pub mRxErrInvalidSrcAddr: u32,
    #[doc = " The total number of frames dropped due to security error."]
    #[doc = ""]
    #[doc = " This counter may be incremented, for example when lower than expected Frame Counter is used"]
    #[doc = " to encrypt the frame."]
    #[doc = ""]
    pub mRxErrSec: u32,
    #[doc = " The total number of frames dropped due to invalid FCS."]
    #[doc = ""]
    pub mRxErrFcs: u32,
    #[doc = " The total number of frames dropped due to other error."]
    #[doc = ""]
    pub mRxErrOther: u32,
}
#[doc = " This structure represents a received IEEE 802.15.4 Beacon."]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otActiveScanResult {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Thread Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Thread Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< IEEE 802.15.4 PAN ID"]
    pub mPanId: u16,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< RSSI (dBm)"]
    pub mRssi: i8,
    #[doc = "< LQI"]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otActiveScanResult {
    #[inline]
    pub fn mVersion(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNative(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNative(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDiscover(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDiscover(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mVersion: crate::c_types::c_uint,
        mIsNative: bool,
        mDiscover: bool,
        mIsJoinable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u32 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsNative: u8 = unsafe { ::core::mem::transmute(mIsNative) };
            mIsNative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mDiscover: u8 = unsafe { ::core::mem::transmute(mDiscover) };
            mDiscover as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsJoinable: u8 = unsafe { ::core::mem::transmute(mIsJoinable) };
            mIsJoinable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an energy scan result."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otEnergyScanResult {
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< The max RSSI (dBm)"]
    pub mMaxRssi: i8,
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Active Scan when an IEEE 802.15.4 Beacon is received or"]
#[doc = " the scan completes."]
#[doc = ""]
#[doc = " @param[in]  aResult   A valid pointer to the beacon information or NULL when the active scan completes."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otHandleActiveScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otActiveScanResult, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Active Scan"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels     A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK)."]
    #[doc = " @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel."]
    #[doc = " @param[in]  aCallback         A pointer to a function called on receiving a beacon or scan completes."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Accepted the Active Scan request."]
    #[doc = " @retval OT_ERROR_BUSY  Already performing an Active Scan."]
    #[doc = ""]
    pub fn otLinkActiveScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Active Scan is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 Active Scan is in progress, false otherwise."]
    pub fn otLinkIsActiveScanInProgress(aInstance: *mut otInstance) -> bool;
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Energy Scan when the result for a channel is ready or the"]
#[doc = " scan completes."]
#[doc = ""]
#[doc = " @param[in]  aResult   A valid pointer to the energy scan result information or NULL when the energy scan completes."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otHandleEnergyScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otEnergyScanResult, aContext: *mut crate::c_types::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Energy Scan"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels     A bit vector indicating on which channels to perform energy scan."]
    #[doc = " @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel."]
    #[doc = " @param[in]  aCallback         A pointer to a function called to pass on scan result on indicate scan completion."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Accepted the Energy Scan request."]
    #[doc = " @retval OT_ERROR_BUSY  Could not start the energy scan."]
    #[doc = ""]
    pub fn otLinkEnergyScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleEnergyScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Energy Scan is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 Energy Scan is in progress, false otherwise."]
    #[doc = ""]
    pub fn otLinkIsEnergyScanInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enqueues an IEEE 802.15.4 Data Request message for transmission."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enqueued an IEEE 802.15.4 Data Request message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in rx-off-when-idle mode."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient message buffers available."]
    #[doc = ""]
    pub fn otLinkSendDataRequest(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 MAC is in the transmit state."]
    #[doc = ""]
    #[doc = " MAC module is in the transmit state during CSMA/CA procedure, CCA, Data, Beacon or Data Request frame transmission"]
    #[doc = " and receiving an ACK of a transmitted frame. MAC module is not in the transmit state during transmission of an ACK"]
    #[doc = " frame or a Beacon Request frame."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 MAC is in the transmit state, false otherwise."]
    #[doc = ""]
    pub fn otLinkIsInTransmitState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @sa otLinkSetChannel"]
    #[doc = ""]
    pub fn otLinkGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 channel"]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful call to this function invalidates the"]
    #[doc = " Active and Pending Operational Datasets in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel    The IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the channel."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   If @p aChannel is not in the range [11, 26] or is not in the supported channel mask."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otLinkGetChannel"]
    #[doc = ""]
    pub fn otLinkSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Get the supported channel mask of MAC layer."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The supported channel mask as `uint32_t` with bit 0 (lsb) mapping to channel 0, bit 1 to channel 1, so on."]
    #[doc = ""]
    pub fn otLinkGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the supported channel mask of MAC layer."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask  The supported channel mask (bit 0 or lsb mapping to channel 0, and so on)."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the supported channel mask."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otLinkSetSupportedChannelMask(aInstance: *mut otInstance, aChannelMask: u32) -> otError;
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    pub fn otLinkGetExtendedAddress(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @note Only succeeds when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the IEEE 802.15.4 Extended Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aExtAddress was NULL."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otLinkSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the factory-assigned IEEE EUI-64."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to the OpenThread instance."]
    #[doc = " @param[out]  aEui64     A pointer to where the factory-assigned IEEE EUI-64 is placed."]
    #[doc = ""]
    pub fn otLinkGetFactoryAssignedIeeeEui64(aInstance: *mut otInstance, aEui64: *mut otExtAddress);
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @sa otLinkSetPanId"]
    #[doc = ""]
    pub fn otLinkGetPanId(aInstance: *mut otInstance) -> otPanId;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful call to this function also invalidates"]
    #[doc = " the Active and Pending Operational Datasets in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPanId       The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the PAN ID."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If aPanId is not in the range [0, 65534]."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otLinkGetPanId"]
    #[doc = ""]
    pub fn otLinkSetPanId(aInstance: *mut otInstance, aPanId: otPanId) -> otError;
}
extern "C" {
    #[doc = " Get the data poll period of sleepy end device."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The data poll period of sleepy end device in milliseconds."]
    #[doc = ""]
    #[doc = " @sa otLinkSetPollPeriod"]
    #[doc = ""]
    pub fn otLinkGetPollPeriod(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set/clear user-specified/external data poll period for sleepy end device."]
    #[doc = ""]
    #[doc = " @note This function updates only poll period of sleepy end device. To update child timeout the function"]
    #[doc = "       `otThreadSetChildTimeout()` shall be called."]
    #[doc = ""]
    #[doc = " @note Minimal non-zero value should be `OPENTHREAD_CONFIG_MAC_MINIMUM_POLL_PERIOD` (10ms)."]
    #[doc = "       Or zero to clear user-specified poll period."]
    #[doc = ""]
    #[doc = " @note User-specified value should be no more than the maximal value 0x3FFFFFF ((1 << 26) - 1) allowed,"]
    #[doc = " otherwise it would be clipped by the maximal value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPollPeriod  data poll period in milliseconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set/cleared user-specified poll period."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If aPollPeriod is invalid."]
    #[doc = ""]
    #[doc = " @sa otLinkGetPollPeriod"]
    #[doc = ""]
    pub fn otLinkSetPollPeriod(aInstance: *mut otInstance, aPollPeriod: u32) -> otError;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 Short Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Short Address."]
    #[doc = ""]
    pub fn otLinkGetShortAddress(aInstance: *mut otInstance) -> otShortAddress;
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during direct transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of retries during direct transmission."]
    #[doc = ""]
    pub fn otLinkGetMaxFrameRetriesDirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during direct transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance               A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxFrameRetriesDirect  The maximum number of retries during direct transmission."]
    #[doc = ""]
    pub fn otLinkSetMaxFrameRetriesDirect(aInstance: *mut otInstance, aMaxFrameRetriesDirect: u8);
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during indirect transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of retries during indirect transmission."]
    #[doc = ""]
    pub fn otLinkGetMaxFrameRetriesIndirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during indirect transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance                 A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxFrameRetriesIndirect  The maximum number of retries during indirect transmission."]
    #[doc = ""]
    pub fn otLinkSetMaxFrameRetriesIndirect(
        aInstance: *mut otInstance,
        aMaxFrameRetriesIndirect: u8,
    );
}
extern "C" {
    #[doc = " This function gets the address mode of MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  the address mode."]
    #[doc = ""]
    pub fn otLinkFilterGetAddressMode(aInstance: *mut otInstance) -> otMacFilterAddressMode;
}
extern "C" {
    #[doc = " This function sets the address mode of MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMode      The address mode to set."]
    #[doc = ""]
    pub fn otLinkFilterSetAddressMode(aInstance: *mut otInstance, aMode: otMacFilterAddressMode);
}
extern "C" {
    #[doc = " This method adds an Extended Address to MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully added @p aExtAddress to MAC filter."]
    #[doc = " @retval OT_ERROR_NO_BUFS        No available entry exists."]
    #[doc = ""]
    pub fn otLinkFilterAddAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes an Extended Address from MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " No action is performed if there is no existing entry in Filter matching the given Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL)."]
    #[doc = ""]
    pub fn otLinkFilterRemoveAddress(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method clears all the Extended Addresses from MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearAddresses(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use address filter entry."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the MAC filter iterator context. To get the first in-use address filter"]
    #[doc = "                            entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT. MUST NOT be NULL."]
    #[doc = " @param[out]     aEntry     A pointer to where the information is placed. MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved an in-use address filter entry."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent entry exists."]
    #[doc = ""]
    pub fn otLinkFilterGetNextAddress(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This method adds a fixed received signal strength (in dBm) entry for the messages from a given Extended Address in"]
    #[doc = " MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL."]
    #[doc = " @param[in]  aRss         A received signal strength (in dBm)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully added an entry for @p aExtAddress and @p aRss."]
    #[doc = " @retval OT_ERROR_NO_BUFS        No available entry exists."]
    #[doc = ""]
    pub fn otLinkFilterAddRssIn(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aRss: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes a MAC Filter entry for fixed received signal strength setting for a given Extended Address."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " No action is performed if there is no existing entry in Filter matching the given Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL."]
    #[doc = ""]
    pub fn otLinkFilterRemoveRssIn(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method sets the default received signal strength (in dBm) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " The default RSS value is used for all received frames from addresses for which there is no explicit RSS-IN entry"]
    #[doc = " in the Filter list (added using `otLinkFilterAddRssIn()`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRss         The default received signal strength (in dBm) to set."]
    #[doc = ""]
    pub fn otLinkFilterSetDefaultRssIn(aInstance: *mut otInstance, aRss: i8);
}
extern "C" {
    #[doc = " This method clears any previously set default received signal strength (in dBm) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearDefaultRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method clears all the received signal strength entries (including default RSS-in) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearAllRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use RssIn filter entry."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the MAC filter iterator context. MUST NOT be NULL."]
    #[doc = "                            To get the first entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT."]
    #[doc = " @param[out]     aEntry     A pointer to where the information is placed. The last entry would have the extended"]
    #[doc = "                            address as all 0xff to indicate the default received signal strength if it was set."]
    #[doc = "@p aEntry MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the next entry."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent entry exists."]
    #[doc = ""]
    pub fn otLinkFilterGetNextRssIn(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables IEEE 802.15.4 radio filter mode."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " The radio filter is mainly intended for testing. It can be used to temporarily block all tx/rx on the 802.15.4 radio."]
    #[doc = " When radio filter is enabled, radio is put to sleep instead of receive (to ensure device does not receive any frame"]
    #[doc = " and/or potentially send ack). Also the frame transmission requests return immediately without sending the frame over"]
    #[doc = " the air (return \"no ack\" error if ack is requested, otherwise return success)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in] aFilterEnabled    TRUE to enable radio filter, FALSE to disable"]
    #[doc = ""]
    pub fn otLinkSetRadioFilterEnabled(aInstance: *mut otInstance, aFilterEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the IEEE 802.15.4 radio filter is enabled or not."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @retval TRUE   If the radio filter is enabled."]
    #[doc = " @retval FALSE  If the radio filter is disabled."]
    #[doc = ""]
    pub fn otLinkIsRadioFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method converts received signal strength to link quality."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRss       The received signal strength value to be converted."]
    #[doc = ""]
    #[doc = " @return Link quality value mapping to @p aRss."]
    #[doc = ""]
    pub fn otLinkConvertRssToLinkQuality(aInstance: *mut otInstance, aRss: i8) -> u8;
}
extern "C" {
    #[doc = " This method converts link quality to typical received signal strength."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aLinkQuality  LinkQuality value, should be in range [0,3]."]
    #[doc = ""]
    #[doc = " @return Typical platform received signal strength mapping to @p aLinkQuality."]
    #[doc = ""]
    pub fn otLinkConvertLinkQualityToRss(aInstance: *mut otInstance, aLinkQuality: u8) -> i8;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single direct packet until success."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed."]
    #[doc = ""]
    #[doc = " @returns     A pointer to the histogram of retries (in a form of an array)."]
    #[doc = "              The n-th element indicates that the packet has been sent with n-th retry."]
    pub fn otLinkGetTxDirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single indirect packet until success."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed."]
    #[doc = ""]
    #[doc = " @returns     A pointer to the histogram of retries (in a form of an array)."]
    #[doc = "              The n-th element indicates that the packet has been sent with n-th retry."]
    #[doc = ""]
    pub fn otLinkGetTxIndirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method clears histogram statistics for direct and indirect transmissions."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkResetTxRetrySuccessHistogram(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the MAC layer counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the MAC layer counters."]
    #[doc = ""]
    pub fn otLinkGetCounters(aInstance: *mut otInstance) -> *const otMacCounters;
}
extern "C" {
    #[doc = " Resets the MAC layer counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkResetCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called when an IEEE 802.15.4 frame is received."]
#[doc = ""]
#[doc = " @note This callback is called after FCS processing and @p aFrame may not contain the actual FCS that was received."]
#[doc = ""]
#[doc = " @note This callback is called before IEEE 802.15.4 security processing."]
#[doc = ""]
#[doc = " @param[in]  aFrame    A pointer to the received IEEE 802.15.4 frame."]
#[doc = " @param[in]  aIsTx     Whether this frame is transmitted, not received."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otLinkPcapCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aFrame: *const otRadioFrame,
        aIsTx: bool,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received raw IEEE 802.15.4 frames."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPcapCallback     A pointer to a function that is called when receiving an IEEE 802.15.4 link frame or"]
    #[doc = "                               NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    pub fn otLinkSetPcapCallback(
        aInstance: *mut otInstance,
        aPcapCallback: otLinkPcapCallback,
        aCallbackContext: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not promiscuous mode is enabled at the link layer."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true   Promiscuous mode is enabled."]
    #[doc = " @retval false  Promiscuous mode is not enabled."]
    #[doc = ""]
    pub fn otLinkIsPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables or disables the link layer promiscuous mode."]
    #[doc = ""]
    #[doc = " @note Promiscuous mode may only be enabled when the Thread interface is disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPromiscuous  true to enable promiscuous mode, or false otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enabled promiscuous mode."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Could not enable promiscuous mode because"]
    #[doc = "                                 the Thread interface is enabled."]
    #[doc = ""]
    pub fn otLinkSetPromiscuous(aInstance: *mut otInstance, aPromiscuous: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL channel."]
    #[doc = ""]
    pub fn otLinkCslGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the CSL channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel       The CSL sample channel. Channel value should be `0` (Set CSL Channel unspecified) or"]
    #[doc = "                            within the range [1, 10] (if 915-MHz supported) and [11, 26] (if 2.4 GHz supported)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL parameters."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel."]
    #[doc = ""]
    pub fn otLinkCslSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL period."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL period in units of 10 symbols."]
    #[doc = ""]
    pub fn otLinkCslGetPeriod(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the CSL period in units of 10 symbols. Disable CSL by setting this parameter to `0`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPeriod        The CSL period in units of 10 symbols."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL period."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid CSL period."]
    #[doc = ""]
    pub fn otLinkCslSetPeriod(aInstance: *mut otInstance, aPeriod: u16) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL timeout."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL timeout in seconds."]
    #[doc = ""]
    pub fn otLinkCslGetTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the CSL timeout in seconds."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout       The CSL timeout in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL timeout."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid CSL timeout."]
    #[doc = ""]
    pub fn otLinkCslSetTimeout(aInstance: *mut otInstance, aTimeout: u32) -> otError;
}
extern "C" {
    #[doc = " This function returns the current CCA (Clear Channel Assessment) failure rate."]
    #[doc = ""]
    #[doc = " The rate is maintained over a window of (roughly) last `OPENTHREAD_CONFIG_CCA_FAILURE_RATE_AVERAGING_WINDOW`"]
    #[doc = " frame transmissions."]
    #[doc = ""]
    #[doc = " @returns The CCA failure rate with maximum value `0xffff` corresponding to 100% failure rate."]
    #[doc = ""]
    pub fn otLinkGetCcaFailureRate(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function enables or disables the link layer."]
    #[doc = ""]
    #[doc = " @note The link layer may only be enabled / disabled when the Thread Interface is disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnable       true to enable the link layer, or false otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enabled / disabled the link layer."]
    #[doc = " @retval OT_ERROR_INVALID_STATE Could not disable the link layer because"]
    #[doc = "                                the Thread interface is enabled."]
    #[doc = ""]
    pub fn otLinkSetEnabled(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the link layer is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true   Link layer is enabled."]
    #[doc = " @retval false  Link layer is not enabled."]
    #[doc = ""]
    pub fn otLinkIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function instructs the device to send an empty IEEE 802.15.4 data frame."]
    #[doc = ""]
    #[doc = " This function is only supported on an Rx-Off-When-Idle device to send an empty data frame to its parent."]
    #[doc = " Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enqueued an empty message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in Rx-Off-When-Idle mode."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient message buffers available."]
    #[doc = ""]
    pub fn otLinkSendEmptyData(aInstance: *mut otInstance) -> otError;
}
#[doc = "< The Thread stack is disabled."]
pub const otDeviceRole_OT_DEVICE_ROLE_DISABLED: otDeviceRole = 0;
#[doc = "< Not currently participating in a Thread network/partition."]
pub const otDeviceRole_OT_DEVICE_ROLE_DETACHED: otDeviceRole = 1;
#[doc = "< The Thread Child role."]
pub const otDeviceRole_OT_DEVICE_ROLE_CHILD: otDeviceRole = 2;
#[doc = "< The Thread Router role."]
pub const otDeviceRole_OT_DEVICE_ROLE_ROUTER: otDeviceRole = 3;
#[doc = "< The Thread Leader role."]
pub const otDeviceRole_OT_DEVICE_ROLE_LEADER: otDeviceRole = 4;
#[doc = " Represents a Thread device role."]
#[doc = ""]
pub type otDeviceRole = crate::c_types::c_uint;
#[doc = " This structure represents an MLE Link Mode configuration."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otLinkModeConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkModeConfig {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDeviceType(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDeviceType(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mDeviceType: bool,
        mNetworkData: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mDeviceType: u8 = unsafe { ::core::mem::transmute(mDeviceType) };
            mDeviceType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNetworkData: u8 = unsafe { ::core::mem::transmute(mNetworkData) };
            mNetworkData as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure holds diagnostic information for a neighboring Thread node"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNeighborInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Time last heard"]
    pub mAge: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Link Frame Counter"]
    pub mLinkFrameCounter: u32,
    #[doc = "< MLE Frame Counter"]
    pub mMleFrameCounter: u32,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl otNeighborInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChild(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsChild: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::core::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::core::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsChild: u8 = unsafe { ::core::mem::transmute(mIsChild) };
            mIsChild as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otNeighborInfoIterator = i16;
#[doc = " This structure represents the Thread Leader Data."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLeaderData {
    #[doc = "< Partition ID"]
    pub mPartitionId: u32,
    #[doc = "< Leader Weight"]
    pub mWeighting: u8,
    #[doc = "< Full Network Data Version"]
    pub mDataVersion: u8,
    #[doc = "< Stable Network Data Version"]
    pub mStableDataVersion: u8,
    #[doc = "< Leader Router ID"]
    pub mLeaderRouterId: u8,
}
#[doc = " This structure holds diagnostic information for a Thread Router"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRouterInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Router ID"]
    pub mRouterId: u8,
    #[doc = "< Next hop to router"]
    pub mNextHop: u8,
    #[doc = "< Path cost to router"]
    pub mPathCost: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Link Quality Out"]
    pub mLinkQualityOut: u8,
    #[doc = "< Time last heard"]
    pub mAge: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Thread version"]
    pub mVersion: u8,
    #[doc = "< CSL clock accuracy, in  ppm"]
    pub mCslClockAccuracy: u8,
    #[doc = "< CSL uncertainty, in 10 us"]
    pub mCslUncertainty: u8,
}
impl otRouterInfo {
    #[inline]
    pub fn mAllocated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllocated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkEstablished(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkEstablished(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAllocated: bool,
        mLinkEstablished: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAllocated: u8 = unsafe { ::core::mem::transmute(mAllocated) };
            mAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLinkEstablished: u8 = unsafe { ::core::mem::transmute(mLinkEstablished) };
            mLinkEstablished as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents the IP level counters."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIpCounters {
    #[doc = "< The number of IPv6 packets successfully transmitted."]
    pub mTxSuccess: u32,
    #[doc = "< The number of IPv6 packets successfully received."]
    pub mRxSuccess: u32,
    #[doc = "< The number of IPv6 packets failed to transmit."]
    pub mTxFailure: u32,
    #[doc = "< The number of IPv6 packets failed to receive."]
    pub mRxFailure: u32,
}
#[doc = " This structure represents the Thread MLE counters."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMleCounters {
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_CHILD role."]
    pub mChildRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderRole: u16,
    #[doc = "< Number of attach attempts while device was detached."]
    pub mAttachAttempts: u16,
    #[doc = "< Number of changes to partition ID."]
    pub mPartitionIdChanges: u16,
    #[doc = "< Number of attempts to attach to a better partition."]
    pub mBetterPartitionAttachAttempts: u16,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role."]
    pub mChildTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderTime: u64,
    #[doc = "< Number of milliseconds tracked by previous counters."]
    pub mTrackedTime: u64,
    #[doc = " Number of times device changed its parent."]
    #[doc = ""]
    #[doc = " A parent change can happen if device detaches from its current parent and attaches to a different one, or even"]
    #[doc = " while device is attached when the periodic parent search feature is enabled  (please see option"]
    #[doc = " OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE)."]
    #[doc = ""]
    pub mParentChanges: u16,
}
#[doc = " This structure represents the MLE Parent Response data."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadParentResponseInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the Parent"]
    pub mExtAddr: otExtAddress,
    #[doc = "< Short address of the Parent"]
    pub mRloc16: u16,
    #[doc = "< Rssi of the Parent"]
    pub mRssi: i8,
    #[doc = "< Parent priority"]
    pub mPriority: i8,
    #[doc = "< Parent Link Quality 3"]
    pub mLinkQuality3: u8,
    #[doc = "< Parent Link Quality 2"]
    pub mLinkQuality2: u8,
    #[doc = "< Parent Link Quality 1"]
    pub mLinkQuality1: u8,
    #[doc = "< Is the node receiving parent response attached"]
    pub mIsAttached: bool,
}
#[doc = " This callback informs the application that the detaching process has finished."]
#[doc = ""]
#[doc = " @param[in] aContext A pointer to application-specific context."]
#[doc = ""]
pub type otDetachGracefullyCallback =
    ::core::option::Option<unsafe extern "C" fn(aContext: *mut crate::c_types::c_void)>;
extern "C" {
    #[doc = " This function starts Thread protocol operation."]
    #[doc = ""]
    #[doc = " The interface must be up when calling this function."]
    #[doc = ""]
    #[doc = " Calling this function with @p aEnabled set to FALSE stops any ongoing processes of detaching started by"]
    #[doc = " otThreadDetachGracefully(). Its callback will be called."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE if Thread is enabled, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started Thread protocol operation."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The network interface was not not up."]
    #[doc = ""]
    pub fn otThreadSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the Thread protocol version."]
    #[doc = ""]
    #[doc = " @returns the Thread protocol version."]
    #[doc = ""]
    pub fn otThreadGetVersion() -> u16;
}
extern "C" {
    #[doc = " This function indicates whether a node is the only router on the network."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   It is the only router in the network."]
    #[doc = " @retval FALSE  It is a child or is not a single router in the network."]
    #[doc = ""]
    pub fn otThreadIsSingleton(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function starts a Thread Discovery scan."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance              A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels          A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK)."]
    #[doc = " @param[in]  aPanId                 The PAN ID filter (set to Broadcast PAN to disable filter)."]
    #[doc = " @param[in]  aJoiner                Value of the Joiner Flag in the Discovery Request TLV."]
    #[doc = " @param[in]  aEnableEui64Filtering  TRUE to filter responses on EUI-64, FALSE otherwise."]
    #[doc = " @param[in]  aCallback              A pointer to a function called on receiving an MLE Discovery Response or"]
    #[doc = "                                    scan completes."]
    #[doc = " @param[in]  aCallbackContext       A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started a Thread Discovery Scan."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The IPv6 interface is not enabled (netif is not up)."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Could not allocate message for Discovery Request."]
    #[doc = " @retval OT_ERROR_BUSY           Thread Discovery Scan is already in progress."]
    #[doc = ""]
    pub fn otThreadDiscover(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aPanId: u16,
        aJoiner: bool,
        aEnableEui64Filtering: bool,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function determines if an MLE Thread Discovery is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadIsDiscoverInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method sets the Thread Joiner Advertisement when discovering Thread network."]
    #[doc = ""]
    #[doc = " Thread Joiner Advertisement is used to allow a Joiner to advertise its own application-specific information"]
    #[doc = " (such as Vendor ID, Product ID, Discriminator, etc.) via a newly-proposed Joiner Advertisement TLV,"]
    #[doc = " and to make this information available to Commissioners or Commissioner Candidates without human interaction."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aOui             The Vendor IEEE OUI value that will be included in the Joiner Advertisement. Only the"]
    #[doc = "                              least significant 3 bytes will be used, and the most significant byte will be ignored."]
    #[doc = " @param[in]  aAdvData         A pointer to the AdvData that will be included in the Joiner Advertisement."]
    #[doc = " @param[in]  aAdvDataLength   The length of AdvData in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully set Joiner Advertisement."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS Invalid AdvData."]
    #[doc = ""]
    pub fn otThreadSetJoinerAdvertisement(
        aInstance: *mut otInstance,
        aOui: u32,
        aAdvData: *const u8,
        aAdvDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Child Timeout (in seconds) used when operating in the Child role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Thread Child Timeout value in seconds."]
    #[doc = ""]
    #[doc = " @sa otThreadSetChildTimeout"]
    #[doc = ""]
    pub fn otThreadGetChildTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the Thread Child Timeout (in seconds) used when operating in the Child role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout  The timeout value in seconds."]
    #[doc = ""]
    #[doc = " @sa otThreadGetChildTimeout"]
    #[doc = ""]
    pub fn otThreadSetChildTimeout(aInstance: *mut otInstance, aTimeout: u32);
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @sa otThreadSetExtendedPanId"]
    #[doc = ""]
    pub fn otThreadGetExtendedPanId(aInstance: *mut otInstance) -> *const otExtendedPanId;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @note Can only be called while Thread protocols are disabled. A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtendedPanId  A pointer to the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Extended PAN ID."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetExtendedPanId"]
    #[doc = ""]
    pub fn otThreadSetExtendedPanId(
        aInstance: *mut otInstance,
        aExtendedPanId: *const otExtendedPanId,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns a pointer to the Leader's RLOC."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLeaderRloc  A pointer to the Leader's RLOC."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The Leader's RLOC was successfully written to @p aLeaderRloc."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aLeaderRloc was NULL."]
    #[doc = " @retval OT_ERROR_DETACHED      Not currently attached to a Thread Partition."]
    #[doc = ""]
    pub fn otThreadGetLeaderRloc(
        aInstance: *mut otInstance,
        aLeaderRloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @sa otThreadSetLinkMode"]
    #[doc = ""]
    pub fn otThreadGetLinkMode(aInstance: *mut otInstance) -> otLinkModeConfig;
}
extern "C" {
    #[doc = " Set the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig   A pointer to the Link Mode configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully set the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @sa otThreadGetLinkMode"]
    #[doc = ""]
    pub fn otThreadSetLinkMode(aInstance: *mut otInstance, aConfig: otLinkModeConfig) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Key."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNetworkKey   A pointer to an `otNetworkkey` to return the Thread Network Key."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkKey"]
    #[doc = ""]
    pub fn otThreadGetNetworkKey(aInstance: *mut otInstance, aNetworkKey: *mut otNetworkKey);
}
extern "C" {
    #[doc = " Get the `otNetworkKeyRef` for Thread Network Key."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns Reference to the Thread Network Key stored in memory."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkKeyRef"]
    #[doc = ""]
    pub fn otThreadGetNetworkKeyRef(aInstance: *mut otInstance) -> otNetworkKeyRef;
}
extern "C" {
    #[doc = " Set the Thread Network Key."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKey        A pointer to a buffer containing the Thread Network Key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Thread Network Key."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkKey"]
    #[doc = ""]
    pub fn otThreadSetNetworkKey(aInstance: *mut otInstance, aKey: *const otNetworkKey) -> otError;
}
extern "C" {
    #[doc = " Set the Thread Network Key as a `otNetworkKeyRef`."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeyRef     Reference to the Thread Network Key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Thread Network Key."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkKeyRef"]
    #[doc = ""]
    pub fn otThreadSetNetworkKeyRef(
        aInstance: *mut otInstance,
        aKeyRef: otNetworkKeyRef,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Routing Locator (RLOC) address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Routing Locator (RLOC) address."]
    #[doc = ""]
    pub fn otThreadGetRloc(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Mesh Local EID address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Mesh Local EID address."]
    #[doc = ""]
    pub fn otThreadGetMeshLocalEid(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function returns a pointer to the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Mesh Local Prefix."]
    #[doc = ""]
    pub fn otThreadGetMeshLocalPrefix(aInstance: *mut otInstance) -> *const otMeshLocalPrefix;
}
extern "C" {
    #[doc = " This function sets the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMeshLocalPrefix  A pointer to the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Mesh Local Prefix."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otThreadSetMeshLocalPrefix(
        aInstance: *mut otInstance,
        aMeshLocalPrefix: *const otMeshLocalPrefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread link-local IPv6 address."]
    #[doc = ""]
    #[doc = " The Thread link local address is derived using IEEE802.15.4 Extended Address as Interface Identifier."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread link-local IPv6 address."]
    #[doc = ""]
    pub fn otThreadGetLinkLocalIp6Address(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Link-Local All Thread Nodes multicast address."]
    #[doc = ""]
    #[doc = " The address is a link-local Unicast Prefix-Based Multicast Address [RFC 3306], with:"]
    #[doc = "   - flgs set to 3 (P = 1 and T = 1)"]
    #[doc = "   - scop set to 2"]
    #[doc = "   - plen set to 64"]
    #[doc = "   - network prefix set to the Mesh Local Prefix"]
    #[doc = "   - group ID set to 1"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread Link-Local All Thread Nodes multicast address."]
    #[doc = ""]
    pub fn otThreadGetLinkLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Realm-Local All Thread Nodes multicast address."]
    #[doc = ""]
    #[doc = " The address is a realm-local Unicast Prefix-Based Multicast Address [RFC 3306], with:"]
    #[doc = "   - flgs set to 3 (P = 1 and T = 1)"]
    #[doc = "   - scop set to 3"]
    #[doc = "   - plen set to 64"]
    #[doc = "   - network prefix set to the Mesh Local Prefix"]
    #[doc = "   - group ID set to 1"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread Realm-Local All Thread Nodes multicast address."]
    #[doc = ""]
    pub fn otThreadGetRealmLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function retrieves the Service ALOC for given Service ID."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aServiceId    Service ID to get ALOC for."]
    #[doc = " @param[out]  aServiceAloc  A pointer to output the Service ALOC. MUST NOT BE NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully retrieved the Service ALOC."]
    #[doc = " @retval OT_ERROR_DETACHED  The Thread interface is not currently attached to a Thread Partition."]
    pub fn otThreadGetServiceAloc(
        aInstance: *mut otInstance,
        aServiceId: u8,
        aServiceAloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Name."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Network Name."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkName"]
    #[doc = ""]
    pub fn otThreadGetNetworkName(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Set the Thread Network Name."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aNetworkName  A pointer to the Thread Network Name."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread Network Name."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkName"]
    #[doc = ""]
    pub fn otThreadSetNetworkName(
        aInstance: *mut otInstance,
        aNetworkName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @note Available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @sa otThreadSetDomainName"]
    #[doc = ""]
    pub fn otThreadGetDomainName(aInstance: *mut otInstance) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " Sets the Thread Domain Name. Only succeeds when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @note Available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDomainName   A pointer to the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread Domain Name."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetDomainName"]
    #[doc = ""]
    pub fn otThreadSetDomainName(
        aInstance: *mut otInstance,
        aDomainName: *const crate::c_types::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or clears the Interface Identifier manually specified for the Thread Domain Unicast Address."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note Only available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aIid        A pointer to the Interface Identifier to set or NULL to clear."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set/cleared the Interface Identifier."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The specified Interface Identifier is reserved."]
    #[doc = ""]
    #[doc = " @sa otThreadGetFixedDuaInterfaceIdentifier"]
    pub fn otThreadSetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Interface Identifier manually specified for the Thread Domain Unicast Address."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note Only available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Interface Identifier which was set manually, or NULL if none was set."]
    #[doc = ""]
    #[doc = " @sa otThreadSetFixedDuaInterfaceIdentifier"]
    #[doc = ""]
    pub fn otThreadGetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
    ) -> *const otIp6InterfaceIdentifier;
}
extern "C" {
    #[doc = " Gets the thrKeySequenceCounter."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The thrKeySequenceCounter value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetKeySequenceCounter"]
    #[doc = ""]
    pub fn otThreadGetKeySequenceCounter(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySequenceCounter."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeySequenceCounter  The thrKeySequenceCounter value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetKeySequenceCounter"]
    #[doc = ""]
    pub fn otThreadSetKeySequenceCounter(aInstance: *mut otInstance, aKeySequenceCounter: u32);
}
extern "C" {
    #[doc = " Gets the thrKeySwitchGuardTime (in hours)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The thrKeySwitchGuardTime value (in hours)."]
    #[doc = ""]
    #[doc = " @sa otThreadSetKeySwitchGuardTime"]
    #[doc = ""]
    pub fn otThreadGetKeySwitchGuardTime(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySwitchGuardTime (in hours)."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeySwitchGuardTime  The thrKeySwitchGuardTime value (in hours)."]
    #[doc = ""]
    #[doc = " @sa otThreadGetKeySwitchGuardTime"]
    #[doc = ""]
    pub fn otThreadSetKeySwitchGuardTime(aInstance: *mut otInstance, aKeySwitchGuardTime: u32);
}
extern "C" {
    #[doc = " Detach from the Thread network."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully detached from the Thread network."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    #[doc = ""]
    pub fn otThreadBecomeDetached(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Attempt to reattach as a child."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully begin attempt to become a child."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    #[doc = ""]
    pub fn otThreadBecomeChild(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the next neighbor information. It is used to go through the entries of"]
    #[doc = " the neighbor table."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the iterator context. To get the first neighbor entry"]
    #[doc = "it should be set to OT_NEIGHBOR_INFO_ITERATOR_INIT."]
    #[doc = " @param[out]     aInfo      A pointer to the neighbor information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully found the next neighbor entry in table."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent neighbor entry exists in the table."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aInfo was NULL."]
    #[doc = ""]
    pub fn otThreadGetNextNeighborInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNeighborInfoIterator,
        aInfo: *mut otNeighborInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the device role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_DEVICE_ROLE_DISABLED  The Thread stack is disabled."]
    #[doc = " @retval OT_DEVICE_ROLE_DETACHED  The device is not currently participating in a Thread network/partition."]
    #[doc = " @retval OT_DEVICE_ROLE_CHILD     The device is currently operating as a Thread Child."]
    #[doc = " @retval OT_DEVICE_ROLE_ROUTER    The device is currently operating as a Thread Router."]
    #[doc = " @retval OT_DEVICE_ROLE_LEADER    The device is currently operating as a Thread Leader."]
    #[doc = ""]
    pub fn otThreadGetDeviceRole(aInstance: *mut otInstance) -> otDeviceRole;
}
extern "C" {
    #[doc = " Convert the device role to human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aRole   The device role to convert."]
    #[doc = ""]
    #[doc = " @returns A string representing @p aRole."]
    #[doc = ""]
    pub fn otThreadDeviceRoleToString(aRole: otDeviceRole) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " This function get the Thread Leader Data."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLeaderData  A pointer to where the leader data is placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the leader data."]
    #[doc = " @retval OT_ERROR_DETACHED      Not currently attached."]
    #[doc = ""]
    pub fn otThreadGetLeaderData(
        aInstance: *mut otInstance,
        aLeaderData: *mut otLeaderData,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Leader's Router ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Leader's Router ID."]
    #[doc = ""]
    pub fn otThreadGetLeaderRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Leader's Weight."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Leader's Weight."]
    #[doc = ""]
    pub fn otThreadGetLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Partition ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Partition ID."]
    #[doc = ""]
    pub fn otThreadGetPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get the RLOC16."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The RLOC16."]
    #[doc = ""]
    pub fn otThreadGetRloc16(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " The function retrieves diagnostic information for a Thread Router as parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aParentInfo  A pointer to where the parent router information is placed."]
    #[doc = ""]
    pub fn otThreadGetParentInfo(
        aInstance: *mut otInstance,
        aParentInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the average RSSI for the Thread Parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aParentRssi  A pointer to where the parent RSSI should be placed."]
    #[doc = ""]
    pub fn otThreadGetParentAverageRssi(
        aInstance: *mut otInstance,
        aParentRssi: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the RSSI of the last packet from the Thread Parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLastRssi    A pointer to where the last RSSI should be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the RSSI data."]
    #[doc = " @retval OT_ERROR_FAILED        Unable to get RSSI data."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aLastRssi is NULL."]
    #[doc = ""]
    pub fn otThreadGetParentLastRssi(aInstance: *mut otInstance, aLastRssi: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Starts the process for child to search for a better parent while staying attached to its current parent."]
    #[doc = ""]
    #[doc = " Must be used when device is attached as a child."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started the process to search for a better parent."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device role is not child."]
    #[doc = ""]
    pub fn otThreadSearchForBetterParent(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the IPv6 counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IPv6 counters."]
    #[doc = ""]
    pub fn otThreadGetIp6Counters(aInstance: *mut otInstance) -> *const otIpCounters;
}
extern "C" {
    #[doc = " Resets the IPv6 counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadResetIp6Counters(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Thread MLE counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread MLE counters."]
    #[doc = ""]
    pub fn otThreadGetMleCounters(aInstance: *mut otInstance) -> *const otMleCounters;
}
extern "C" {
    #[doc = " Resets the Thread MLE counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadResetMleCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called every time an MLE Parent Response message is received."]
#[doc = ""]
#[doc = " @param[in]  aInfo     A pointer to a location on stack holding the stats data."]
#[doc = " @param[in]  aContext  A pointer to callback client-specific context."]
#[doc = ""]
pub type otThreadParentResponseCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *mut otThreadParentResponseInfo,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to receive MLE Parent Response data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Parent Response message."]
    #[doc = " @param[in]  aContext   A pointer to callback client-specific context."]
    #[doc = ""]
    pub fn otThreadRegisterParentResponseCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadParentResponseCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
#[doc = " This structure represents the Thread Discovery Request data."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadDiscoveryRequestInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the requester"]
    pub mExtAddress: otExtAddress,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otThreadDiscoveryRequestInfo {
    #[inline]
    pub fn mVersion(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoiner(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoiner(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mVersion: u8, mIsJoiner: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u8 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsJoiner: u8 = unsafe { ::core::mem::transmute(mIsJoiner) };
            mIsJoiner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called every time an MLE Discovery Request message is received."]
#[doc = ""]
#[doc = " @param[in]  aInfo     A pointer to the Discovery Request info data."]
#[doc = " @param[in]  aContext  A pointer to callback application-specific context."]
#[doc = ""]
pub type otThreadDiscoveryRequestCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *const otThreadDiscoveryRequestInfo,
        aContext: *mut crate::c_types::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sets a callback to receive MLE Discovery Request data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Discovery Request message."]
    #[doc = " @param[in]  aContext   A pointer to callback application-specific context."]
    #[doc = ""]
    pub fn otThreadSetDiscoveryRequestCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadDiscoveryRequestCallback,
        aContext: *mut crate::c_types::c_void,
    );
}
#[doc = " This function pointer type defines the callback to notify the outcome of a `otThreadLocateAnycastDestination()`"]
#[doc = " request."]
#[doc = ""]
#[doc = " @param[in] aContext            A pointer to an arbitrary context (provided when callback is registered)."]
#[doc = " @param[in] aError              The error when handling the request. OT_ERROR_NONE indicates success."]
#[doc = "                                OT_ERROR_RESPONSE_TIMEOUT indicates a destination could not be found."]
#[doc = "                                OT_ERROR_ABORT indicates the request was aborted."]
#[doc = " @param[in] aMeshLocalAddress   A pointer to the mesh-local EID of the closest destination of the anycast address"]
#[doc = "                                when @p aError is OT_ERROR_NONE, NULL otherwise."]
#[doc = " @param[in] aRloc16             The RLOC16 of the destination if found, otherwise invalid RLOC16 (0xfffe)."]
#[doc = ""]
pub type otThreadAnycastLocatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut crate::c_types::c_void,
        aError: otError,
        aMeshLocalAddress: *const otIp6Address,
        aRloc16: u16,
    ),
>;
extern "C" {
    #[doc = " This function requests the closest destination of a given anycast address to be located."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " If a previous request is ongoing, a subsequent call to this function will cancel and replace the earlier request."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in] aAnycastAddress   The anycast address to locate. MUST NOT be NULL."]
    #[doc = " @param[in] aCallback         The callback function to report the result."]
    #[doc = " @param[in] aContext          An arbitrary context used with @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The request started successfully. @p aCallback will be invoked to report the result."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The @p aAnycastAddress is not a valid anycast address or @p aCallback is NULL."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Out of buffer to prepare and send the request message."]
    #[doc = ""]
    pub fn otThreadLocateAnycastDestination(
        aInstance: *mut otInstance,
        aAnycastAddress: *const otIp6Address,
        aCallback: otThreadAnycastLocatorCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether an anycast locate request is currently in progress."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if an anycast locate request is currently in progress, FALSE otherwise."]
    #[doc = ""]
    pub fn otThreadIsAnycastLocateInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sends a Proactive Address Notification (ADDR_NTF.ntf) message."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDestination  The destination to send the ADDR_NTF.ntf message."]
    #[doc = " @param[in]  aTarget       The target address of the ADDR_NTF.ntf message."]
    #[doc = " @param[in]  aMlIid        The ML-IID of the ADDR_NTF.ntf message."]
    #[doc = ""]
    pub fn otThreadSendAddressNotification(
        aInstance: *mut otInstance,
        aDestination: *mut otIp6Address,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
    );
}
extern "C" {
    #[doc = " This function sends a Proactive Backbone Notification (PRO_BB.ntf) message on the Backbone link."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance                    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTarget                      The target address of the PRO_BB.ntf message."]
    #[doc = " @param[in]  aMlIid                       The ML-IID of the PRO_BB.ntf message."]
    #[doc = " @param[in]  aTimeSinceLastTransaction    Time since last transaction (in seconds)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent PRO_BB.ntf on backbone link."]
    #[doc = " @retval OT_ERROR_NO_BUFS        If insufficient message buffers available."]
    #[doc = ""]
    pub fn otThreadSendProactiveBackboneNotification(
        aInstance: *mut otInstance,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
        aTimeSinceLastTransaction: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function notifies other nodes in the network (if any) and then stops Thread protocol operation."]
    #[doc = ""]
    #[doc = " It sends an Address Release if it's a router, or sets its child timeout to 0 if it's a child."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback A pointer to a function that is called upon finishing detaching."]
    #[doc = " @param[in] aContext  A pointer to callback application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE Successfully started detaching."]
    #[doc = " @retval OT_ERROR_BUSY Detaching is already in progress."]
    #[doc = ""]
    pub fn otThreadDetachGracefully(
        aInstance: *mut otInstance,
        aCallback: otDetachGracefullyCallback,
        aContext: *mut crate::c_types::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Run all queued OpenThread tasklets at the time this is called."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otTaskletsProcess(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates whether or not OpenThread has tasklets pending."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   If there are tasklets pending."]
    #[doc = " @retval FALSE  If there are no tasklets pending."]
    #[doc = ""]
    pub fn otTaskletsArePending(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " OpenThread calls this function when the tasklet queue transitions from empty to non-empty."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otTaskletsSignalPending(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt milliseconds after @p aT0."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aT0        The reference time."]
    #[doc = " @param[in] aDt        The time delay in milliseconds from @p aT0."]
    pub fn otPlatAlarmMilliStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time."]
    #[doc = ""]
    #[doc = " @returns The current time in milliseconds."]
    pub fn otPlatAlarmMilliGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Signal diagnostics module that the alarm has fired."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatDiagAlarmFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function performs a software reset on the platform, if supported."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatReset(aInstance: *mut otInstance);
}
pub const otPlatResetReason_OT_PLAT_RESET_REASON_POWER_ON: otPlatResetReason = 0;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_EXTERNAL: otPlatResetReason = 1;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_SOFTWARE: otPlatResetReason = 2;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_FAULT: otPlatResetReason = 3;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_CRASH: otPlatResetReason = 4;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_ASSERT: otPlatResetReason = 5;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_OTHER: otPlatResetReason = 6;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_UNKNOWN: otPlatResetReason = 7;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_WATCHDOG: otPlatResetReason = 8;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_COUNT: otPlatResetReason = 9;
#[doc = " Enumeration of possible reset reason codes."]
#[doc = ""]
#[doc = " These are in the same order as the Spinel reset reason codes."]
#[doc = ""]
pub type otPlatResetReason = crate::c_types::c_uint;
extern "C" {
    #[doc = " This function returns the reason for the last platform reset."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatGetResetReason(aInstance: *mut otInstance) -> otPlatResetReason;
}
extern "C" {
    #[doc = " This function provides a platform specific implementation for assert."]
    #[doc = ""]
    #[doc = " @param[in] aFilename    The name of the file where the assert occurred."]
    #[doc = " @param[in] aLineNumber  The line number in the file where the assert occurred."]
    #[doc = ""]
    pub fn otPlatAssertFail(
        aFilename: *const crate::c_types::c_char,
        aLineNumber: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " This function performs a platform specific operation to wake the host MCU."]
    #[doc = " This is used only for NCP configurations."]
    #[doc = ""]
    pub fn otPlatWakeHost();
}
#[doc = " NCP's MCU stays on and active all the time."]
#[doc = ""]
#[doc = " When the NCP's desired power state is set to `ON`, host can send messages to NCP without requiring any \"poke\" or"]
#[doc = " external triggers."]
#[doc = ""]
#[doc = " @note The `ON` power state only determines the MCU's power mode and is not related to radio's state."]
#[doc = ""]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_ON: otPlatMcuPowerState = 0;
#[doc = " NCP's MCU can enter low-power (energy-saving) state."]
#[doc = ""]
#[doc = " When the NCP's desired power state is set to `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external"]
#[doc = " trigger like an interrupt) before it can communicate with the NCP (send a message to the NCP). The \"poke\""]
#[doc = " mechanism is determined by the platform code (based on NCP's interface to the host)."]
#[doc = ""]
#[doc = " While power state is set to `LOW_POWER`, NCP can still (at any time) send messages to host. Note that receiving"]
#[doc = " a message from the NCP does NOT indicate that the NCP's power state has changed, i.e., host is expected to"]
#[doc = " continue to \"poke\" when it wants to talk to the NCP until the power state is explicitly changed (by a successful"]
#[doc = " call to `otPlatSetMcuPowerState()` changing the state to `ON`)."]
#[doc = ""]
#[doc = " @note The `LOW_POWER` power state only determines the MCU's power mode and is not related to radio's state"]
#[doc = " (radio is managed by OpenThread core and device role, e.g., device being sleepy or not."]
#[doc = ""]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_LOW_POWER: otPlatMcuPowerState = 1;
#[doc = " NCP is fully off."]
#[doc = ""]
#[doc = " An NCP hardware reset (via a RESET pin) is required to bring the NCP back to `SPINEL_MCU_POWER_STATE_ON`."]
#[doc = " RAM is not retained after reset."]
#[doc = ""]
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_OFF: otPlatMcuPowerState = 2;
#[doc = " Enumeration of micro-controller's power states."]
#[doc = ""]
#[doc = " These values are used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL` is enabled."]
#[doc = ""]
#[doc = " The power state specifies the desired power state of NCP's micro-controller (MCU) when the underlying platform's"]
#[doc = " operating system enters idle mode (i.e., all active tasks/events are processed and the MCU can potentially enter a"]
#[doc = " energy-saving power state)."]
#[doc = ""]
#[doc = " The power state primarily determines how the host should interact with the NCP and whether the host needs an"]
#[doc = " external trigger (a \"poke\") to NCP before it can communicate with the NCP or not."]
#[doc = ""]
#[doc = " After a reset, the MCU power state MUST be `OT_PLAT_POWER_STATE_ON`."]
#[doc = ""]
pub type otPlatMcuPowerState = crate::c_types::c_uint;
extern "C" {
    #[doc = " This function sets the desired MCU power state."]
    #[doc = ""]
    #[doc = " This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      A pointer to OpenThread instance."]
    #[doc = " @param[in] aState         The new MCU power state."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     The power state updated successfully."]
    #[doc = " @retval OT_ERROR_FAILED   The given MCU power state is not supported by the platform."]
    #[doc = ""]
    pub fn otPlatSetMcuPowerState(
        aInstance: *mut otInstance,
        aState: otPlatMcuPowerState,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the current desired MCU power state."]
    #[doc = ""]
    #[doc = " This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " After a reset, the power state MUST return `OT_PLAT_POWER_STATE_ON`. During operation, power state SHOULD only"]
    #[doc = " change through an explicit successful call to `otPlatSetMcuPowerState()`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current power state."]
    #[doc = ""]
    pub fn otPlatGetMcuPowerState(aInstance: *mut otInstance) -> otPlatMcuPowerState;
}
extern "C" {
    #[doc = " Fill buffer with entropy."]
    #[doc = ""]
    #[doc = " This function MUST be implemented using a true random number generator (TRNG)."]
    #[doc = ""]
    #[doc = " @param[out]  aOutput              A pointer to where the true random values are placed.  Must not be NULL."]
    #[doc = " @param[in]   aOutputLength        Size of @p aBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully filled @p aBuffer with true random values."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to fill @p aBuffer with true random values."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aBuffer was set to NULL."]
    #[doc = ""]
    pub fn otPlatEntropyGet(aOutput: *mut u8, aOutputLength: u16) -> otError;
}
#[doc = "< Active Operational Dataset."]
pub const OT_SETTINGS_KEY_ACTIVE_DATASET: crate::c_types::c_uint = 1;
#[doc = "< Pending Operational Dataset."]
pub const OT_SETTINGS_KEY_PENDING_DATASET: crate::c_types::c_uint = 2;
#[doc = "< Thread network information."]
pub const OT_SETTINGS_KEY_NETWORK_INFO: crate::c_types::c_uint = 3;
#[doc = "< Parent information."]
pub const OT_SETTINGS_KEY_PARENT_INFO: crate::c_types::c_uint = 4;
#[doc = "< Child information."]
pub const OT_SETTINGS_KEY_CHILD_INFO: crate::c_types::c_uint = 5;
#[doc = "< SLAAC key to generate semantically opaque IID."]
pub const OT_SETTINGS_KEY_SLAAC_IID_SECRET_KEY: crate::c_types::c_uint = 7;
#[doc = "< Duplicate Address Detection (DAD) information."]
pub const OT_SETTINGS_KEY_DAD_INFO: crate::c_types::c_uint = 8;
#[doc = "< SRP client ECDSA public/private key pair."]
pub const OT_SETTINGS_KEY_SRP_ECDSA_KEY: crate::c_types::c_uint = 11;
#[doc = "< The SRP client info (selected SRP server address)."]
pub const OT_SETTINGS_KEY_SRP_CLIENT_INFO: crate::c_types::c_uint = 12;
#[doc = "< The SRP server info (UDP port)."]
pub const OT_SETTINGS_KEY_SRP_SERVER_INFO: crate::c_types::c_uint = 13;
#[doc = "< BR ULA prefix."]
pub const OT_SETTINGS_KEY_BR_ULA_PREFIX: crate::c_types::c_uint = 15;
#[doc = "< BR local on-link prefixes."]
pub const OT_SETTINGS_KEY_BR_ON_LINK_PREFIXES: crate::c_types::c_uint = 16;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MIN: crate::c_types::c_uint = 32768;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MAX: crate::c_types::c_uint = 65535;
#[doc = " This enumeration defines the keys of settings."]
#[doc = ""]
#[doc = " Note: When adding a new settings key, if the settings corresponding to the key contains security sensitive"]
#[doc = "       information, the developer MUST add the key to the array `aSensitiveKeys` which is passed in"]
#[doc = "       `otPlatSettingsInit()`."]
#[doc = ""]
pub type _bindgen_ty_11 = crate::c_types::c_uint;
extern "C" {
    #[doc = " Performs any initialization for the settings subsystem, if necessary."]
    #[doc = ""]
    #[doc = " This function also sets the sensitive keys that should be stored in the secure area."]
    #[doc = ""]
    #[doc = " Note that the memory pointed by @p aSensitiveKeys MUST not be released before @p aInstance is destroyed."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             The OpenThread instance structure."]
    #[doc = " @param[in]  aSensitiveKeys        A pointer to an array containing the list of sensitive keys. May be NULL only if"]
    #[doc = "                                   @p aSensitiveKeysLength is 0, which means that there is no sensitive keys."]
    #[doc = " @param[in]  aSensitiveKeysLength  The number of entries in the @p aSensitiveKeys array."]
    #[doc = ""]
    pub fn otPlatSettingsInit(
        aInstance: *mut otInstance,
        aSensitiveKeys: *const u16,
        aSensitiveKeysLength: u16,
    );
}
extern "C" {
    #[doc = " Performs any de-initialization for the settings subsystem, if necessary."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatSettingsDeinit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Fetches the value of a setting."]
    #[doc = ""]
    #[doc = " This function fetches the value of the setting identified"]
    #[doc = " by @p aKey and write it to the memory pointed to by aValue."]
    #[doc = " It then writes the length to the integer pointed to by"]
    #[doc = " @p aValueLength. The initial value of @p aValueLength is the"]
    #[doc = " maximum number of bytes to be written to @p aValue."]
    #[doc = ""]
    #[doc = " This function can be used to check for the existence of"]
    #[doc = " a key without fetching the value by setting @p aValue and"]
    #[doc = " @p aValueLength to NULL. You can also check the length of"]
    #[doc = " the setting without fetching it by setting only aValue"]
    #[doc = " to NULL."]
    #[doc = ""]
    #[doc = " Note that the underlying storage implementation is not"]
    #[doc = " required to maintain the order of settings with multiple"]
    #[doc = " values. The order of such values MAY change after ANY"]
    #[doc = " write operation to the store."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]      aKey          The key associated with the requested setting."]
    #[doc = " @param[in]      aIndex        The index of the specific item to get."]
    #[doc = " @param[out]     aValue        A pointer to where the value of the setting should be written. May be set to NULL if"]
    #[doc = "                               just testing for the presence or length of a setting."]
    #[doc = " @param[in,out]  aValueLength  A pointer to the length of the value. When called, this pointer should point to an"]
    #[doc = "                               integer containing the maximum value size that can be written to @p aValue. At return,"]
    #[doc = "                               the actual length of the setting is written. This may be set to NULL if performing"]
    #[doc = "                               a presence check."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was found and fetched successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        The given setting was not found in the setting store."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsGet(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: crate::c_types::c_int,
        aValue: *mut u8,
        aValueLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or replaces the value of a setting."]
    #[doc = ""]
    #[doc = " This function sets or replaces the value of a setting"]
    #[doc = " identified by @p aKey."]
    #[doc = ""]
    #[doc = " Calling this function successfully may cause unrelated"]
    #[doc = " settings with multiple values to be reordered."]
    #[doc = ""]
    #[doc = " OpenThread stack guarantees to use `otPlatSettingsSet()`"]
    #[doc = " method for a @p aKey that was either previously set using"]
    #[doc = " `otPlatSettingsSet()` (i.e., contains a single value) or"]
    #[doc = " is empty and/or fully deleted (contains no value)."]
    #[doc = ""]
    #[doc = " Platform layer can rely and use this fact for optimizing"]
    #[doc = " its implementation."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aKey          The key associated with the setting to change."]
    #[doc = " @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL if"]
    #[doc = "                           @p aValueLength is non-zero."]
    #[doc = " @param[in]  aValueLength  The length of the data pointed to by aValue. May be zero."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was changed or staged."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsSet(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a value to a setting."]
    #[doc = ""]
    #[doc = " This function adds the value to a setting"]
    #[doc = " identified by @p aKey, without replacing any existing"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " Note that the underlying implementation is not required"]
    #[doc = " to maintain the order of the items associated with a"]
    #[doc = " specific key. The added value may be added to the end,"]
    #[doc = " the beginning, or even somewhere in the middle. The order"]
    #[doc = " of any pre-existing values may also change."]
    #[doc = ""]
    #[doc = " Calling this function successfully may cause unrelated"]
    #[doc = " settings with multiple values to be reordered."]
    #[doc = ""]
    #[doc = " OpenThread stack guarantees to use `otPlatSettingsAdd()`"]
    #[doc = " method for a @p aKey that was either previously managed by"]
    #[doc = " `otPlatSettingsAdd()` (i.e., contains one or more items) or"]
    #[doc = " is empty and/or fully deleted (contains no value)."]
    #[doc = ""]
    #[doc = " Platform layer can rely and use this fact for optimizing"]
    #[doc = " its implementation."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aKey          The key associated with the setting to change."]
    #[doc = " @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL"]
    #[doc = "                           if @p aValueLength is non-zero."]
    #[doc = " @param[in]  aValueLength  The length of the data pointed to by @p aValue. May be zero."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was added or staged to be added."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsAdd(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a setting from the setting store."]
    #[doc = ""]
    #[doc = " This function deletes a specific value from the"]
    #[doc = " setting identified by aKey from the settings store."]
    #[doc = ""]
    #[doc = " Note that the underlying implementation is not required"]
    #[doc = " to maintain the order of the items associated with a"]
    #[doc = " specific key."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aKey       The key associated with the requested setting."]
    #[doc = " @param[in] aIndex     The index of the value to be removed. If set to -1, all values for this @p aKey will be"]
    #[doc = "                       removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given key and index was found and removed successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        The given key or index was not found in the setting store."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsDelete(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: crate::c_types::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes all settings from the setting store."]
    #[doc = ""]
    #[doc = " This function deletes all settings from the settings"]
    #[doc = " store, resetting it to its initial factory state."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatSettingsWipe(aInstance: *mut otInstance);
}
pub type __builtin_va_list = *mut crate::c_types::c_void;
