/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const OT_LOG_LEVEL_NONE: u32 = 0;
pub const OT_LOG_LEVEL_CRIT: u32 = 1;
pub const OT_LOG_LEVEL_WARN: u32 = 2;
pub const OT_LOG_LEVEL_NOTE: u32 = 3;
pub const OT_LOG_LEVEL_INFO: u32 = 4;
pub const OT_LOG_LEVEL_DEBG: u32 = 5;
pub const OPENTHREAD_API_VERSION: u32 = 450;
pub const OT_UPTIME_STRING_SIZE: u32 = 24;
pub const OT_CHANGED_IP6_ADDRESS_ADDED: u32 = 1;
pub const OT_CHANGED_IP6_ADDRESS_REMOVED: u32 = 2;
pub const OT_CHANGED_THREAD_ROLE: u32 = 4;
pub const OT_CHANGED_THREAD_LL_ADDR: u32 = 8;
pub const OT_CHANGED_THREAD_ML_ADDR: u32 = 16;
pub const OT_CHANGED_THREAD_RLOC_ADDED: u32 = 32;
pub const OT_CHANGED_THREAD_RLOC_REMOVED: u32 = 64;
pub const OT_CHANGED_THREAD_PARTITION_ID: u32 = 128;
pub const OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER: u32 = 256;
pub const OT_CHANGED_THREAD_NETDATA: u32 = 512;
pub const OT_CHANGED_THREAD_CHILD_ADDED: u32 = 1024;
pub const OT_CHANGED_THREAD_CHILD_REMOVED: u32 = 2048;
pub const OT_CHANGED_IP6_MULTICAST_SUBSCRIBED: u32 = 4096;
pub const OT_CHANGED_IP6_MULTICAST_UNSUBSCRIBED: u32 = 8192;
pub const OT_CHANGED_THREAD_CHANNEL: u32 = 16384;
pub const OT_CHANGED_THREAD_PANID: u32 = 32768;
pub const OT_CHANGED_THREAD_NETWORK_NAME: u32 = 65536;
pub const OT_CHANGED_THREAD_EXT_PANID: u32 = 131072;
pub const OT_CHANGED_NETWORK_KEY: u32 = 262144;
pub const OT_CHANGED_PSKC: u32 = 524288;
pub const OT_CHANGED_SECURITY_POLICY: u32 = 1048576;
pub const OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL: u32 = 2097152;
pub const OT_CHANGED_SUPPORTED_CHANNEL_MASK: u32 = 4194304;
pub const OT_CHANGED_COMMISSIONER_STATE: u32 = 8388608;
pub const OT_CHANGED_THREAD_NETIF_STATE: u32 = 16777216;
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE: u32 = 33554432;
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_LOCAL: u32 = 67108864;
pub const OT_CHANGED_JOINER_STATE: u32 = 134217728;
pub const OT_CHANGED_ACTIVE_DATASET: u32 = 268435456;
pub const OT_CHANGED_PENDING_DATASET: u32 = 536870912;
pub const OT_CHANGED_NAT64_TRANSLATOR_STATE: u32 = 1073741824;
pub const OT_CHANGED_PARENT_LINK_QUALITY: u32 = 2147483648;
pub const OT_CRYPTO_SHA256_HASH_SIZE: u32 = 32;
pub const OT_CRYPTO_ECDSA_MAX_DER_SIZE: u32 = 125;
pub const OT_CRYPTO_ECDSA_PUBLIC_KEY_SIZE: u32 = 64;
pub const OT_CRYPTO_ECDSA_SIGNATURE_SIZE: u32 = 64;
pub const OT_CRYPTO_PBDKF2_MAX_SALT_SIZE: u32 = 30;
pub const OT_PANID_BROADCAST: u32 = 65535;
pub const OT_EXT_ADDRESS_SIZE: u32 = 8;
pub const CSL_IE_HEADER_BYTES_LO: u32 = 4;
pub const CSL_IE_HEADER_BYTES_HI: u32 = 13;
pub const OT_MAC_KEY_SIZE: u32 = 16;
pub const OT_IP6_PREFIX_SIZE: u32 = 8;
pub const OT_IP6_PREFIX_BITSIZE: u32 = 64;
pub const OT_IP6_IID_SIZE: u32 = 8;
pub const OT_IP6_ADDRESS_SIZE: u32 = 16;
pub const OT_IP6_ADDRESS_BITSIZE: u32 = 128;
pub const OT_IP6_HEADER_SIZE: u32 = 40;
pub const OT_IP6_HEADER_PROTO_OFFSET: u32 = 6;
pub const OT_IP6_ADDRESS_STRING_SIZE: u32 = 40;
pub const OT_IP6_SOCK_ADDR_STRING_SIZE: u32 = 48;
pub const OT_IP6_PREFIX_STRING_SIZE: u32 = 45;
pub const OT_IP6_MAX_MLR_ADDRESSES: u32 = 15;
pub const OT_NETWORK_KEY_SIZE: u32 = 16;
pub const OT_NETWORK_NAME_MAX_SIZE: u32 = 16;
pub const OT_EXT_PAN_ID_SIZE: u32 = 8;
pub const OT_MESH_LOCAL_PREFIX_SIZE: u32 = 8;
pub const OT_PSKC_MAX_SIZE: u32 = 16;
pub const OT_CHANNEL_1_MASK: u32 = 2;
pub const OT_CHANNEL_2_MASK: u32 = 4;
pub const OT_CHANNEL_3_MASK: u32 = 8;
pub const OT_CHANNEL_4_MASK: u32 = 16;
pub const OT_CHANNEL_5_MASK: u32 = 32;
pub const OT_CHANNEL_6_MASK: u32 = 64;
pub const OT_CHANNEL_7_MASK: u32 = 128;
pub const OT_CHANNEL_8_MASK: u32 = 256;
pub const OT_CHANNEL_9_MASK: u32 = 512;
pub const OT_CHANNEL_10_MASK: u32 = 1024;
pub const OT_CHANNEL_11_MASK: u32 = 2048;
pub const OT_CHANNEL_12_MASK: u32 = 4096;
pub const OT_CHANNEL_13_MASK: u32 = 8192;
pub const OT_CHANNEL_14_MASK: u32 = 16384;
pub const OT_CHANNEL_15_MASK: u32 = 32768;
pub const OT_CHANNEL_16_MASK: u32 = 65536;
pub const OT_CHANNEL_17_MASK: u32 = 131072;
pub const OT_CHANNEL_18_MASK: u32 = 262144;
pub const OT_CHANNEL_19_MASK: u32 = 524288;
pub const OT_CHANNEL_20_MASK: u32 = 1048576;
pub const OT_CHANNEL_21_MASK: u32 = 2097152;
pub const OT_CHANNEL_22_MASK: u32 = 4194304;
pub const OT_CHANNEL_23_MASK: u32 = 8388608;
pub const OT_CHANNEL_24_MASK: u32 = 16777216;
pub const OT_CHANNEL_25_MASK: u32 = 33554432;
pub const OT_CHANNEL_26_MASK: u32 = 67108864;
pub const OT_OPERATIONAL_DATASET_MAX_LENGTH: u32 = 254;
pub const OT_JOINER_MAX_DISCERNER_LENGTH: u32 = 64;
pub const OT_COMMISSIONING_PASSPHRASE_MIN_SIZE: u32 = 6;
pub const OT_COMMISSIONING_PASSPHRASE_MAX_SIZE: u32 = 255;
pub const OT_PROVISIONING_URL_MAX_SIZE: u32 = 64;
pub const OT_STEERING_DATA_MAX_LENGTH: u32 = 16;
pub const OT_JOINER_MAX_PSKD_LENGTH: u32 = 32;
pub const OT_MAC_FILTER_FIXED_RSS_DISABLED: u32 = 127;
pub const OT_MAC_FILTER_ITERATOR_INIT: u32 = 0;
pub const OT_LINK_CSL_PERIOD_TEN_SYMBOLS_UNIT_IN_USEC: u32 = 160;
pub const OT_THREAD_VERSION_INVALID: u32 = 0;
pub const OT_THREAD_VERSION_1_1: u32 = 2;
pub const OT_THREAD_VERSION_1_2: u32 = 3;
pub const OT_THREAD_VERSION_1_3: u32 = 4;
pub const OT_THREAD_VERSION_1_3_1: u32 = 5;
pub const OT_THREAD_VERSION_1_4: u32 = 5;
pub const OT_NETWORK_BASE_TLV_MAX_LENGTH: u32 = 254;
pub const OT_NETWORK_MAX_ROUTER_ID: u32 = 62;
pub const OT_NEIGHBOR_INFO_ITERATOR_INIT: u32 = 0;
pub const OT_JOINER_ADVDATA_MAX_LENGTH: u32 = 64;
pub const OT_DURATION_STRING_SIZE: u32 = 21;
pub const OT_DNS_MAX_NAME_SIZE: u32 = 255;
pub const OT_DNS_MAX_LABEL_SIZE: u32 = 64;
pub const OT_DNS_TXT_KEY_MIN_LENGTH: u32 = 1;
pub const OT_DNS_TXT_KEY_MAX_LENGTH: u32 = 9;
pub const OT_DNS_TXT_KEY_ITER_MAX_LENGTH: u32 = 64;
pub const OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE: u32 = 1;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type wint_t = ::core::ffi::c_uint;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
unsafe extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
pub type __FILE = __sFILE;
unsafe extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
unsafe extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
    pub _rand_next: ::core::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: *mut ::core::ffi::c_char,
    pub _reserved_0: ::core::ffi::c_int,
    pub _reserved_1: ::core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::core::ffi::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub _reserved_6: *mut _atexit,
    pub _reserved_7: _atexit,
    pub _reserved_8: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::core::ffi::c_char,
}
unsafe extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
unsafe extern "C" {
    pub static mut _impure_data: _reent;
}
unsafe extern "C" {
    pub fn __getreent() -> *mut _reent;
}
unsafe extern "C" {
    pub static mut __atexit: *mut _atexit;
}
unsafe extern "C" {
    pub static mut __atexit0: _atexit;
}
unsafe extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
unsafe extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
unsafe extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    pub fn __locale_mb_cur_max() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
unsafe extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoff(__nptr: *const ::core::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[must_use]
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn getenv(__string: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _findenv(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
unsafe extern "C" {
    #[must_use]
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn mblen(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mkdtemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(arg1: *mut ::core::ffi::c_char, arg2: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[must_use]
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[must_use]
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[must_use]
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn realpath(
        path: *const ::core::ffi::c_char,
        resolved_path: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn rpmatch(response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn strtod(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f64;
}
unsafe extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn system(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn a64l(__input: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn l64a(__input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn setenv(
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn __utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
unsafe extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
unsafe extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::core::ffi::c_long);
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn setstate(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn strtoll(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn unsetenv(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[must_use]
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __eprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
        arg4: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
unsafe extern "C" {
    #[must_use]
    pub fn aligned_alloc(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int) -> !;
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
/// No error.
pub const otError_OT_ERROR_NONE: otError = 0;
/// Operational failed.
pub const otError_OT_ERROR_FAILED: otError = 1;
/// Message was dropped.
pub const otError_OT_ERROR_DROP: otError = 2;
/// Insufficient buffers.
pub const otError_OT_ERROR_NO_BUFS: otError = 3;
/// No route available.
pub const otError_OT_ERROR_NO_ROUTE: otError = 4;
/// Service is busy and could not service the operation.
pub const otError_OT_ERROR_BUSY: otError = 5;
/// Failed to parse message.
pub const otError_OT_ERROR_PARSE: otError = 6;
/// Input arguments are invalid.
pub const otError_OT_ERROR_INVALID_ARGS: otError = 7;
/// Security checks failed.
pub const otError_OT_ERROR_SECURITY: otError = 8;
/// Address resolution requires an address query operation.
pub const otError_OT_ERROR_ADDRESS_QUERY: otError = 9;
/// Address is not in the source match table.
pub const otError_OT_ERROR_NO_ADDRESS: otError = 10;
/// Operation was aborted.
pub const otError_OT_ERROR_ABORT: otError = 11;
/// Function or method is not implemented.
pub const otError_OT_ERROR_NOT_IMPLEMENTED: otError = 12;
/// Cannot complete due to invalid state.
pub const otError_OT_ERROR_INVALID_STATE: otError = 13;
/// No acknowledgment was received after macMaxFrameRetries (IEEE 802.15.4-2006).
pub const otError_OT_ERROR_NO_ACK: otError = 14;
/// A transmission could not take place due to activity on the channel, i.e., the CSMA-CA mechanism has failed
/// (IEEE 802.15.4-2006).
pub const otError_OT_ERROR_CHANNEL_ACCESS_FAILURE: otError = 15;
/// Not currently attached to a Thread Partition.
pub const otError_OT_ERROR_DETACHED: otError = 16;
/// FCS check failure while receiving.
pub const otError_OT_ERROR_FCS: otError = 17;
/// No frame received.
pub const otError_OT_ERROR_NO_FRAME_RECEIVED: otError = 18;
/// Received a frame from an unknown neighbor.
pub const otError_OT_ERROR_UNKNOWN_NEIGHBOR: otError = 19;
/// Received a frame from an invalid source address.
pub const otError_OT_ERROR_INVALID_SOURCE_ADDRESS: otError = 20;
/// Received a frame filtered by the address filter (allowlisted or denylisted).
pub const otError_OT_ERROR_ADDRESS_FILTERED: otError = 21;
/// Received a frame filtered by the destination address check.
pub const otError_OT_ERROR_DESTINATION_ADDRESS_FILTERED: otError = 22;
/// The requested item could not be found.
pub const otError_OT_ERROR_NOT_FOUND: otError = 23;
/// The operation is already in progress.
pub const otError_OT_ERROR_ALREADY: otError = 24;
/// The creation of IPv6 address failed.
pub const otError_OT_ERROR_IP6_ADDRESS_CREATION_FAILURE: otError = 26;
/// Operation prevented by mode flags
pub const otError_OT_ERROR_NOT_CAPABLE: otError = 27;
/// Coap response or acknowledgment or DNS, SNTP response not received.
pub const otError_OT_ERROR_RESPONSE_TIMEOUT: otError = 28;
/// Received a duplicated frame.
pub const otError_OT_ERROR_DUPLICATED: otError = 29;
/// Message is being dropped from reassembly list due to timeout.
pub const otError_OT_ERROR_REASSEMBLY_TIMEOUT: otError = 30;
/// Message is not a TMF Message.
pub const otError_OT_ERROR_NOT_TMF: otError = 31;
/// Received a non-lowpan data frame.
pub const otError_OT_ERROR_NOT_LOWPAN_DATA_FRAME: otError = 32;
/// The link margin was too low.
pub const otError_OT_ERROR_LINK_MARGIN_LOW: otError = 34;
/// Input (CLI) command is invalid.
pub const otError_OT_ERROR_INVALID_COMMAND: otError = 35;
/// Special error code used to indicate success/error status is pending and not yet known.
pub const otError_OT_ERROR_PENDING: otError = 36;
/// Request rejected.
pub const otError_OT_ERROR_REJECTED: otError = 37;
/// The number of defined errors.
pub const otError_OT_NUM_ERRORS: otError = 38;
/// Generic error (should not use).
pub const otError_OT_ERROR_GENERIC: otError = 255;
/// Represents error codes used throughout OpenThread.
pub type otError = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Converts an otError enum into a string.
    ///
    /// @param[in]  aError     An otError enum.
    ///
    /// @returns  A string representation of an otError.
    pub fn otThreadErrorToString(aError: otError) -> *const ::core::ffi::c_char;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
/// Represents the log level.
pub type otLogLevel = ::core::ffi::c_int;
///< OpenThread API
pub const otLogRegion_OT_LOG_REGION_API: otLogRegion = 1;
///< MLE
pub const otLogRegion_OT_LOG_REGION_MLE: otLogRegion = 2;
///< EID-to-RLOC mapping.
pub const otLogRegion_OT_LOG_REGION_ARP: otLogRegion = 3;
///< Network Data
pub const otLogRegion_OT_LOG_REGION_NET_DATA: otLogRegion = 4;
///< ICMPv6
pub const otLogRegion_OT_LOG_REGION_ICMP: otLogRegion = 5;
///< IPv6
pub const otLogRegion_OT_LOG_REGION_IP6: otLogRegion = 6;
///< TCP
pub const otLogRegion_OT_LOG_REGION_TCP: otLogRegion = 7;
///< IEEE 802.15.4 MAC
pub const otLogRegion_OT_LOG_REGION_MAC: otLogRegion = 8;
///< Memory
pub const otLogRegion_OT_LOG_REGION_MEM: otLogRegion = 9;
///< NCP
pub const otLogRegion_OT_LOG_REGION_NCP: otLogRegion = 10;
///< Mesh Commissioning Protocol
pub const otLogRegion_OT_LOG_REGION_MESH_COP: otLogRegion = 11;
///< Network Diagnostic
pub const otLogRegion_OT_LOG_REGION_NET_DIAG: otLogRegion = 12;
///< Platform
pub const otLogRegion_OT_LOG_REGION_PLATFORM: otLogRegion = 13;
///< CoAP
pub const otLogRegion_OT_LOG_REGION_COAP: otLogRegion = 14;
///< CLI
pub const otLogRegion_OT_LOG_REGION_CLI: otLogRegion = 15;
///< OpenThread Core
pub const otLogRegion_OT_LOG_REGION_CORE: otLogRegion = 16;
///< Utility module
pub const otLogRegion_OT_LOG_REGION_UTIL: otLogRegion = 17;
///< Backbone Router (available since Thread 1.2)
pub const otLogRegion_OT_LOG_REGION_BBR: otLogRegion = 18;
///< Multicast Listener Registration (available since Thread 1.2)
pub const otLogRegion_OT_LOG_REGION_MLR: otLogRegion = 19;
///< Domain Unicast Address (available since Thread 1.2)
pub const otLogRegion_OT_LOG_REGION_DUA: otLogRegion = 20;
///< Border Router
pub const otLogRegion_OT_LOG_REGION_BR: otLogRegion = 21;
///< Service Registration Protocol (SRP)
pub const otLogRegion_OT_LOG_REGION_SRP: otLogRegion = 22;
///< DNS
pub const otLogRegion_OT_LOG_REGION_DNS: otLogRegion = 23;
/// Represents log regions.
///
/// The support for log region is removed and instead each core module can define its own name to appended to the logs.
/// However, the `otLogRegion` enumeration is still defined as before to help with platforms which we may be using it
/// in their `otPlatLog()` implementation. The OT core will always emit all logs with `OT_LOG_REGION_CORE`.
pub type otLogRegion = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Outputs logs.
    ///
    /// Note that the support for log region is removed. The OT core will always emit all logs with `OT_LOG_REGION_CORE`
    /// as @p aLogRegion.
    ///
    /// @param[in]  aLogLevel   The log level.
    /// @param[in]  aLogRegion  The log region.
    /// @param[in]  aFormat     A pointer to the format string.
    /// @param[in]  ...         Arguments for the format specification.
    pub fn otPlatLog(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::core::ffi::c_char,
        ...
    );
}
unsafe extern "C" {
    /// Handles OpenThread log level changes.
    ///
    /// This platform function is called whenever the OpenThread log level changes.
    /// This platform function is optional since an empty weak implementation has been provided.
    ///
    /// @note Only applicable when `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`.
    ///
    /// @param[in]  aLogLevel  The new OpenThread log level.
    pub fn otPlatLogHandleLevelChanged(aLogLevel: otLogLevel);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otInstance {
    _unused: [u8; 0],
}
unsafe extern "C" {
    /// Initializes the OpenThread library.
    ///
    /// Initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be
    /// called before any other calls to OpenThread.
    ///
    /// Is available and can only be used when support for multiple OpenThread instances is enabled.
    ///
    /// @param[in]     aInstanceBuffer      The buffer for OpenThread to use for allocating the otInstance structure.
    /// @param[in,out] aInstanceBufferSize  On input, the size of aInstanceBuffer. On output, if not enough space for
    ///                                     otInstance, the number of bytes required for otInstance.
    ///
    /// @returns  A pointer to the new OpenThread instance.
    ///
    /// @sa otInstanceFinalize
    pub fn otInstanceInit(
        aInstanceBuffer: *mut ::core::ffi::c_void,
        aInstanceBufferSize: *mut usize,
    ) -> *mut otInstance;
}
unsafe extern "C" {
    /// Initializes the static single instance of the OpenThread library.
    ///
    /// Initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be
    /// called before any other calls to OpenThread.
    ///
    /// Is available and can only be used when support for multiple OpenThread instances is disabled.
    ///
    /// @returns A pointer to the single OpenThread instance.
    pub fn otInstanceInitSingle() -> *mut otInstance;
}
unsafe extern "C" {
    /// Initializes the OpenThread instance.
    ///
    /// This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be
    /// called before any other calls to OpenThread. This method utilizes static buffer to initialize the OpenThread
    /// instance.
    ///
    /// This function is available and can only be used when support for multiple OpenThread static instances is
    /// enabled (`OPENTHREAD_CONFIG_MULTIPLE_STATIC_INSTANCE_ENABLE`)
    ///
    /// @param[in] aIdx The index of the OpenThread instance to initialize.
    ///
    /// @returns  A pointer to the new OpenThread instance.
    pub fn otInstanceInitMultiple(aIdx: u8) -> *mut otInstance;
}
unsafe extern "C" {
    /// Gets the instance identifier.
    ///
    /// The instance identifier is set to a random value when the instance is constructed, and then its value will not
    /// change after initialization.
    ///
    /// @returns The instance identifier.
    pub fn otInstanceGetId(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Indicates whether or not the instance is valid/initialized.
    ///
    /// The instance is considered valid if it is acquired and initialized using either `otInstanceInitSingle()` (in single
    /// instance case) or `otInstanceInit()` (in multi instance case). A subsequent call to `otInstanceFinalize()` causes
    /// the instance to be considered as uninitialized.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns TRUE if the given instance is valid/initialized, FALSE otherwise.
    pub fn otInstanceIsInitialized(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Disables the OpenThread library.
    ///
    /// Call this function when OpenThread is no longer in use.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    pub fn otInstanceFinalize(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Returns the current instance uptime (in msec).
    ///
    /// Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.
    ///
    /// The uptime is given as number of milliseconds since OpenThread instance was initialized.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The uptime (number of milliseconds).
    pub fn otInstanceGetUptime(aInstance: *mut otInstance) -> u64;
}
unsafe extern "C" {
    /// Returns the current instance uptime as a human-readable string.
    ///
    /// Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.
    ///
    /// The string follows the format "<hh>:<mm>:<ss>.<mmmm>" for hours, minutes, seconds and millisecond (if uptime is
    /// shorter than one day) or "<dd>d.<hh>:<mm>:<ss>.<mmmm>" (if longer than a day).
    ///
    /// If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated
    /// but the outputted string is always null-terminated.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[out] aBuffer   A pointer to a char array to output the string.
    /// @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_UPTIME_STRING_SIZE`.
    pub fn otInstanceGetUptimeAsString(
        aInstance: *mut otInstance,
        aBuffer: *mut ::core::ffi::c_char,
        aSize: u16,
    );
}
/// Represents a bit-field indicating specific state/configuration that has changed. See `OT_CHANGED_*`
/// definitions.
pub type otChangedFlags = u32;
/// Pointer is called to notify certain configuration or state changes within OpenThread.
///
/// @param[in]  aFlags    A bit-field indicating specific state that has changed.  See `OT_CHANGED_*` definitions.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otStateChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(aFlags: otChangedFlags, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Registers a callback to indicate when certain configuration or state changes within OpenThread.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aCallback  A pointer to a function that is called with certain configuration or state changes.
    /// @param[in]  aContext   A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE     Added the callback to the list of callbacks.
    /// @retval OT_ERROR_ALREADY  The callback was already registered.
    /// @retval OT_ERROR_NO_BUFS  Could not add the callback due to resource constraints.
    pub fn otSetStateChangedCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a callback to indicate when certain configuration or state changes within OpenThread.
    ///
    /// @param[in]  aInstance   A pointer to an OpenThread instance.
    /// @param[in]  aCallback   A pointer to a function that is called with certain configuration or state changes.
    /// @param[in]  aContext    A pointer to application-specific context.
    pub fn otRemoveStateChangeCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Triggers a platform reset.
    ///
    /// The reset process ensures that all the OpenThread state/info (stored in volatile memory) is erased. Note that the
    /// `otPlatformReset` does not erase any persistent state/info saved in non-volatile memory.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otInstanceReset(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Triggers a platform reset to bootloader mode, if supported.
    ///
    /// Requires `OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE`.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE         Reset to bootloader successfully.
    /// @retval OT_ERROR_BUSY         Failed due to another operation is ongoing.
    /// @retval OT_ERROR_NOT_CAPABLE  Not capable of resetting to bootloader.
    pub fn otInstanceResetToBootloader(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Deletes all the settings stored on non-volatile memory, and then triggers a platform reset.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otInstanceFactoryReset(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Resets the internal states of the OpenThread radio stack.
    ///
    /// Callbacks and configurations are preserved.
    ///
    /// This API is only available under radio builds (`OPENTHREAD_RADIO = 1`).
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otInstanceResetRadioStack(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Erases all the OpenThread persistent info (network settings) stored on non-volatile memory.
    /// Erase is successful only if the device is in `disabled` state/role.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE           All persistent info/state was erased successfully.
    /// @retval OT_ERROR_INVALID_STATE  Device is not in `disabled` state/role.
    pub fn otInstanceErasePersistentInfo(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Gets the OpenThread version string.
    ///
    /// @returns A pointer to the OpenThread version.
    pub fn otGetVersionString() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Gets the OpenThread radio version string.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the OpenThread radio version.
    pub fn otGetRadioVersionString(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessage {
    _unused: [u8; 0],
}
///< Low priority level.
pub const otMessagePriority_OT_MESSAGE_PRIORITY_LOW: otMessagePriority = 0;
///< Normal priority level.
pub const otMessagePriority_OT_MESSAGE_PRIORITY_NORMAL: otMessagePriority = 1;
///< High priority level.
pub const otMessagePriority_OT_MESSAGE_PRIORITY_HIGH: otMessagePriority = 2;
/// Defines the OpenThread message priority levels.
pub type otMessagePriority = ::core::ffi::c_uint;
///< Message from Thread Netif.
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_THREAD_NETIF: otMessageOrigin = 0;
///< Message from a trusted source on host.
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_HOST_TRUSTED: otMessageOrigin = 1;
///< Message from an untrusted source on host.
pub const otMessageOrigin_OT_MESSAGE_ORIGIN_HOST_UNTRUSTED: otMessageOrigin = 2;
/// Defines the OpenThread message origins.
pub type otMessageOrigin = ::core::ffi::c_uint;
/// Represents a message settings.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageSettings {
    ///< TRUE if the message should be secured at Layer 2.
    pub mLinkSecurityEnabled: bool,
    ///< Priority level (MUST be a `OT_MESSAGE_PRIORITY_*` from `otMessagePriority`).
    pub mPriority: u8,
}
/// Represents link-specific information for messages received from the Thread radio.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadLinkInfo {
    ///< Source PAN ID
    pub mPanId: u16,
    ///< 802.15.4 Channel
    pub mChannel: u8,
    ///< Received Signal Strength in dBm (averaged over fragments)
    pub mRss: i8,
    ///< Average Link Quality Indicator (averaged over fragments)
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    ///< The time sync sequence.
    pub mTimeSyncSeq: u8,
    ///< The time offset to the Thread network time, in microseconds.
    pub mNetworkTimeOffset: i64,
    ///< Radio link type.
    pub mRadioType: u8,
}
impl otThreadLinkInfo {
    #[inline]
    pub fn mLinkSecurity(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkSecurity(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mLinkSecurity_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mLinkSecurity_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsDstPanIdBroadcast(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDstPanIdBroadcast(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsDstPanIdBroadcast_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsDstPanIdBroadcast_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkSecurity: bool,
        mIsDstPanIdBroadcast: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mLinkSecurity: u8 = unsafe { ::core::mem::transmute(mLinkSecurity) };
            mLinkSecurity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsDstPanIdBroadcast: u8 = unsafe { ::core::mem::transmute(mIsDstPanIdBroadcast) };
            mIsDstPanIdBroadcast as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    /// Free an allocated message buffer.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    pub fn otMessageFree(aMessage: *mut otMessage);
}
unsafe extern "C" {
    /// Get the message length in bytes.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @returns The message length in bytes.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    /// @sa otMessageSetLength
    pub fn otMessageGetLength(aMessage: *const otMessage) -> u16;
}
unsafe extern "C" {
    /// Set the message length in bytes.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aLength   A length in bytes.
    ///
    /// @retval OT_ERROR_NONE     Successfully set the message length.
    /// @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    pub fn otMessageSetLength(aMessage: *mut otMessage, aLength: u16) -> otError;
}
unsafe extern "C" {
    /// Get the message offset in bytes.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @returns The message offset value.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    pub fn otMessageGetOffset(aMessage: *const otMessage) -> u16;
}
unsafe extern "C" {
    /// Set the message offset in bytes.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aOffset   An offset in bytes.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    pub fn otMessageSetOffset(aMessage: *mut otMessage, aOffset: u16);
}
unsafe extern "C" {
    /// Indicates whether or not link security is enabled for the message.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @retval TRUE   If link security is enabled.
    /// @retval FALSE  If link security is not enabled.
    pub fn otMessageIsLinkSecurityEnabled(aMessage: *const otMessage) -> bool;
}
unsafe extern "C" {
    /// Indicates whether or not the message is allowed to be looped back to host.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @retval TRUE   If the message is allowed to be looped back to host.
    /// @retval FALSE  If the message is not allowed to be looped back to host.
    pub fn otMessageIsLoopbackToHostAllowed(aMessage: *const otMessage) -> bool;
}
unsafe extern "C" {
    /// Sets whether or not the message is allowed to be looped back to host.
    ///
    /// @param[in]  aMessage              A pointer to a message buffer.
    /// @param[in]  aAllowLoopbackToHost  Whether to allow the message to be looped back to host.
    pub fn otMessageSetLoopbackToHostAllowed(aMessage: *mut otMessage, aAllowLoopbackToHost: bool);
}
unsafe extern "C" {
    /// Indicates whether the given message may be looped back in a case of a multicast destination address.
    ///
    /// If @p aMessage is used along with an `otMessageInfo`, the `mMulticastLoop` field from `otMessageInfo` structure
    /// takes precedence and will be used instead of the the value set on @p aMessage.
    ///
    /// This API is mainly intended for use along with `otIp6Send()` which expects an already prepared IPv6 message.
    ///
    /// @param[in]  aMessage A pointer to the message.
    pub fn otMessageIsMulticastLoopEnabled(aMessage: *mut otMessage) -> bool;
}
unsafe extern "C" {
    /// Controls whether the given message may be looped back in a case of a multicast destination address.
    ///
    /// @param[in]  aMessage  A pointer to the message.
    /// @param[in]  aEnabled  The configuration value.
    pub fn otMessageSetMulticastLoopEnabled(aMessage: *mut otMessage, aEnabled: bool);
}
unsafe extern "C" {
    /// Gets the message origin.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @returns The message origin.
    pub fn otMessageGetOrigin(aMessage: *const otMessage) -> otMessageOrigin;
}
unsafe extern "C" {
    /// Sets the message origin.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aOrigin   The message origin.
    pub fn otMessageSetOrigin(aMessage: *mut otMessage, aOrigin: otMessageOrigin);
}
unsafe extern "C" {
    /// Sets/forces the message to be forwarded using direct transmission.
    /// Default setting for a new message is `false`.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aEnabled  If `true`, the message is forced to use direct transmission. If `false`, the message follows
    ///                       the normal procedure.
    pub fn otMessageSetDirectTransmission(aMessage: *mut otMessage, aEnabled: bool);
}
unsafe extern "C" {
    /// Returns the average RSS (received signal strength) associated with the message.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    ///
    /// @returns The average RSS value (in dBm) or OT_RADIO_RSSI_INVALID if no average RSS is available.
    pub fn otMessageGetRss(aMessage: *const otMessage) -> i8;
}
unsafe extern "C" {
    /// Retrieves the link-specific information for a message received over Thread radio.
    ///
    /// @param[in] aMessage    The message from which to retrieve `otThreadLinkInfo`.
    /// @pram[out] aLinkInfo   A pointer to an `otThreadLinkInfo` to populate.
    ///
    /// @retval OT_ERROR_NONE       Successfully retrieved the link info, @p `aLinkInfo` is updated.
    /// @retval OT_ERROR_NOT_FOUND  Message origin is not `OT_MESSAGE_ORIGIN_THREAD_NETIF`.
    pub fn otMessageGetThreadLinkInfo(
        aMessage: *const otMessage,
        aLinkInfo: *mut otThreadLinkInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// Append bytes to a message.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aBuf      A pointer to the data to append.
    /// @param[in]  aLength   Number of bytes to append.
    ///
    /// @retval OT_ERROR_NONE     Successfully appended to the message
    /// @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.
    ///
    /// @sa otMessageFree
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    /// @sa otMessageWrite
    pub fn otMessageAppend(
        aMessage: *mut otMessage,
        aBuf: *const ::core::ffi::c_void,
        aLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Read bytes from a message.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aOffset   An offset in bytes.
    /// @param[in]  aBuf      A pointer to a buffer that message bytes are read to.
    /// @param[in]  aLength   Number of bytes to read.
    ///
    /// @returns The number of bytes read.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageWrite
    pub fn otMessageRead(
        aMessage: *const otMessage,
        aOffset: u16,
        aBuf: *mut ::core::ffi::c_void,
        aLength: u16,
    ) -> u16;
}
unsafe extern "C" {
    /// Write bytes to a message.
    ///
    /// @param[in]  aMessage  A pointer to a message buffer.
    /// @param[in]  aOffset   An offset in bytes.
    /// @param[in]  aBuf      A pointer to a buffer that message bytes are written from.
    /// @param[in]  aLength   Number of bytes to write.
    ///
    /// @returns The number of bytes written.
    ///
    /// @sa otMessageFree
    /// @sa otMessageAppend
    /// @sa otMessageGetLength
    /// @sa otMessageSetLength
    /// @sa otMessageGetOffset
    /// @sa otMessageSetOffset
    /// @sa otMessageRead
    pub fn otMessageWrite(
        aMessage: *mut otMessage,
        aOffset: u16,
        aBuf: *const ::core::ffi::c_void,
        aLength: u16,
    ) -> ::core::ffi::c_int;
}
/// Represents an OpenThread message queue.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageQueue {
    ///< Opaque data used by the implementation.
    pub mData: *mut ::core::ffi::c_void,
}
/// Represents information about a message queue.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageQueueInfo {
    ///< Number of messages in the queue.
    pub mNumMessages: u16,
    ///< Number of data buffers used by messages in the queue.
    pub mNumBuffers: u16,
    ///< Total number of bytes used by all messages in the queue.
    pub mTotalBytes: u32,
}
/// Represents the message buffer information for different queues used by OpenThread stack.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBufferInfo {
    ///< The total number of buffers in the messages pool (0xffff if unknown).
    pub mTotalBuffers: u16,
    ///< The number of free buffers (0xffff if unknown).
    pub mFreeBuffers: u16,
    /// The maximum number of used buffers at the same time since OT stack initialization or last call to
    /// `otMessageResetBufferInfo()`.
    pub mMaxUsedBuffers: u16,
    ///< Info about 6LoWPAN send queue.
    pub m6loSendQueue: otMessageQueueInfo,
    ///< Info about 6LoWPAN reassembly queue.
    pub m6loReassemblyQueue: otMessageQueueInfo,
    ///< Info about IPv6 send queue.
    pub mIp6Queue: otMessageQueueInfo,
    ///< Info about MPL send queue.
    pub mMplQueue: otMessageQueueInfo,
    ///< Info about MLE delayed message queue.
    pub mMleQueue: otMessageQueueInfo,
    ///< Info about CoAP/TMF send queue.
    pub mCoapQueue: otMessageQueueInfo,
    ///< Info about CoAP secure send queue.
    pub mCoapSecureQueue: otMessageQueueInfo,
    ///< Info about application CoAP send queue.
    pub mApplicationCoapQueue: otMessageQueueInfo,
}
unsafe extern "C" {
    /// Initialize the message queue.
    ///
    /// MUST be called once and only once for a `otMessageQueue` instance before any other `otMessageQueue`
    /// functions. The behavior is undefined if other queue APIs are used with an `otMessageQueue` before it being
    /// initialized or if it is initialized more than once.
    ///
    /// @param[in]  aQueue     A pointer to a message queue.
    pub fn otMessageQueueInit(aQueue: *mut otMessageQueue);
}
unsafe extern "C" {
    /// Adds a message to the end of the given message queue.
    ///
    /// @param[in]  aQueue    A pointer to the message queue.
    /// @param[in]  aMessage  The message to add.
    pub fn otMessageQueueEnqueue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
unsafe extern "C" {
    /// Adds a message at the head/front of the given message queue.
    ///
    /// @param[in]  aQueue    A pointer to the message queue.
    /// @param[in]  aMessage  The message to add.
    pub fn otMessageQueueEnqueueAtHead(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
unsafe extern "C" {
    /// Removes a message from the given message queue.
    ///
    /// @param[in]  aQueue    A pointer to the message queue.
    /// @param[in]  aMessage  The message to remove.
    pub fn otMessageQueueDequeue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
unsafe extern "C" {
    /// Returns a pointer to the message at the head of the queue.
    ///
    /// @param[in]  aQueue    A pointer to a message queue.
    ///
    /// @returns  A pointer to the message at the head of queue or NULL if queue is empty.
    pub fn otMessageQueueGetHead(aQueue: *mut otMessageQueue) -> *mut otMessage;
}
unsafe extern "C" {
    /// Returns a pointer to the next message in the queue by iterating forward (from head to tail).
    ///
    /// @param[in]  aQueue    A pointer to a message queue.
    /// @param[in]  aMessage  A pointer to current message buffer.
    ///
    /// @returns  A pointer to the next message in the queue after `aMessage` or NULL if `aMessage is the tail of queue.
    ///           NULL is returned if `aMessage` is not in the queue `aQueue`.
    pub fn otMessageQueueGetNext(
        aQueue: *mut otMessageQueue,
        aMessage: *const otMessage,
    ) -> *mut otMessage;
}
unsafe extern "C" {
    /// Get the Message Buffer information.
    ///
    /// @param[in]   aInstance    A pointer to the OpenThread instance.
    /// @param[out]  aBufferInfo  A pointer where the message buffer information is written.
    pub fn otMessageGetBufferInfo(aInstance: *mut otInstance, aBufferInfo: *mut otBufferInfo);
}
unsafe extern "C" {
    /// Reset the Message Buffer information counter tracking the maximum number buffers in use at the same time.
    ///
    /// This resets `mMaxUsedBuffers` in `otBufferInfo`.
    ///
    /// @param[in]   aInstance    A pointer to the OpenThread instance.
    pub fn otMessageResetBufferInfo(aInstance: *mut otInstance);
}
///< Key Type: Raw Data.
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_RAW: otCryptoKeyType = 0;
///< Key Type: AES.
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_AES: otCryptoKeyType = 1;
///< Key Type: HMAC.
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_HMAC: otCryptoKeyType = 2;
///< Key Type: ECDSA.
pub const otCryptoKeyType_OT_CRYPTO_KEY_TYPE_ECDSA: otCryptoKeyType = 3;
/// Defines the key types.
pub type otCryptoKeyType = ::core::ffi::c_uint;
///< Key Algorithm: Vendor Defined.
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_VENDOR: otCryptoKeyAlgorithm = 0;
///< Key Algorithm: AES ECB.
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_AES_ECB: otCryptoKeyAlgorithm = 1;
///< Key Algorithm: HMAC SHA-256.
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_HMAC_SHA_256: otCryptoKeyAlgorithm = 2;
///< Key Algorithm: ECDSA.
pub const otCryptoKeyAlgorithm_OT_CRYPTO_KEY_ALG_ECDSA: otCryptoKeyAlgorithm = 3;
/// Defines the key algorithms.
pub type otCryptoKeyAlgorithm = ::core::ffi::c_uint;
///< Key Usage: Key Usage is empty.
pub const OT_CRYPTO_KEY_USAGE_NONE: _bindgen_ty_1 = 0;
///< Key Usage: Key can be exported.
pub const OT_CRYPTO_KEY_USAGE_EXPORT: _bindgen_ty_1 = 1;
///< Key Usage: Encryption (vendor defined).
pub const OT_CRYPTO_KEY_USAGE_ENCRYPT: _bindgen_ty_1 = 2;
///< Key Usage: AES ECB.
pub const OT_CRYPTO_KEY_USAGE_DECRYPT: _bindgen_ty_1 = 4;
///< Key Usage: Sign Hash.
pub const OT_CRYPTO_KEY_USAGE_SIGN_HASH: _bindgen_ty_1 = 8;
///< Key Usage: Verify Hash.
pub const OT_CRYPTO_KEY_USAGE_VERIFY_HASH: _bindgen_ty_1 = 16;
/// Defines the key usage flags.
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
///< Key Persistence: Key is volatile.
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_VOLATILE: otCryptoKeyStorage = 0;
///< Key Persistence: Key is persistent.
pub const otCryptoKeyStorage_OT_CRYPTO_KEY_STORAGE_PERSISTENT: otCryptoKeyStorage = 1;
/// Defines the key storage types.
pub type otCryptoKeyStorage = ::core::ffi::c_uint;
/// This datatype represents the key reference.
pub type otCryptoKeyRef = u32;
/// @struct otCryptoKey
///
/// Represents the Key Material required for Crypto operations.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCryptoKey {
    ///< Pointer to the buffer containing key. NULL indicates to use `mKeyRef`.
    pub mKey: *const u8,
    ///< The key length in bytes (applicable when `mKey` is not NULL).
    pub mKeyLength: u16,
    ///< The PSA key ref (requires `mKey` to be NULL).
    pub mKeyRef: u32,
}
/// @struct otCryptoContext
///
/// Stores the context object for platform APIs.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCryptoContext {
    ///< Pointer to the context.
    pub mContext: *mut ::core::ffi::c_void,
    ///< The length of the context in bytes.
    pub mContextSize: u16,
}
/// @struct otPlatCryptoSha256Hash
///
/// Represents a SHA-256 hash.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otPlatCryptoSha256Hash {
    ///< Hash bytes.
    pub m8: [u8; 32usize],
}
/// @struct otPlatCryptoEcdsaKeyPair
///
/// Represents an ECDSA key pair (public and private keys).
///
/// The key pair is stored using Distinguished Encoding Rules (DER) format (per RFC 5915).
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPlatCryptoEcdsaKeyPair {
    pub mDerBytes: [u8; 125usize],
    pub mDerLength: u8,
}
/// @struct otPlatCryptoEcdsaPublicKey
///
/// Represents a ECDSA public key.
///
/// The public key is stored as a byte sequence representation of an uncompressed curve point (RFC 6605 - sec 4).
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otPlatCryptoEcdsaPublicKey {
    pub m8: [u8; 64usize],
}
/// @struct otPlatCryptoEcdsaSignature
///
/// Represents an ECDSA signature.
///
/// The signature is encoded as the concatenated binary representation of two MPIs `r` and `s` which are calculated
/// during signing (RFC 6605 - section 4).
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otPlatCryptoEcdsaSignature {
    pub m8: [u8; 64usize],
}
unsafe extern "C" {
    /// Initialize the Crypto module.
    pub fn otPlatCryptoInit();
}
unsafe extern "C" {
    /// Import a key into PSA ITS.
    ///
    /// @param[in,out] aKeyRef           Pointer to the key ref to be used for crypto operations.
    /// @param[in]     aKeyType          Key Type encoding for the key.
    /// @param[in]     aKeyAlgorithm     Key algorithm encoding for the key.
    /// @param[in]     aKeyUsage         Key Usage encoding for the key (combinations of `OT_CRYPTO_KEY_USAGE_*`).
    /// @param[in]     aKeyPersistence   Key Persistence for this key
    /// @param[in]     aKey              Actual key to be imported.
    /// @param[in]     aKeyLen           Length of the key to be imported.
    ///
    /// @retval OT_ERROR_NONE          Successfully imported the key.
    /// @retval OT_ERROR_FAILED        Failed to import the key.
    /// @retval OT_ERROR_INVALID_ARGS  @p aKey was set to NULL.
    ///
    /// @note If OT_CRYPTO_KEY_STORAGE_PERSISTENT is passed for aKeyPersistence then @p aKeyRef is input and platform
    ///       should use the given aKeyRef and MUST not change it.
    ///
    ///       If OT_CRYPTO_KEY_STORAGE_VOLATILE is passed for aKeyPersistence then @p aKeyRef is output, the initial
    ///       value does not matter and platform API MUST update it to return the new key ref.
    ///
    ///       This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoImportKey(
        aKeyRef: *mut otCryptoKeyRef,
        aKeyType: otCryptoKeyType,
        aKeyAlgorithm: otCryptoKeyAlgorithm,
        aKeyUsage: ::core::ffi::c_int,
        aKeyPersistence: otCryptoKeyStorage,
        aKey: *const u8,
        aKeyLen: usize,
    ) -> otError;
}
unsafe extern "C" {
    /// Export a key stored in PSA ITS.
    ///
    /// @param[in]   aKeyRef           The key ref to be used for crypto operations.
    /// @param[out]  aBuffer           Pointer to the buffer where key needs to be exported.
    /// @param[in]   aBufferLen        Length of the buffer passed to store the exported key.
    /// @param[out]  aKeyLen           Pointer to return the length of the exported key.
    ///
    /// @retval OT_ERROR_NONE          Successfully exported  @p aKeyRef.
    /// @retval OT_ERROR_FAILED        Failed to export @p aKeyRef.
    /// @retval OT_ERROR_INVALID_ARGS  @p aBuffer was NULL
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoExportKey(
        aKeyRef: otCryptoKeyRef,
        aBuffer: *mut u8,
        aBufferLen: usize,
        aKeyLen: *mut usize,
    ) -> otError;
}
unsafe extern "C" {
    /// Destroy a key stored in PSA ITS.
    ///
    /// @param[in]   aKeyRef          The key ref to be destroyed
    ///
    /// @retval OT_ERROR_NONE          Successfully destroyed the key.
    /// @retval OT_ERROR_FAILED        Failed to destroy the key.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoDestroyKey(aKeyRef: otCryptoKeyRef) -> otError;
}
unsafe extern "C" {
    /// Check if the key ref passed has an associated key in PSA ITS.
    ///
    /// @param[in]  aKeyRef          The Key Ref to check.
    ///
    /// @retval TRUE                 There is an associated key with @p aKeyRef.
    /// @retval FALSE                There is no associated key with @p aKeyRef.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoHasKey(aKeyRef: otCryptoKeyRef) -> bool;
}
unsafe extern "C" {
    /// Initialize the HMAC operation.
    ///
    /// @param[in]  aContext          Context for HMAC operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully initialized HMAC operation.
    /// @retval OT_ERROR_FAILED        Failed to initialize HMAC operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    ///
    /// @note The platform driver shall point the context to the correct object such as psa_mac_operation_t or
    ///       mbedtls_md_context_t.
    pub fn otPlatCryptoHmacSha256Init(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Uninitialize the HMAC operation.
    ///
    /// @param[in]  aContext          Context for HMAC operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully uninitialized HMAC operation.
    /// @retval OT_ERROR_FAILED        Failed to uninitialized HMAC operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoHmacSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Start HMAC operation.
    ///
    /// @param[in]  aContext           Context for HMAC operation.
    /// @param[in]  aKey               Key material to be used for HMAC operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully started HMAC operation.
    /// @retval OT_ERROR_FAILED        Failed to start HMAC operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL
    pub fn otPlatCryptoHmacSha256Start(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
unsafe extern "C" {
    /// Update the HMAC operation with new input.
    ///
    /// @param[in]  aContext           Context for HMAC operation.
    /// @param[in]  aBuf               A pointer to the input buffer.
    /// @param[in]  aBufLength         The length of @p aBuf in bytes.
    ///
    /// @retval OT_ERROR_NONE          Successfully updated HMAC with new input operation.
    /// @retval OT_ERROR_FAILED        Failed to update HMAC operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL
    pub fn otPlatCryptoHmacSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::core::ffi::c_void,
        aBufLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Complete the HMAC operation.
    ///
    /// @param[in]  aContext           Context for HMAC operation.
    /// @param[out] aBuf               A pointer to the output buffer.
    /// @param[in]  aBufLength         The length of @p aBuf in bytes.
    ///
    /// @retval OT_ERROR_NONE          Successfully completed HMAC operation.
    /// @retval OT_ERROR_FAILED        Failed to complete HMAC operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL
    pub fn otPlatCryptoHmacSha256Finish(
        aContext: *mut otCryptoContext,
        aBuf: *mut u8,
        aBufLength: usize,
    ) -> otError;
}
unsafe extern "C" {
    /// Initialise the AES operation.
    ///
    /// @param[in]  aContext           Context for AES operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully Initialised AES operation.
    /// @retval OT_ERROR_FAILED        Failed to Initialise AES operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    /// @retval OT_ERROR_NO_BUFS       Cannot allocate the context.
    ///
    /// @note The platform driver shall point the context to the correct object such as psa_key_id
    ///       or mbedtls_aes_context_t.
    pub fn otPlatCryptoAesInit(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Set the key for AES operation.
    ///
    /// @param[in]  aContext           Context for AES operation.
    /// @param[out] aKey               Key to use for AES operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully set the key for AES operation.
    /// @retval OT_ERROR_FAILED        Failed to set the key for AES operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL
    pub fn otPlatCryptoAesSetKey(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
unsafe extern "C" {
    /// Encrypt the given data.
    ///
    /// @param[in]  aContext           Context for AES operation.
    /// @param[in]  aInput             Pointer to the input buffer.
    /// @param[in]  aOutput            Pointer to the output buffer.
    ///
    /// @retval OT_ERROR_NONE          Successfully encrypted @p aInput.
    /// @retval OT_ERROR_FAILED        Failed to encrypt @p aInput.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey or @p aOutput were NULL
    pub fn otPlatCryptoAesEncrypt(
        aContext: *mut otCryptoContext,
        aInput: *const u8,
        aOutput: *mut u8,
    ) -> otError;
}
unsafe extern "C" {
    /// Free the AES context.
    ///
    /// @param[in]  aContext           Context for AES operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully freed AES context.
    /// @retval OT_ERROR_FAILED        Failed to free AES context.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoAesFree(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Initialise the HKDF context.
    ///
    /// @param[in]  aContext           Context for HKDF operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully Initialised AES operation.
    /// @retval OT_ERROR_FAILED        Failed to Initialise AES operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    ///
    /// @note The platform driver shall point the context to the correct object such as psa_key_derivation_operation_t
    ///       or HmacSha256::Hash
    pub fn otPlatCryptoHkdfInit(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Perform HKDF Expand step.
    ///
    /// @param[in]  aContext           Operation context for HKDF operation.
    /// @param[in]  aInfo              Pointer to the Info sequence.
    /// @param[in]  aInfoLength        Length of the Info sequence.
    /// @param[out] aOutputKey         Pointer to the output Key.
    /// @param[in]  aOutputKeyLength   Size of the output key buffer.
    ///
    /// @retval OT_ERROR_NONE          HKDF Expand was successful.
    /// @retval OT_ERROR_FAILED        HKDF Expand failed.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoHkdfExpand(
        aContext: *mut otCryptoContext,
        aInfo: *const u8,
        aInfoLength: u16,
        aOutputKey: *mut u8,
        aOutputKeyLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Perform HKDF Extract step.
    ///
    /// @param[in]  aContext           Operation context for HKDF operation.
    /// @param[in]  aSalt              Pointer to the Salt for HKDF.
    /// @param[in]  aSaltLength        Length of Salt.
    /// @param[in]  aInputKey          Pointer to the input key.
    ///
    /// @retval OT_ERROR_NONE          HKDF Extract was successful.
    /// @retval OT_ERROR_FAILED        HKDF Extract failed.
    pub fn otPlatCryptoHkdfExtract(
        aContext: *mut otCryptoContext,
        aSalt: *const u8,
        aSaltLength: u16,
        aInputKey: *const otCryptoKey,
    ) -> otError;
}
unsafe extern "C" {
    /// Uninitialize the HKDF context.
    ///
    /// @param[in]  aContext           Context for HKDF operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully un-initialised HKDF operation.
    /// @retval OT_ERROR_FAILED        Failed to un-initialised HKDF operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoHkdfDeinit(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Initialise the SHA-256 operation.
    ///
    /// @param[in]  aContext           Context for SHA-256 operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully initialised SHA-256 operation.
    /// @retval OT_ERROR_FAILED        Failed to initialise SHA-256 operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    ///
    ///
    /// @note The platform driver shall point the context to the correct object such as psa_hash_operation_t
    ///       or mbedtls_sha256_context.
    pub fn otPlatCryptoSha256Init(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Uninitialize the SHA-256 operation.
    ///
    /// @param[in]  aContext           Context for SHA-256 operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully un-initialised SHA-256 operation.
    /// @retval OT_ERROR_FAILED        Failed to un-initialised SHA-256 operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Start SHA-256 operation.
    ///
    /// @param[in]  aContext           Context for SHA-256 operation.
    ///
    /// @retval OT_ERROR_NONE          Successfully started SHA-256 operation.
    /// @retval OT_ERROR_FAILED        Failed to start SHA-256 operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL
    pub fn otPlatCryptoSha256Start(aContext: *mut otCryptoContext) -> otError;
}
unsafe extern "C" {
    /// Update SHA-256 operation with new input.
    ///
    /// @param[in]  aContext           Context for SHA-256 operation.
    /// @param[in]  aBuf               A pointer to the input buffer.
    /// @param[in]  aBufLength         The length of @p aBuf in bytes.
    ///
    /// @retval OT_ERROR_NONE          Successfully updated SHA-256 with new input operation.
    /// @retval OT_ERROR_FAILED        Failed to update SHA-256 operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL
    pub fn otPlatCryptoSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::core::ffi::c_void,
        aBufLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Finish SHA-256 operation.
    ///
    /// @param[in]  aContext           Context for SHA-256 operation.
    /// @param[in]  aHash              A pointer to the output buffer, where hash needs to be stored.
    /// @param[in]  aHashSize          The length of @p aHash in bytes.
    ///
    /// @retval OT_ERROR_NONE          Successfully completed the SHA-256 operation.
    /// @retval OT_ERROR_FAILED        Failed to complete SHA-256 operation.
    /// @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aHash was NULL
    pub fn otPlatCryptoSha256Finish(
        aContext: *mut otCryptoContext,
        aHash: *mut u8,
        aHashSize: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Initialize cryptographically-secure pseudorandom number generator (CSPRNG).
    pub fn otPlatCryptoRandomInit();
}
unsafe extern "C" {
    /// Deinitialize cryptographically-secure pseudorandom number generator (CSPRNG).
    pub fn otPlatCryptoRandomDeinit();
}
unsafe extern "C" {
    /// Fills a given buffer with cryptographically secure random bytes.
    ///
    /// @param[out] aBuffer            A pointer to a buffer to fill with the random bytes.
    /// @param[in]  aSize              Size of buffer (number of bytes to fill).
    ///
    /// @retval OT_ERROR_NONE          Successfully filled buffer with random values.
    /// @retval OT_ERROR_FAILED        Operation failed.
    pub fn otPlatCryptoRandomGet(aBuffer: *mut u8, aSize: u16) -> otError;
}
unsafe extern "C" {
    /// Generate and populate the output buffer with a new ECDSA key-pair.
    ///
    /// @param[out] aKeyPair           A pointer to an ECDSA key-pair structure to store the generated key-pair.
    ///
    /// @retval OT_ERROR_NONE          A new key-pair was generated successfully.
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.
    /// @retval OT_ERROR_NOT_CAPABLE   Feature not supported.
    /// @retval OT_ERROR_FAILED        Failed to generate key-pair.
    pub fn otPlatCryptoEcdsaGenerateKey(aKeyPair: *mut otPlatCryptoEcdsaKeyPair) -> otError;
}
unsafe extern "C" {
    /// Get the associated public key from the input context.
    ///
    /// @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.
    /// @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.
    ///
    /// @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.
    /// @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).
    /// @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.
    pub fn otPlatCryptoEcdsaGetPublicKey(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
unsafe extern "C" {
    /// Calculate the ECDSA signature for a hashed message using the private key from the input context.
    ///
    /// Uses the deterministic digital signature generation procedure from RFC 6979.
    ///
    /// @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.
    /// @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation
    ///                                is stored.
    /// @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.
    ///
    /// @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.
    /// @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.
    pub fn otPlatCryptoEcdsaSign(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
unsafe extern "C" {
    /// Use the key from the input context to verify the ECDSA signature of a hashed message.
    ///
    /// @param[in]  aPublicKey         A pointer to an ECDSA public key structure where the public key for signature
    ///                                verification is stored.
    /// @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification
    ///                                is stored.
    /// @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is
    ///                                stored.
    ///
    /// @retval OT_ERROR_NONE          The signature was verified successfully.
    /// @retval OT_ERROR_SECURITY      The signature is invalid.
    /// @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.
    pub fn otPlatCryptoEcdsaVerify(
        aPublicKey: *const otPlatCryptoEcdsaPublicKey,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
unsafe extern "C" {
    /// Calculate the ECDSA signature for a hashed message using the Key reference passed.
    ///
    /// Uses the deterministic digital signature generation procedure from RFC 6979.
    ///
    /// @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.
    /// @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation
    ///                                is stored.
    /// @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.
    ///
    /// @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.
    /// @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoEcdsaSignUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the associated public key from the key reference passed.
    ///
    /// The public key is stored differently depending on the crypto backend library being used
    /// (OPENTHREAD_CONFIG_CRYPTO_LIB).
    ///
    /// This API must make sure to return the public key as a byte sequence representation of an
    /// uncompressed curve point (RFC 6605 - sec 4)
    ///
    /// @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.
    /// @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.
    ///
    /// @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.
    /// @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).
    /// @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoEcdsaExportPublicKey(
        aKeyRef: otCryptoKeyRef,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
unsafe extern "C" {
    /// Generate and import a new ECDSA key-pair at reference passed.
    ///
    /// @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.
    ///
    /// @retval OT_ERROR_NONE          A new key-pair was generated successfully.
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.
    /// @retval OT_ERROR_NOT_CAPABLE   Feature not supported.
    /// @retval OT_ERROR_FAILED        Failed to generate key-pair.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoEcdsaGenerateAndImportKey(aKeyRef: otCryptoKeyRef) -> otError;
}
unsafe extern "C" {
    /// Use the keyref to verify the ECDSA signature of a hashed message.
    ///
    /// @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.
    /// @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification
    ///                                is stored.
    /// @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is
    ///                                stored.
    ///
    /// @retval OT_ERROR_NONE          The signature was verified successfully.
    /// @retval OT_ERROR_SECURITY      The signature is invalid.
    /// @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.
    ///
    /// @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.
    pub fn otPlatCryptoEcdsaVerifyUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
unsafe extern "C" {
    /// Perform PKCS#5 PBKDF2 using CMAC (AES-CMAC-PRF-128).
    ///
    /// @param[in]     aPassword          Password to use when generating key.
    /// @param[in]     aPasswordLen       Length of password.
    /// @param[in]     aSalt              Salt to use when generating key.
    /// @param[in]     aSaltLen           Length of salt.
    /// @param[in]     aIterationCounter  Iteration count.
    /// @param[in]     aKeyLen            Length of generated key in bytes.
    /// @param[out]    aKey               A pointer to the generated key.
    ///
    /// @retval OT_ERROR_NONE          A new key-pair was generated successfully.
    /// @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.
    /// @retval OT_ERROR_NOT_CAPABLE   Feature not supported.
    /// @retval OT_ERROR_FAILED        Failed to generate key.
    pub fn otPlatCryptoPbkdf2GenerateKey(
        aPassword: *const u8,
        aPasswordLen: u16,
        aSalt: *const u8,
        aSaltLen: u16,
        aIterationCounter: u32,
        aKeyLen: u16,
        aKey: *mut u8,
    ) -> otError;
}
///< aMaxPHYPacketSize (IEEE 802.15.4-2006)
pub const OT_RADIO_FRAME_MAX_SIZE: _bindgen_ty_2 = 127;
///< Minimal size of frame FCS + CONTROL
pub const OT_RADIO_FRAME_MIN_SIZE: _bindgen_ty_2 = 3;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_SYMBOLS_PER_OCTET: _bindgen_ty_2 = 2;
///< 2.4 GHz IEEE 802.15.4 (bits per second)
pub const OT_RADIO_BIT_RATE: _bindgen_ty_2 = 250000;
///< Number of bits per octet
pub const OT_RADIO_BITS_PER_OCTET: _bindgen_ty_2 = 8;
///< The O-QPSK PHY symbol rate when operating in the 780MHz, 915MHz, 2380MHz, 2450MHz
pub const OT_RADIO_SYMBOL_RATE: _bindgen_ty_2 = 62500;
///< Symbol duration time in unit of microseconds
pub const OT_RADIO_SYMBOL_TIME: _bindgen_ty_2 = 16;
///< Time for 10 symbols in unit of microseconds
pub const OT_RADIO_TEN_SYMBOLS_TIME: _bindgen_ty_2 = 160;
///< LQI measurement not supported
pub const OT_RADIO_LQI_NONE: _bindgen_ty_2 = 0;
///< Invalid or unknown RSSI value
pub const OT_RADIO_RSSI_INVALID: _bindgen_ty_2 = 127;
///< Invalid or unknown power value
pub const OT_RADIO_POWER_INVALID: _bindgen_ty_2 = 127;
/// @defgroup radio-types Radio Types
///
/// @brief
///   This module includes the platform abstraction for a radio frame.
///
/// @{
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_CHANNEL_PAGE_0: _bindgen_ty_3 = 0;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_CHANNEL_PAGE_0_MASK: _bindgen_ty_3 = 1;
///< 915 MHz IEEE 802.15.4-2006
pub const OT_RADIO_CHANNEL_PAGE_2: _bindgen_ty_3 = 2;
///< 915 MHz IEEE 802.15.4-2006
pub const OT_RADIO_CHANNEL_PAGE_2_MASK: _bindgen_ty_3 = 4;
/// Defines the channel page.
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
///< 915 MHz IEEE 802.15.4-2006
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_4 = 1;
///< 915 MHz IEEE 802.15.4-2006
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_4 = 10;
///< 915 MHz IEEE 802.15.4-2006
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_4 = 2046;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_4 = 11;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_4 = 26;
///< 2.4 GHz IEEE 802.15.4-2006
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_4 = 134215680;
/// Defines the frequency band channel range.
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
/// Represents radio capabilities.
///
/// The value is a bit-field indicating the capabilities supported by the radio. See `OT_RADIO_CAPS_*` definitions.
pub type otRadioCaps = u16;
///< Radio supports no capability.
pub const OT_RADIO_CAPS_NONE: _bindgen_ty_5 = 0;
///< Radio supports AckTime event.
pub const OT_RADIO_CAPS_ACK_TIMEOUT: _bindgen_ty_5 = 1;
///< Radio supports Energy Scans.
pub const OT_RADIO_CAPS_ENERGY_SCAN: _bindgen_ty_5 = 2;
///< Radio supports tx retry logic with collision avoidance (CSMA).
pub const OT_RADIO_CAPS_TRANSMIT_RETRIES: _bindgen_ty_5 = 4;
///< Radio supports CSMA backoff for frame transmission (but no retry).
pub const OT_RADIO_CAPS_CSMA_BACKOFF: _bindgen_ty_5 = 8;
///< Radio supports direct transition from sleep to TX with CSMA.
pub const OT_RADIO_CAPS_SLEEP_TO_TX: _bindgen_ty_5 = 16;
///< Radio supports tx security.
pub const OT_RADIO_CAPS_TRANSMIT_SEC: _bindgen_ty_5 = 32;
///< Radio supports tx at specific time.
pub const OT_RADIO_CAPS_TRANSMIT_TIMING: _bindgen_ty_5 = 64;
///< Radio supports rx at specific time.
pub const OT_RADIO_CAPS_RECEIVE_TIMING: _bindgen_ty_5 = 128;
///< Radio supports RxOnWhenIdle handling.
pub const OT_RADIO_CAPS_RX_ON_WHEN_IDLE: _bindgen_ty_5 = 256;
///< Radio supports setting per-frame transmit power.
pub const OT_RADIO_CAPS_TRANSMIT_FRAME_POWER: _bindgen_ty_5 = 512;
/// Defines constants that are used to indicate different radio capabilities. See `otRadioCaps`.
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
/// Represents the IEEE 802.15.4 PAN ID.
pub type otPanId = u16;
/// Represents the IEEE 802.15.4 Short Address.
pub type otShortAddress = u16;
///< Size of IE header in bytes.
pub const OT_IE_HEADER_SIZE: _bindgen_ty_6 = 2;
///< Size of CSL IE content in bytes.
pub const OT_CSL_IE_SIZE: _bindgen_ty_6 = 4;
///< Max length for header IE in ACK.
pub const OT_ACK_IE_MAX_SIZE: _bindgen_ty_6 = 16;
///< Max length of Link Metrics data in Vendor-Specific IE.
pub const OT_ENH_PROBING_IE_DATA_MAX_SIZE: _bindgen_ty_6 = 2;
/// Defines constants about size of header IE in ACK.
pub type _bindgen_ty_6 = ::core::ffi::c_uint;
/// @struct otExtAddress
///
/// Represents the IEEE 802.15.4 Extended Address.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otExtAddress {
    ///< IEEE 802.15.4 Extended Address bytes
    pub m8: [u8; 8usize],
}
/// @struct otMacKey
///
/// Represents a MAC Key.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otMacKey {
    ///< MAC Key bytes.
    pub m8: [u8; 16usize],
}
/// Represents a MAC Key Ref used by PSA.
pub type otMacKeyRef = otCryptoKeyRef;
/// @struct otMacKeyMaterial
///
/// Represents a MAC Key.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacKeyMaterial {
    pub mKeyMaterial: otMacKeyMaterial__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otMacKeyMaterial__bindgen_ty_1 {
    ///< Reference to the key stored.
    pub mKeyRef: otMacKeyRef,
    ///< Key stored as literal.
    pub mKey: otMacKey,
}
///< Use Literal Keys.
pub const otRadioKeyType_OT_KEY_TYPE_LITERAL_KEY: otRadioKeyType = 0;
///< Use Reference to Key.
pub const otRadioKeyType_OT_KEY_TYPE_KEY_REF: otRadioKeyType = 1;
/// Defines constants about key types.
pub type otRadioKeyType = ::core::ffi::c_uint;
/// Represents the IEEE 802.15.4 Header IE (Information Element) related information of a radio frame.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioIeInfo {
    ///< The time offset to the Thread network time.
    pub mNetworkTimeOffset: i64,
    ///< The Time IE offset from the start of PSDU.
    pub mTimeIeOffset: u8,
    ///< The Time sync sequence.
    pub mTimeSyncSeq: u8,
}
/// Represents an IEEE 802.15.4 radio frame.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame {
    ///< The PSDU.
    pub mPsdu: *mut u8,
    ///< Length of the PSDU.
    pub mLength: u16,
    ///< Channel used to transmit/receive the frame.
    pub mChannel: u8,
    ///< Radio link type - should be ignored by radio driver.
    pub mRadioType: u8,
    pub mInfo: otRadioFrame__bindgen_ty_1,
}
/// The union of transmit and receive information for a radio frame.
#[repr(C)]
#[derive(Copy, Clone)]
pub union otRadioFrame__bindgen_ty_1 {
    pub mTxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_1,
    pub mRxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_2,
}
/// Structure representing radio frame transmit information.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    ///< The key material used for AES-CCM frame security.
    pub mAesKey: *const otMacKeyMaterial,
    ///< The pointer to the Header IE(s) related information.
    pub mIeInfo: *mut otRadioIeInfo,
    /// The base time in microseconds for scheduled transmissions
    /// relative to the local radio clock, see `otPlatRadioGetNow` and
    /// `mTxDelay`.
    pub mTxDelayBaseTime: u32,
    /// The delay time in microseconds for this transmission referenced
    /// to `mTxDelayBaseTime`.
    ///
    /// Note: `mTxDelayBaseTime` + `mTxDelay` SHALL point to the point in
    /// time when the end of the SFD will be present at the local
    /// antenna, relative to the local radio clock.
    pub mTxDelay: u32,
    ///< Maximum number of backoffs attempts before declaring CCA failure.
    pub mMaxCsmaBackoffs: u8,
    ///< Maximum number of retries allowed after a transmission failure.
    pub mMaxFrameRetries: u8,
    /// The RX channel after frame TX is done (after all frame retries - ack received, or timeout, or abort).
    ///
    /// Radio platforms can choose to fully ignore this. OT stack will make sure to call `otPlatRadioReceive()`
    /// with the desired RX channel after a frame TX is done and signaled in `otPlatRadioTxDone()` callback.
    /// Radio platforms that don't provide `OT_RADIO_CAPS_TRANSMIT_RETRIES` must always ignore this.
    ///
    /// This is intended for situations where there may be delay in interactions between OT stack and radio, as
    /// an example this is used in RCP/host architecture to make sure RCP switches to PAN channel more quickly.
    /// In particular, this can help with CSL tx to a sleepy child, where the child may use a different channel
    /// for CSL than the PAN channel. After frame tx, we want the radio/RCP to go back to the PAN channel
    /// quickly to ensure that parent does not miss tx from child afterwards, e.g., child responding to the
    /// earlier CSL transmitted frame from parent using PAN channel while radio still staying on CSL channel.
    ///
    /// The switch to the RX channel MUST happen after the frame TX is fully done, i.e., after all retries and
    /// when ack is received (when "Ack Request" flag is set on the TX frame) or ack timeout. Note that ack is
    /// expected on the same channel that frame is sent on.
    pub mRxChannelAfterTxDone: u8,
    /// The transmit power in dBm.
    ///
    /// If the platform layer does not provide `OT_RADIO_CAPS_TRANSMIT_FRAME_POWER` capability, it can ignore
    /// this value.
    ///
    /// If the value is OT_RADIO_POWER_INVALID, then the platform should ignore this value and transmit the frame
    /// with its default transmit power.
    ///
    /// Otherwise, the platform should transmit this frame with the maximum power no larger than minimal of the
    /// following values:
    ///     1. mTxPower,
    ///     2. The power limit set by otPlatRadioSetChannelTargetPower(),
    ///     3. The power limit set by otPlatRadioSetChannelMaxTransmitPower(),
    ///     4. The power limit set by otPlatRadioSetRegion().
    pub mTxPower: i8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    /// The time of the local radio clock in microseconds when the end of
    /// the SFD was present at the local antenna.
    ///
    /// The platform should update this field before otPlatRadioTxStarted() is fired for each transmit attempt.
    pub mTimestamp: u64,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mIsHeaderUpdated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHeaderUpdated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsHeaderUpdated_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsHeaderUpdated_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsARetx(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsARetx(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsARetx_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsARetx_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mCsmaCaEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCsmaCaEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mCsmaCaEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mCsmaCaEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mCslPresent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCslPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mCslPresent_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mCslPresent_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsSecurityProcessed(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityProcessed(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsSecurityProcessed_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsSecurityProcessed_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsHeaderUpdated: bool,
        mIsARetx: bool,
        mCsmaCaEnabled: bool,
        mCslPresent: bool,
        mIsSecurityProcessed: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsHeaderUpdated: u8 = unsafe { ::core::mem::transmute(mIsHeaderUpdated) };
            mIsHeaderUpdated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsARetx: u8 = unsafe { ::core::mem::transmute(mIsARetx) };
            mIsARetx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mCsmaCaEnabled: u8 = unsafe { ::core::mem::transmute(mCsmaCaEnabled) };
            mCsmaCaEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mCslPresent: u8 = unsafe { ::core::mem::transmute(mCslPresent) };
            mCslPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsSecurityProcessed: u8 = unsafe { ::core::mem::transmute(mIsSecurityProcessed) };
            mIsSecurityProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Structure representing radio frame receive information.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    /// The time of the local radio clock in microseconds when the end of
    /// the SFD was present at the local antenna.
    pub mTimestamp: u64,
    ///< ACK security frame counter (applicable when `mAckedWithSecEnhAck` is set).
    pub mAckFrameCounter: u32,
    ///< ACK security key index (applicable when `mAckedWithSecEnhAck` is set).
    pub mAckKeyId: u8,
    ///< Received signal strength indicator in dBm for received frames.
    pub mRssi: i8,
    ///< Link Quality Indicator for received frames.
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn mAckedWithFramePending(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithFramePending(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mAckedWithFramePending_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mAckedWithFramePending_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mAckedWithSecEnhAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithSecEnhAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mAckedWithSecEnhAck_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mAckedWithSecEnhAck_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAckedWithFramePending: bool,
        mAckedWithSecEnhAck: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAckedWithFramePending: u8 =
                unsafe { ::core::mem::transmute(mAckedWithFramePending) };
            mAckedWithFramePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mAckedWithSecEnhAck: u8 = unsafe { ::core::mem::transmute(mAckedWithSecEnhAck) };
            mAckedWithSecEnhAck as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const otRadioState_OT_RADIO_STATE_DISABLED: otRadioState = 0;
pub const otRadioState_OT_RADIO_STATE_SLEEP: otRadioState = 1;
pub const otRadioState_OT_RADIO_STATE_RECEIVE: otRadioState = 2;
pub const otRadioState_OT_RADIO_STATE_TRANSMIT: otRadioState = 3;
pub const otRadioState_OT_RADIO_STATE_INVALID: otRadioState = 255;
/// Represents the state of a radio.
/// Initially, a radio is in the Disabled state.
pub type otRadioState = ::core::ffi::c_uint;
/// Represents radio coexistence metrics.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioCoexMetrics {
    ///< Number of grant glitches.
    pub mNumGrantGlitch: u32,
    ///< Number of tx requests.
    pub mNumTxRequest: u32,
    ///< Number of tx requests while grant was active.
    pub mNumTxGrantImmediate: u32,
    ///< Number of tx requests while grant was inactive.
    pub mNumTxGrantWait: u32,
    ///< Number of tx requests while grant was inactive that were ultimately granted.
    pub mNumTxGrantWaitActivated: u32,
    ///< Number of tx requests while grant was inactive that timed out.
    pub mNumTxGrantWaitTimeout: u32,
    ///< Number of tx that were in progress when grant was deactivated.
    pub mNumTxGrantDeactivatedDuringRequest: u32,
    ///< Number of tx requests that were not granted within 50us.
    pub mNumTxDelayedGrant: u32,
    ///< Average time in usec from tx request to grant.
    pub mAvgTxRequestToGrantTime: u32,
    ///< Number of rx requests.
    pub mNumRxRequest: u32,
    ///< Number of rx requests while grant was active.
    pub mNumRxGrantImmediate: u32,
    ///< Number of rx requests while grant was inactive.
    pub mNumRxGrantWait: u32,
    ///< Number of rx requests while grant was inactive that were ultimately granted.
    pub mNumRxGrantWaitActivated: u32,
    ///< Number of rx requests while grant was inactive that timed out.
    pub mNumRxGrantWaitTimeout: u32,
    ///< Number of rx that were in progress when grant was deactivated.
    pub mNumRxGrantDeactivatedDuringRequest: u32,
    ///< Number of rx requests that were not granted within 50us.
    pub mNumRxDelayedGrant: u32,
    ///< Average time in usec from rx request to grant.
    pub mAvgRxRequestToGrantTime: u32,
    ///< Number of rx requests that completed without receiving grant.
    pub mNumRxGrantNone: u32,
    ///< Stats collection stopped due to saturation.
    pub mStopped: bool,
}
/// Represents what metrics are specified to query.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLinkMetrics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkMetrics {
    #[inline]
    pub fn mPduCount(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPduCount(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mPduCount_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mPduCount_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mLqi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLqi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mLqi_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mLqi_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mLinkMargin(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkMargin(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mLinkMargin_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mLinkMargin_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mRssi(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRssi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mRssi_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mRssi_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mReserved(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mReserved(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mReserved_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mReserved_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPduCount: bool,
        mLqi: bool,
        mLinkMargin: bool,
        mRssi: bool,
        mReserved: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPduCount: u8 = unsafe { ::core::mem::transmute(mPduCount) };
            mPduCount as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLqi: u8 = unsafe { ::core::mem::transmute(mLqi) };
            mLqi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mLinkMargin: u8 = unsafe { ::core::mem::transmute(mLinkMargin) };
            mLinkMargin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRssi: u8 = unsafe { ::core::mem::transmute(mRssi) };
            mRssi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mReserved: u8 = unsafe { ::core::mem::transmute(mReserved) };
            mReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    /// Get the radio capabilities.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns The radio capability bit vector (see `OT_RADIO_CAP_*` definitions).
    pub fn otPlatRadioGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
unsafe extern "C" {
    /// Get the radio version string.
    ///
    /// This is an optional radio driver platform function. If not provided by platform radio driver, OpenThread uses
    /// the OpenThread version instead (@sa otGetVersionString()).
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    ///
    /// @returns A pointer to the OpenThread radio version.
    pub fn otPlatRadioGetVersionString(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Get the radio receive sensitivity value.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns The radio receive sensitivity value in dBm.
    pub fn otPlatRadioGetReceiveSensitivity(aInstance: *mut otInstance) -> i8;
}
unsafe extern "C" {
    /// Gets the factory-assigned IEEE EUI-64 for this interface.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    /// @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.
    pub fn otPlatRadioGetIeeeEui64(aInstance: *mut otInstance, aIeeeEui64: *mut u8);
}
unsafe extern "C" {
    /// Set the PAN ID for address filtering.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aPanId     The IEEE 802.15.4 PAN ID.
    pub fn otPlatRadioSetPanId(aInstance: *mut otInstance, aPanId: otPanId);
}
unsafe extern "C" {
    /// Set the Extended Address for address filtering.
    ///
    /// @param[in] aInstance    The OpenThread instance structure.
    /// @param[in] aExtAddress  A pointer to the IEEE 802.15.4 Extended Address stored in little-endian byte order.
    pub fn otPlatRadioSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    );
}
unsafe extern "C" {
    /// Set the Short Address for address filtering.
    ///
    /// @param[in] aInstance      The OpenThread instance structure.
    /// @param[in] aShortAddress  The IEEE 802.15.4 Short Address.
    pub fn otPlatRadioSetShortAddress(aInstance: *mut otInstance, aShortAddress: otShortAddress);
}
unsafe extern "C" {
    /// Get the radio's transmit power in dBm.
    ///
    /// @note The transmit power returned will be no larger than the power specified in the max power table for
    /// the current channel.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[out] aPower    The transmit power in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully retrieved the transmit power.
    /// @retval OT_ERROR_INVALID_ARGS     @p aPower was NULL.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.
    pub fn otPlatRadioGetTransmitPower(aInstance: *mut otInstance, aPower: *mut i8) -> otError;
}
unsafe extern "C" {
    /// Set the radio's transmit power in dBm.
    ///
    /// @note The real transmit power will be no larger than the power specified in the max power table for
    /// the current channel.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aPower     The transmit power in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully set the transmit power.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.
    pub fn otPlatRadioSetTransmitPower(aInstance: *mut otInstance, aPower: i8) -> otError;
}
unsafe extern "C" {
    /// Get the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.
    ///
    /// @param[in] aInstance    The OpenThread instance structure.
    /// @param[out] aThreshold  The CCA ED threshold in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully retrieved the CCA ED threshold.
    /// @retval OT_ERROR_INVALID_ARGS     @p aThreshold was NULL.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.
    pub fn otPlatRadioGetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: *mut i8,
    ) -> otError;
}
unsafe extern "C" {
    /// Set the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.
    ///
    /// @param[in] aInstance   The OpenThread instance structure.
    /// @param[in] aThreshold  The CCA ED threshold in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully set the transmit power.
    /// @retval OT_ERROR_INVALID_ARGS     Given threshold is out of range.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.
    pub fn otPlatRadioSetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: i8,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the external FEM's Rx LNA gain in dBm.
    ///
    /// @param[in]  aInstance  The OpenThread instance structure.
    /// @param[out] aGain     The external FEM's Rx LNA gain in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully retrieved the external FEM's LNA gain.
    /// @retval OT_ERROR_INVALID_ARGS     @p aGain was NULL.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA setting is not implemented.
    pub fn otPlatRadioGetFemLnaGain(aInstance: *mut otInstance, aGain: *mut i8) -> otError;
}
unsafe extern "C" {
    /// Sets the external FEM's Rx LNA gain in dBm.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aGain      The external FEM's Rx LNA gain in dBm.
    ///
    /// @retval OT_ERROR_NONE             Successfully set the external FEM's LNA gain.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA gain setting is not implemented.
    pub fn otPlatRadioSetFemLnaGain(aInstance: *mut otInstance, aGain: i8) -> otError;
}
unsafe extern "C" {
    /// Get the status of promiscuous mode.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @retval TRUE   Promiscuous mode is enabled.
    /// @retval FALSE  Promiscuous mode is disabled.
    pub fn otPlatRadioGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Enable or disable promiscuous mode.
    ///
    /// @param[in]  aInstance The OpenThread instance structure.
    /// @param[in]  aEnable   TRUE to enable or FALSE to disable promiscuous mode.
    pub fn otPlatRadioSetPromiscuous(aInstance: *mut otInstance, aEnable: bool);
}
unsafe extern "C" {
    /// Sets the rx-on-when-idle state to the radio platform.
    ///
    /// There are a few situations that the radio can enter sleep state if the device is in rx-off-when-idle state but
    /// it's hard and costly for the SubMac to identify these situations and instruct the radio to enter sleep:
    ///
    /// - Finalization of a regular frame reception task, provided that:
    ///   - The frame is received without errors and passes the filtering and it's not an spurious ACK.
    ///   - ACK is not requested or transmission of ACK is not possible due to internal conditions.
    /// - Finalization of a frame transmission or transmission of an ACK frame, when ACK is not requested in the transmitted
    ///   frame.
    /// - Finalization of the reception operation of a requested ACK due to:
    ///   - ACK timeout expiration.
    ///   - Reception of an invalid ACK or not an ACK frame.
    ///   - Reception of the proper ACK, unless the transmitted frame was a Data Request Command and the frame pending bit
    ///     on the received ACK is set to true. In this case the radio platform implementation SHOULD keep the receiver on
    ///     until a determined timeout which triggers an idle period start.`OPENTHREAD_CONFIG_MAC_DATA_POLL_TIMEOUT` can be
    ///     taken as a reference for this.
    /// - Finalization of a stand alone CCA task.
    /// - Finalization of a CCA operation with busy result during CSMA/CA procedure.
    /// - Finalization of an Energy Detection task.
    /// - Finalization of a radio reception window scheduled with `otPlatRadioReceiveAt`.
    ///
    /// If a platform supports `OT_RADIO_CAPS_RX_ON_WHEN_IDLE` it must also support `OT_RADIO_CAPS_CSMA_BACKOFF` and handle
    /// idle periods after CCA as described above.
    ///
    /// Upon the transition of the "RxOnWhenIdle" flag from TRUE to FALSE, the radio platform should enter sleep mode.
    /// If the radio is currently in receive mode, it should enter sleep mode immediately. Otherwise, it should enter sleep
    /// mode after the current operation is completed.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aEnable      TRUE to keep radio in Receive state, FALSE to put to Sleep state during idle periods.
    pub fn otPlatRadioSetRxOnWhenIdle(aInstance: *mut otInstance, aEnable: bool);
}
unsafe extern "C" {
    /// Update MAC keys and key index
    ///
    /// Is used when radio provides OT_RADIO_CAPS_TRANSMIT_SEC capability.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[in]   aKeyIdMode   The key ID mode.
    /// @param[in]   aKeyId       Current MAC key index.
    /// @param[in]   aPrevKey     A pointer to the previous MAC key.
    /// @param[in]   aCurrKey     A pointer to the current MAC key.
    /// @param[in]   aNextKey     A pointer to the next MAC key.
    /// @param[in]   aKeyType     Key Type used.
    pub fn otPlatRadioSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKeyMaterial,
        aCurrKey: *const otMacKeyMaterial,
        aNextKey: *const otMacKeyMaterial,
        aKeyType: otRadioKeyType,
    );
}
unsafe extern "C" {
    /// Sets the current MAC frame counter value.
    ///
    /// Is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.
    ///
    /// @param[in]   aInstance         A pointer to an OpenThread instance.
    /// @param[in]   aMacFrameCounter  The MAC frame counter value.
    pub fn otPlatRadioSetMacFrameCounter(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
unsafe extern "C" {
    /// Sets the current MAC frame counter value only if the new given value is larger than the current value.
    ///
    /// Is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.
    ///
    /// @param[in]   aInstance         A pointer to an OpenThread instance.
    /// @param[in]   aMacFrameCounter  The MAC frame counter value.
    pub fn otPlatRadioSetMacFrameCounterIfLarger(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
unsafe extern "C" {
    /// Get the current time in microseconds referenced to a continuous monotonic
    /// local radio clock (64 bits width).
    ///
    /// The radio clock SHALL NOT wrap during the device's uptime. Implementations
    /// SHALL therefore identify and compensate for internal counter overflows. The
    /// clock does not have a defined epoch and it SHALL NOT introduce any continuous
    /// or discontinuous adjustments (e.g. leap seconds). Implementations SHALL
    /// compensate for any sleep times of the device.
    ///
    /// Implementations MAY choose to discipline the radio clock and compensate for
    /// sleep times by any means (e.g. by combining a high precision/low power RTC
    /// with a high resolution counter) as long as the exposed combined clock
    /// provides continuous monotonic microsecond resolution ticks within the
    /// accuracy limits announced by @ref otPlatRadioGetCslAccuracy.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    ///
    /// @returns The current time in microseconds. UINT64_MAX when platform does not
    /// support or radio time is not ready.
    pub fn otPlatRadioGetNow(aInstance: *mut otInstance) -> u64;
}
unsafe extern "C" {
    /// Get the bus speed in bits/second between the host and the radio chip.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    ///
    /// @returns The bus speed in bits/second between the host and the radio chip.
    ///          Return 0 when the MAC and above layer and Radio layer resides on the same chip.
    pub fn otPlatRadioGetBusSpeed(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Get the bus latency in microseconds between the host and the radio chip.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    ///
    /// @returns The bus latency in microseconds between the host and the radio chip.
    ///          Return 0 when the MAC and above layer and Radio layer resides on the same chip.
    pub fn otPlatRadioGetBusLatency(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Get current state of the radio.
    ///
    /// Is not required by OpenThread. It may be used for debugging and/or application-specific purposes.
    ///
    /// @note This function may be not implemented. It does not affect OpenThread.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @return  Current state of the radio.
    pub fn otPlatRadioGetState(aInstance: *mut otInstance) -> otRadioState;
}
unsafe extern "C" {
    /// Enable the radio.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @retval OT_ERROR_NONE     Successfully enabled.
    /// @retval OT_ERROR_FAILED   The radio could not be enabled.
    pub fn otPlatRadioEnable(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Disable the radio.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @retval OT_ERROR_NONE            Successfully transitioned to Disabled.
    /// @retval OT_ERROR_INVALID_STATE   The radio was not in sleep state.
    pub fn otPlatRadioDisable(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Check whether radio is enabled or not.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns TRUE if the radio is enabled, FALSE otherwise.
    pub fn otPlatRadioIsEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Transition the radio from Receive to Sleep (turn off the radio).
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @retval OT_ERROR_NONE          Successfully transitioned to Sleep.
    /// @retval OT_ERROR_BUSY          The radio was transmitting.
    /// @retval OT_ERROR_INVALID_STATE The radio was disabled.
    pub fn otPlatRadioSleep(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Transition the radio from Sleep to Receive (turn on the radio).
    ///
    /// @param[in]  aInstance  The OpenThread instance structure.
    /// @param[in]  aChannel   The channel to use for receiving.
    ///
    /// @retval OT_ERROR_NONE          Successfully transitioned to Receive.
    /// @retval OT_ERROR_INVALID_STATE The radio was disabled or transmitting.
    pub fn otPlatRadioReceive(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
unsafe extern "C" {
    /// Schedule a radio reception window at a specific time and duration.
    ///
    /// @param[in]  aChannel   The radio channel on which to receive.
    /// @param[in]  aStart     The receive window start time relative to the local
    ///                        radio clock, see `otPlatRadioGetNow`. The radio
    ///                        receiver SHALL be on and ready to receive the first
    ///                        symbol of a frame's SHR at the window start time.
    /// @param[in]  aDuration  The receive window duration, in microseconds, as
    ///                        measured by the local radio clock. The radio SHOULD be
    ///                        turned off (or switched to TX mode if an ACK frame
    ///                        needs to be sent) after that duration unless it is
    ///                        still actively receiving a frame. In the latter case
    ///                        the radio SHALL be kept in reception mode until frame
    ///                        reception has either succeeded or failed.
    ///
    /// @retval OT_ERROR_NONE    Successfully scheduled receive window.
    /// @retval OT_ERROR_FAILED  The receive window could not be scheduled.
    pub fn otPlatRadioReceiveAt(
        aInstance: *mut otInstance,
        aChannel: u8,
        aStart: u32,
        aDuration: u32,
    ) -> otError;
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread of a received frame.
    ///
    /// @param[in]  aInstance The OpenThread instance structure.
    /// @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.
    /// @param[in]  aError    OT_ERROR_NONE when successfully received a frame,
    ///                       OT_ERROR_ABORT when reception was aborted and a frame was not received,
    ///                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.
    pub fn otPlatRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread diagnostics module of a received frame.
    ///
    /// Is used when diagnostics is enabled.
    ///
    /// @param[in]  aInstance The OpenThread instance structure.
    /// @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.
    /// @param[in]  aError    OT_ERROR_NONE when successfully received a frame,
    ///                       OT_ERROR_ABORT when reception was aborted and a frame was not received,
    ///                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.
    pub fn otPlatDiagRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
unsafe extern "C" {
    /// Get the radio transmit frame buffer.
    ///
    /// OpenThread forms the IEEE 802.15.4 frame in this buffer then calls `otPlatRadioTransmit()` to request transmission.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns A pointer to the transmit frame buffer.
    pub fn otPlatRadioGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
unsafe extern "C" {
    /// Begin the transmit sequence on the radio.
    ///
    /// The caller must form the IEEE 802.15.4 frame in the buffer provided by `otPlatRadioGetTransmitBuffer()` before
    /// requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure.
    ///
    /// The transmit sequence consists of:
    /// 1. Transitioning the radio to Transmit from one of the following states:
    ///    - Receive if RX is on when the device is idle or OT_RADIO_CAPS_SLEEP_TO_TX is not supported
    ///    - Sleep if RX is off when the device is idle and OT_RADIO_CAPS_SLEEP_TO_TX is supported.
    /// 2. Transmits the psdu on the given channel and at the given transmit power.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aFrame     A pointer to the frame to be transmitted.
    ///
    /// @retval OT_ERROR_NONE          Successfully transitioned to Transmit.
    /// @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state.
    pub fn otPlatRadioTransmit(aInstance: *mut otInstance, aFrame: *mut otRadioFrame) -> otError;
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread that the transmission has started.
    ///
    /// @note  This function should be called by the same thread that executes all of the other OpenThread code. It should
    ///        not be called by ISR or any other task.
    ///
    /// @param[in]  aInstance  A pointer to the OpenThread instance structure.
    /// @param[in]  aFrame     A pointer to the frame that is being transmitted.
    pub fn otPlatRadioTxStarted(aInstance: *mut otInstance, aFrame: *mut otRadioFrame);
}
unsafe extern "C" {
    /// The radio driver calls this function to notify OpenThread that the transmit operation has completed,
    /// providing both the transmitted frame and, if applicable, the received ack frame.
    ///
    /// When radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability, radio platform layer updates @p aFrame
    /// with the security frame counter and key index values maintained by the radio.
    ///
    /// @param[in]  aInstance  The OpenThread instance structure.
    /// @param[in]  aFrame     A pointer to the frame that was transmitted.
    /// @param[in]  aAckFrame  A pointer to the ACK frame, NULL if no ACK was received.
    /// @param[in]  aError     OT_ERROR_NONE when the frame was transmitted,
    ///                        OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received,
    ///                        OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,
    ///                        OT_ERROR_ABORT when transmission was aborted for other reasons.
    pub fn otPlatRadioTxDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    );
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed.
    ///
    /// Is used when diagnostics is enabled.
    ///
    /// @param[in]  aInstance      The OpenThread instance structure.
    /// @param[in]  aFrame         A pointer to the frame that was transmitted.
    /// @param[in]  aError         OT_ERROR_NONE when the frame was transmitted,
    ///                            OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,
    ///                            OT_ERROR_ABORT when transmission was aborted for other reasons.
    pub fn otPlatDiagRadioTransmitDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
unsafe extern "C" {
    /// Get the most recent RSSI measurement.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid.
    pub fn otPlatRadioGetRssi(aInstance: *mut otInstance) -> i8;
}
unsafe extern "C" {
    /// Begin the energy scan sequence on the radio.
    ///
    /// Is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.
    ///
    /// @param[in] aInstance      The OpenThread instance structure.
    /// @param[in] aScanChannel   The channel to perform the energy scan on.
    /// @param[in] aScanDuration  The duration, in milliseconds, for the channel to be scanned.
    ///
    /// @retval OT_ERROR_NONE             Successfully started scanning the channel.
    /// @retval OT_ERROR_BUSY             The radio is performing energy scanning.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning.
    pub fn otPlatRadioEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread that the energy scan is complete.
    ///
    /// Is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.
    ///
    /// @param[in]  aInstance           The OpenThread instance structure.
    /// @param[in]  aEnergyScanMaxRssi  The maximum RSSI encountered on the scanned channel.
    pub fn otPlatRadioEnergyScanDone(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8);
}
unsafe extern "C" {
    /// The radio driver calls this method to notify OpenThread that the spinel bus latency has been changed.
    ///
    /// @param[in]  aInstance  The OpenThread instance structure.
    pub fn otPlatRadioBusLatencyChanged(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Enable/Disable source address match feature.
    ///
    /// The source address match feature controls how the radio layer decides the "frame pending" bit for acks sent in
    /// response to data request commands from children.
    ///
    /// If disabled, the radio layer must set the "frame pending" on all acks to data request commands.
    ///
    /// If enabled, the radio layer uses the source address match table to determine whether to set or clear the "frame
    /// pending" bit in an ack to a data request command.
    ///
    /// The source address match table provides the list of children for which there is a pending frame. Either a short
    /// address or an extended/long address can be added to the source address match table.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    /// @param[in]  aEnable     Enable/disable source address match feature.
    pub fn otPlatRadioEnableSrcMatch(aInstance: *mut otInstance, aEnable: bool);
}
unsafe extern "C" {
    /// Add a short address to the source address match table.
    ///
    /// @param[in]  aInstance      The OpenThread instance structure.
    /// @param[in]  aShortAddress  The short address to be added.
    ///
    /// @retval OT_ERROR_NONE      Successfully added short address to the source match table.
    /// @retval OT_ERROR_NO_BUFS   No available entry in the source match table.
    pub fn otPlatRadioAddSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Add an extended address to the source address match table.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aExtAddress  The extended address to be added stored in little-endian byte order.
    ///
    /// @retval OT_ERROR_NONE      Successfully added extended address to the source match table.
    /// @retval OT_ERROR_NO_BUFS   No available entry in the source match table.
    pub fn otPlatRadioAddSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Remove a short address from the source address match table.
    ///
    /// @param[in]  aInstance      The OpenThread instance structure.
    /// @param[in]  aShortAddress  The short address to be removed.
    ///
    /// @retval OT_ERROR_NONE        Successfully removed short address from the source match table.
    /// @retval OT_ERROR_NO_ADDRESS  The short address is not in source address match table.
    pub fn otPlatRadioClearSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Remove an extended address from the source address match table.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aExtAddress  The extended address to be removed stored in little-endian byte order.
    ///
    /// @retval OT_ERROR_NONE        Successfully removed the extended address from the source match table.
    /// @retval OT_ERROR_NO_ADDRESS  The extended address is not in source address match table.
    pub fn otPlatRadioClearSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Clear all short addresses from the source address match table.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    pub fn otPlatRadioClearSrcMatchShortEntries(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Clear all the extended/long addresses from source address match table.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    pub fn otPlatRadioClearSrcMatchExtEntries(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Get the radio supported channel mask that the device is allowed to be on.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    ///
    /// @returns The radio supported channel mask.
    pub fn otPlatRadioGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Gets the radio preferred channel mask that the device prefers to form on.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    ///
    /// @returns The radio preferred channel mask.
    pub fn otPlatRadioGetPreferredChannelMask(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Enable the radio coex.
    ///
    /// Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aEnabled   TRUE to enable the radio coex, FALSE otherwise.
    ///
    /// @retval OT_ERROR_NONE     Successfully enabled.
    /// @retval OT_ERROR_FAILED   The radio coex could not be enabled.
    pub fn otPlatRadioSetCoexEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
unsafe extern "C" {
    /// Check whether radio coex is enabled or not.
    ///
    /// Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @returns TRUE if the radio coex is enabled, FALSE otherwise.
    pub fn otPlatRadioIsCoexEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Get the radio coexistence metrics.
    ///
    /// Is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[out] aCoexMetrics  A pointer to the coexistence metrics structure.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the coex metrics.
    /// @retval OT_ERROR_INVALID_ARGS  @p aCoexMetrics was NULL.
    pub fn otPlatRadioGetCoexMetrics(
        aInstance: *mut otInstance,
        aCoexMetrics: *mut otRadioCoexMetrics,
    ) -> otError;
}
unsafe extern "C" {
    /// Enable or disable CSL receiver.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[in]  aCslPeriod    CSL period, 0 for disabling CSL. CSL period is in unit of 10 symbols.
    /// @param[in]  aShortAddr    The short source address of CSL receiver's peer.
    /// @param[in]  aExtAddr      The extended source address of CSL receiver's peer.
    ///
    /// @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks.
    ///
    /// @retval  OT_ERROR_NOT_IMPLEMENTED Radio driver doesn't support CSL.
    /// @retval  OT_ERROR_FAILED          Other platform specific errors.
    /// @retval  OT_ERROR_NONE            Successfully enabled or disabled CSL.
    pub fn otPlatRadioEnableCsl(
        aInstance: *mut otInstance,
        aCslPeriod: u32,
        aShortAddr: otShortAddress,
        aExtAddr: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Reset CSL receiver in the platform.
    ///
    /// @note Defaults to `otPlatRadioEnableCsl(aInstance,0, Mac::kShortAddrInvalid, nullptr);`
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    ///
    /// @retval  OT_ERROR_NOT_IMPLEMENTED Radio driver doesn't support CSL.
    /// @retval  OT_ERROR_FAILED          Other platform specific errors.
    /// @retval  OT_ERROR_NONE            Successfully disabled CSL.
    pub fn otPlatRadioResetCsl(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Update CSL sample time in radio driver.
    ///
    /// Sample time is stored in radio driver as a copy to calculate phase when
    /// sending ACK with CSL IE. The CSL sample (window) of the CSL receiver extends
    /// before and after the sample time. The CSL sample time marks a timestamp in
    /// the CSL sample window when a frame should be received in "ideal conditions"
    /// if there would be no inaccuracy/clock-drift.
    ///
    /// @param[in]  aInstance         The OpenThread instance structure.
    /// @param[in]  aCslSampleTime    The next sample time, in microseconds. It is
    ///                               the time when the first symbol of the MHR of
    ///                               the frame is expected.
    pub fn otPlatRadioUpdateCslSampleTime(aInstance: *mut otInstance, aCslSampleTime: u32);
}
unsafe extern "C" {
    /// Get the current estimated worst case accuracy (maximum  deviation from the
    /// nominal frequency) of the local radio clock in units of PPM. This is the
    /// clock used to schedule CSL operations.
    ///
    /// @note Implementations MAY estimate this value based on current operating
    /// conditions (e.g. temperature).
    ///
    /// In case the implementation does not estimate the current value but returns a
    /// fixed value, this value MUST be the worst-case accuracy over all possible
    /// foreseen operating conditions (temperature, pressure, etc) of the
    /// implementation.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    ///
    /// @returns The current CSL rx/tx scheduling drift, in PPM.
    pub fn otPlatRadioGetCslAccuracy(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// The fixed uncertainty (i.e. random jitter) of the arrival time of CSL
    /// transmissions received by this device in units of 10 microseconds.
    ///
    /// This designates the worst case constant positive or negative deviation of
    /// the actual arrival time of a transmission from the transmission time
    /// calculated relative to the local radio clock independent of elapsed time. In
    /// addition to uncertainty accumulated over elapsed time, the CSL channel sample
    /// ("RX window") must be extended by twice this deviation such that an actual
    /// transmission is guaranteed to be detected by the local receiver in the
    /// presence of random arrival time jitter.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    ///
    /// @returns The CSL Uncertainty in units of 10 us.
    pub fn otPlatRadioGetCslUncertainty(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Set the max transmit power for a specific channel.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aChannel     The radio channel.
    /// @param[in]  aMaxPower    The max power in dBm, passing OT_RADIO_RSSI_INVALID will disable this channel.
    ///
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented
    /// @retval  OT_ERROR_INVALID_ARGS     The specified channel is not valid.
    /// @retval  OT_ERROR_FAILED           Other platform specific errors.
    /// @retval  OT_ERROR_NONE             Successfully set max transmit power.
    pub fn otPlatRadioSetChannelMaxTransmitPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aMaxPower: i8,
    ) -> otError;
}
unsafe extern "C" {
    /// Set the region code.
    ///
    /// The radio region format is the 2-bytes ascii representation of the
    /// ISO 3166 alpha-2 code.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char
    ///                          and the `aRegionCode & 0xff` is the second ascii char.
    ///
    /// @retval  OT_ERROR_FAILED           Other platform specific errors.
    /// @retval  OT_ERROR_NONE             Successfully set region code.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
    pub fn otPlatRadioSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
unsafe extern "C" {
    /// Get the region code.
    ///
    /// The radio region format is the 2-bytes ascii representation of the
    /// ISO 3166 alpha-2 code.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[out] aRegionCode  The radio region.
    ///
    /// @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.
    /// @retval  OT_ERROR_FAILED           Other platform specific errors.
    /// @retval  OT_ERROR_NONE             Successfully got region code.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
    pub fn otPlatRadioGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
unsafe extern "C" {
    /// Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator.
    ///
    /// After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that
    /// node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to
    /// collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that
    /// Probing Initiator.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics
    ///                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0.
    /// @param[in]  aShortAddress The short address of the Probing Initiator.
    /// @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`.
    ///
    /// @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing.
    /// @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`.
    /// @retval  OT_ERROR_NOT_FOUND       The Initiator indicated by @p aShortAddress is not found when trying to clear.
    /// @retval  OT_ERROR_NO_BUFS         No more Initiator can be supported.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED The feature is not implemented.
    pub fn otPlatRadioConfigureEnhAckProbing(
        aInstance: *mut otInstance,
        aLinkMetrics: otLinkMetrics,
        aShortAddress: otShortAddress,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Add a calibrated power of the specified channel to the power calibration table.
    ///
    /// @note This API is an optional radio platform API. It's up to the platform layer to implement it.
    ///
    /// The @p aActualPower is the actual measured output power when the parameters of the radio hardware modules
    /// are set to the @p aRawPowerSetting.
    ///
    /// The raw power setting is an opaque byte array. OpenThread doesn't define the format of the raw power setting.
    /// Its format is radio hardware related and it should be defined by the developers in the platform radio driver.
    /// For example, if the radio hardware contains both the radio chip and the FEM chip, the raw power setting can be
    /// a combination of the radio power register and the FEM gain value.
    ///
    /// @param[in] aInstance               The OpenThread instance structure.
    /// @param[in] aChannel                The radio channel.
    /// @param[in] aActualPower            The actual power in 0.01dBm.
    /// @param[in] aRawPowerSetting        A pointer to the raw power setting byte array.
    /// @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting.
    ///
    /// @retval OT_ERROR_NONE             Successfully added the calibrated power to the power calibration table.
    /// @retval OT_ERROR_NO_BUFS          No available entry in the power calibration table.
    /// @retval OT_ERROR_INVALID_ARGS     The @p aChannel, @p aActualPower or @p aRawPowerSetting is invalid or the
    ///                                   @p aActualPower already exists in the power calibration table.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.
    pub fn otPlatRadioAddCalibratedPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aActualPower: i16,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Clear all calibrated powers from the power calibration table.
    ///
    /// @note This API is an optional radio platform API. It's up to the platform layer to implement it.
    ///
    /// @param[in]  aInstance   The OpenThread instance structure.
    ///
    /// @retval OT_ERROR_NONE             Successfully cleared all calibrated powers from the power calibration table.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.
    pub fn otPlatRadioClearCalibratedPowers(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Set the target power for the given channel.
    ///
    /// @note This API is an optional radio platform API. It's up to the platform layer to implement it.
    ///       If this API is implemented, the function `otPlatRadioSetTransmitPower()` should be disabled.
    ///
    /// The radio driver should set the actual output power to be less than or equal to the @p aTargetPower and as close
    /// as possible to the @p aTargetPower. If the @p aTargetPower is lower than the minimum output power supported
    /// by the platform, the output power should be set to the minimum output power supported by the platform.  If the
    /// @p aTargetPower is higher than the maximum output power supported by the platform, the output power should be
    /// set to the maximum output power supported by the platform. If the @p aTargetPower is set to `INT16_MAX`, the
    /// corresponding channel is disabled.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[in]  aChannel      The radio channel.
    /// @param[in]  aTargetPower  The target power in 0.01dBm.
    ///
    /// @retval  OT_ERROR_NONE             Successfully set the target power.
    /// @retval  OT_ERROR_INVALID_ARGS     The @p aChannel is invalid.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
    pub fn otPlatRadioSetChannelTargetPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: i16,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the raw power setting for the given channel.
    ///
    /// @note OpenThread `src/core/utils` implements a default implementation of the API `otPlatRadioAddCalibratedPower()`,
    ///       `otPlatRadioClearCalibratedPowers()` and `otPlatRadioSetChannelTargetPower()`. This API is provided by
    ///       the default implementation to get the raw power setting for the given channel. If the platform doesn't
    ///       use the default implementation, it can ignore this API.
    ///
    /// Platform radio layer should parse the raw power setting based on the radio layer defined format and set the
    /// parameters of each radio hardware module.
    ///
    /// @param[in]      aInstance               The OpenThread instance structure.
    /// @param[in]      aChannel                The radio channel.
    /// @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array.
    /// @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting.
    ///                                         On output, a pointer to the length of the raw power setting data.
    ///
    /// @retval  OT_ERROR_NONE          Successfully got the target power.
    /// @retval  OT_ERROR_INVALID_ARGS  The @p aChannel is invalid, @p aRawPowerSetting or @p aRawPowerSettingLength is NULL
    ///                                 or @aRawPowerSettingLength is too short.
    /// @retval  OT_ERROR_NOT_FOUND     The raw power setting for the @p aChannel was not found.
    pub fn otPlatRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aChannel: u8,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
/// @struct otIp6InterfaceIdentifier
///
/// Represents the Interface Identifier of an IPv6 address.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6InterfaceIdentifier {
    ///< The Interface Identifier accessor fields
    pub mFields: otIp6InterfaceIdentifier__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6InterfaceIdentifier__bindgen_ty_1 {
    ///< 8-bit fields
    pub m8: [u8; 8usize],
    ///< 16-bit fields
    pub m16: [u16; 4usize],
    ///< 32-bit fields
    pub m32: [u32; 2usize],
}
/// @struct otIp6NetworkPrefix
///
/// Represents the Network Prefix of an IPv6 address (most significant 64 bits of the address).
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6NetworkPrefix {
    ///< The Network Prefix.
    pub m8: [u8; 8usize],
}
/// @struct otIp6AddressComponents
///
/// Represents the components of an IPv6 address.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6AddressComponents {
    ///< The Network Prefix (most significant 64 bits of the address)
    pub mNetworkPrefix: otIp6NetworkPrefix,
    ///< The Interface Identifier (least significant 64 bits of the address)
    pub mIid: otIp6InterfaceIdentifier,
}
/// @struct otIp6Address
///
/// Represents an IPv6 address.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Address {
    ///< IPv6 accessor fields
    pub mFields: otIp6Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6Address__bindgen_ty_1 {
    ///< 8-bit fields
    pub m8: [u8; 16usize],
    ///< 16-bit fields
    pub m16: [u16; 8usize],
    ///< 32-bit fields
    pub m32: [u32; 4usize],
    ///< IPv6 address components
    pub mComponents: otIp6AddressComponents,
}
/// @struct otIp6Prefix
///
/// Represents an IPv6 prefix.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Prefix {
    ///< The IPv6 prefix.
    pub mPrefix: otIp6Address,
    ///< The IPv6 prefix length (in bits).
    pub mLength: u8,
}
///< Thread assigned address (ALOC, RLOC, MLEID, etc)
pub const OT_ADDRESS_ORIGIN_THREAD: _bindgen_ty_7 = 0;
///< SLAAC assigned address
pub const OT_ADDRESS_ORIGIN_SLAAC: _bindgen_ty_7 = 1;
///< DHCPv6 assigned address
pub const OT_ADDRESS_ORIGIN_DHCPV6: _bindgen_ty_7 = 2;
///< Manually assigned address
pub const OT_ADDRESS_ORIGIN_MANUAL: _bindgen_ty_7 = 3;
/// IPv6 Address origins
pub type _bindgen_ty_7 = ::core::ffi::c_uint;
/// Represents an IPv6 network interface unicast address.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifAddress {
    ///< The IPv6 unicast address.
    pub mAddress: otIp6Address,
    ///< The Prefix length (in bits).
    pub mPrefixLength: u8,
    ///< The IPv6 address origin.
    pub mAddressOrigin: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    ///< A pointer to the next network interface address.
    pub mNext: *const otNetifAddress,
}
impl otNetifAddress {
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mPreferred_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mPreferred_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mValid_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mValid_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mScopeOverrideValid(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mScopeOverrideValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mScopeOverrideValid_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mScopeOverrideValid_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mScopeOverride(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mScopeOverride(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mScopeOverride_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mScopeOverride_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mRloc(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRloc(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mRloc_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mRloc_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mMeshLocal(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMeshLocal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mMeshLocal_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mMeshLocal_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mSrpRegistered(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSrpRegistered(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mSrpRegistered_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mSrpRegistered_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreferred: bool,
        mValid: bool,
        mScopeOverrideValid: bool,
        mScopeOverride: ::core::ffi::c_uint,
        mRloc: bool,
        mMeshLocal: bool,
        mSrpRegistered: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValid: u8 = unsafe { ::core::mem::transmute(mValid) };
            mValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mScopeOverrideValid: u8 = unsafe { ::core::mem::transmute(mScopeOverrideValid) };
            mScopeOverrideValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let mScopeOverride: u32 = unsafe { ::core::mem::transmute(mScopeOverride) };
            mScopeOverride as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mRloc: u8 = unsafe { ::core::mem::transmute(mRloc) };
            mRloc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mMeshLocal: u8 = unsafe { ::core::mem::transmute(mMeshLocal) };
            mMeshLocal as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mSrpRegistered: u8 = unsafe { ::core::mem::transmute(mSrpRegistered) };
            mSrpRegistered as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Represents an IPv6 network interface multicast address.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifMulticastAddress {
    ///< The IPv6 multicast address.
    pub mAddress: otIp6Address,
    ///< A pointer to the next network interface multicast address.
    pub mNext: *const otNetifMulticastAddress,
}
/// Represents an IPv6 socket address.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSockAddr {
    ///< An IPv6 address.
    pub mAddress: otIp6Address,
    ///< A transport-layer port.
    pub mPort: u16,
}
///< Non-ECT
pub const OT_ECN_NOT_CAPABLE: _bindgen_ty_8 = 0;
///< ECT(0)
pub const OT_ECN_CAPABLE_0: _bindgen_ty_8 = 2;
///< ECT(1)
pub const OT_ECN_CAPABLE_1: _bindgen_ty_8 = 1;
///< Congestion encountered (CE)
pub const OT_ECN_MARKED: _bindgen_ty_8 = 3;
/// ECN statuses, represented as in the IP header.
pub type _bindgen_ty_8 = ::core::ffi::c_uint;
/// Represents the local and peer IPv6 socket addresses.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageInfo {
    ///< The local IPv6 address.
    pub mSockAddr: otIp6Address,
    ///< The peer IPv6 address.
    pub mPeerAddr: otIp6Address,
    ///< The local transport-layer port.
    pub mSockPort: u16,
    ///< The peer transport-layer port.
    pub mPeerPort: u16,
    ///< The IPv6 Hop Limit value. Only applies if `mAllowZeroHopLimit` is FALSE.
    ///< If `0`, IPv6 Hop Limit is default value `OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT`.
    ///< Otherwise, specifies the IPv6 Hop Limit.
    pub mHopLimit: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otMessageInfo {
    #[inline]
    pub fn mEcn(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mEcn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mEcn_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mEcn_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsHostInterface(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHostInterface(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsHostInterface_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsHostInterface_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mAllowZeroHopLimit(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllowZeroHopLimit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mAllowZeroHopLimit_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mAllowZeroHopLimit_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mMulticastLoop(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMulticastLoop(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mMulticastLoop_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mMulticastLoop_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mEcn: u8,
        mIsHostInterface: bool,
        mAllowZeroHopLimit: bool,
        mMulticastLoop: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mEcn: u8 = unsafe { ::core::mem::transmute(mEcn) };
            mEcn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsHostInterface: u8 = unsafe { ::core::mem::transmute(mIsHostInterface) };
            mIsHostInterface as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mAllowZeroHopLimit: u8 = unsafe { ::core::mem::transmute(mAllowZeroHopLimit) };
            mAllowZeroHopLimit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mMulticastLoop: u8 = unsafe { ::core::mem::transmute(mMulticastLoop) };
            mMulticastLoop as u64
        });
        __bindgen_bitfield_unit
    }
}
///< IPv6 Hop-by-Hop Option
pub const OT_IP6_PROTO_HOP_OPTS: _bindgen_ty_9 = 0;
///< Transmission Control Protocol
pub const OT_IP6_PROTO_TCP: _bindgen_ty_9 = 6;
///< User Datagram
pub const OT_IP6_PROTO_UDP: _bindgen_ty_9 = 17;
///< IPv6 encapsulation
pub const OT_IP6_PROTO_IP6: _bindgen_ty_9 = 41;
///< Routing Header for IPv6
pub const OT_IP6_PROTO_ROUTING: _bindgen_ty_9 = 43;
///< Fragment Header for IPv6
pub const OT_IP6_PROTO_FRAGMENT: _bindgen_ty_9 = 44;
///< ICMP for IPv6
pub const OT_IP6_PROTO_ICMP6: _bindgen_ty_9 = 58;
///< No Next Header for IPv6
pub const OT_IP6_PROTO_NONE: _bindgen_ty_9 = 59;
///< Destination Options for IPv6
pub const OT_IP6_PROTO_DST_OPTS: _bindgen_ty_9 = 60;
/// Internet Protocol Numbers.
pub type _bindgen_ty_9 = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Brings the IPv6 interface up or down.
    ///
    /// Call this to enable or disable IPv6 communication.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    /// @param[in] aEnabled  TRUE to enable IPv6, FALSE otherwise.
    ///
    /// @retval OT_ERROR_NONE            Successfully brought the IPv6 interface up/down.
    /// @retval OT_ERROR_INVALID_STATE   IPv6 interface is not available since device is operating in raw-link mode
    ///                                  (applicable only when `OPENTHREAD_CONFIG_LINK_RAW_ENABLE` feature is enabled).
    pub fn otIp6SetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
unsafe extern "C" {
    /// Indicates whether or not the IPv6 interface is up.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   The IPv6 interface is enabled.
    /// @retval FALSE  The IPv6 interface is disabled.
    pub fn otIp6IsEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Adds a Network Interface Address to the Thread interface.
    ///
    /// The passed-in instance @p aAddress is copied by the Thread interface. The Thread interface only
    /// supports a fixed number of externally added unicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_UCAST_ADDRS`.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aAddress  A pointer to a Network Interface Address.
    ///
    /// @retval OT_ERROR_NONE          Successfully added (or updated) the Network Interface Address.
    /// @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.
    /// @retval OT_ERROR_NO_BUFS       The Network Interface is already storing the maximum allowed external addresses.
    pub fn otIp6AddUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otNetifAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a Network Interface Address from the Thread interface.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aAddress  A pointer to an IP Address.
    ///
    /// @retval OT_ERROR_NONE          Successfully removed the Network Interface Address.
    /// @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.
    /// @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found.
    pub fn otIp6RemoveUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the list of IPv6 addresses assigned to the Thread interface.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the first Network Interface Address.
    pub fn otIp6GetUnicastAddresses(aInstance: *mut otInstance) -> *const otNetifAddress;
}
unsafe extern "C" {
    /// Indicates whether or not a unicast IPv6 address is assigned to the Thread interface.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aAddress  A pointer to the unicast address.
    ///
    /// @retval TRUE   If @p aAddress is assigned to the Thread interface.
    /// @retval FALSE  If @p aAddress is not assigned to the Thread interface.
    pub fn otIp6HasUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> bool;
}
unsafe extern "C" {
    /// Subscribes the Thread interface to a Network Interface Multicast Address.
    ///
    /// The passed in instance @p aAddress will be copied by the Thread interface. The Thread interface only
    /// supports a fixed number of externally added multicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_MCAST_ADDRS`.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aAddress  A pointer to an IP Address.
    ///
    /// @retval OT_ERROR_NONE           Successfully subscribed to the Network Interface Multicast Address.
    /// @retval OT_ERROR_ALREADY        The multicast address is already subscribed.
    /// @retval OT_ERROR_INVALID_ARGS   The IP Address indicated by @p aAddress is an invalid multicast address.
    /// @retval OT_ERROR_REJECTED       The IP Address indicated by @p aAddress is an internal multicast address.
    /// @retval OT_ERROR_NO_BUFS        The Network Interface is already storing the maximum allowed external multicast
    ///                                 addresses.
    pub fn otIp6SubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Unsubscribes the Thread interface to a Network Interface Multicast Address.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aAddress  A pointer to an IP Address.
    ///
    /// @retval OT_ERROR_NONE          Successfully unsubscribed to the Network Interface Multicast Address.
    /// @retval OT_ERROR_REJECTED      The IP Address indicated by @p aAddress is an internal address.
    /// @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found.
    pub fn otIp6UnsubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the list of IPv6 multicast addresses subscribed to the Thread interface.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the first Network Interface Multicast Address.
    pub fn otIp6GetMulticastAddresses(aInstance: *mut otInstance)
        -> *const otNetifMulticastAddress;
}
unsafe extern "C" {
    /// Allocate a new message buffer for sending an IPv6 message.
    ///
    /// @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to
    /// OT_MESSAGE_PRIORITY_NORMAL by default.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSettings  A pointer to the message settings or NULL to set default settings.
    ///
    /// @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.
    ///
    /// @sa otMessageFree
    pub fn otIp6NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
unsafe extern "C" {
    /// Allocate a new message buffer and write the IPv6 datagram to the message buffer for sending an IPv6 message.
    ///
    /// @note If @p aSettings is NULL, the link layer security is enabled and the message priority is obtained from IPv6
    ///       message itself.
    ///       If @p aSettings is not NULL, the @p aSetting->mPriority is ignored and obtained from IPv6 message itself.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aData        A pointer to the IPv6 datagram buffer.
    /// @param[in]  aDataLength  The size of the IPv6 datagram buffer pointed by @p aData.
    /// @param[in]  aSettings    A pointer to the message settings or NULL to set default settings.
    ///
    /// @returns A pointer to the message or NULL if malformed IPv6 header or insufficient message buffers are available.
    ///
    /// @sa otMessageFree
    pub fn otIp6NewMessageFromBuffer(
        aInstance: *mut otInstance,
        aData: *const u8,
        aDataLength: u16,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
/// Pointer is called when an IPv6 datagram is received.
///
/// @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers
///                       the ownership of the @p aMessage to the receiver of the callback. The message should be
///                       freed by the receiver of the callback after it is processed (see otMessageFree()).
/// @param[in]  aContext  A pointer to application-specific context.
pub type otIp6ReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Registers a callback to provide received IPv6 datagrams.
    ///
    /// By default, this callback does not pass Thread control traffic.  See otIp6SetReceiveFilterEnabled() to
    /// change the Thread control traffic filter setting.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aCallback         A pointer to a function that is called when an IPv6 datagram is received or
    ///                               NULL to disable the callback.
    /// @param[in]  aCallbackContext  A pointer to application-specific context.
    ///
    /// @sa otIp6IsReceiveFilterEnabled
    /// @sa otIp6SetReceiveFilterEnabled
    pub fn otIp6SetReceiveCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6ReceiveCallback,
        aCallbackContext: *mut ::core::ffi::c_void,
    );
}
/// Represents IPv6 address information.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIp6AddressInfo {
    ///< A pointer to the IPv6 address.
    pub mAddress: *const otIp6Address,
    ///< The prefix length of mAddress if it is a unicast address.
    pub mPrefixLength: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otIp6AddressInfo {
    #[inline]
    pub fn mScope(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mScope(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mScope_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mScope_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mPreferred_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mPreferred_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mMeshLocal(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMeshLocal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mMeshLocal_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mMeshLocal_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mScope: u8,
        mPreferred: bool,
        mMeshLocal: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mScope: u8 = unsafe { ::core::mem::transmute(mScope) };
            mScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mPreferred: u8 = unsafe { ::core::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mMeshLocal: u8 = unsafe { ::core::mem::transmute(mMeshLocal) };
            mMeshLocal as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Pointer is called when an internal IPv6 address is added or removed.
///
/// @param[in]   aAddressInfo        A pointer to the IPv6 address information.
/// @param[in]   aIsAdded            TRUE if the @p aAddress was added, FALSE if @p aAddress was removed.
/// @param[in]   aContext            A pointer to application-specific context.
pub type otIp6AddressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aAddressInfo: *const otIp6AddressInfo,
        aIsAdded: bool,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Registers a callback to notify internal IPv6 address changes.
    ///
    /// @param[in]   aInstance           A pointer to an OpenThread instance.
    /// @param[in]   aCallback           A pointer to a function that is called when an internal IPv6 address is added or
    ///                                  removed. NULL to disable the callback.
    /// @param[in]   aCallbackContext    A pointer to application-specific context.
    pub fn otIp6SetAddressCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6AddressCallback,
        aCallbackContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Indicates whether or not Thread control traffic is filtered out when delivering IPv6 datagrams
    /// via the callback specified in otIp6SetReceiveCallback().
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns  TRUE if Thread control traffic is filtered out, FALSE otherwise.
    ///
    /// @sa otIp6SetReceiveCallback
    /// @sa otIp6SetReceiveFilterEnabled
    pub fn otIp6IsReceiveFilterEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Sets whether or not Thread control traffic is filtered out when delivering IPv6 datagrams
    /// via the callback specified in otIp6SetReceiveCallback().
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aEnabled  TRUE if Thread control traffic is filtered out, FALSE otherwise.
    ///
    /// @sa otIp6SetReceiveCallback
    /// @sa otIsReceiveIp6FilterEnabled
    pub fn otIp6SetReceiveFilterEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
unsafe extern "C" {
    /// Sends an IPv6 datagram via the Thread interface.
    ///
    /// The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when
    /// processing is complete, including when a value other than `OT_ERROR_NONE` is returned.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aMessage  A pointer to the message buffer containing the IPv6 datagram.
    ///
    /// @retval OT_ERROR_NONE                    Successfully processed the message.
    /// @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing
    /// rules.
    /// @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram.
    /// @retval OT_ERROR_NO_ROUTE                No route to host.
    /// @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address.
    /// @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message.
    /// @retval OT_ERROR_INVALID_ARGS            The message's metadata is invalid, e.g. the message uses
    ///                                          `OT_MESSAGE_ORIGIN_THREAD_NETIF` as the origin.
    pub fn otIp6Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
unsafe extern "C" {
    /// Adds a port to the allowed unsecured port list.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aPort     The port value.
    ///
    /// @retval OT_ERROR_NONE         The port was successfully added to the allowed unsecure port list.
    /// @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).
    /// @retval OT_ERROR_NO_BUFS      The unsecure port list is full.
    pub fn otIp6AddUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
unsafe extern "C" {
    /// Removes a port from the allowed unsecure port list.
    ///
    /// @note This function removes @p aPort by overwriting @p aPort with the element after @p aPort in the internal port
    ///       list. Be careful when calling otIp6GetUnsecurePorts() followed by otIp6RemoveUnsecurePort() to remove unsecure
    ///       ports.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aPort     The port value.
    ///
    /// @retval OT_ERROR_NONE         The port was successfully removed from the allowed unsecure port list.
    /// @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).
    /// @retval OT_ERROR_NOT_FOUND    The port was not found in the unsecure port list.
    pub fn otIp6RemoveUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
unsafe extern "C" {
    /// Removes all ports from the allowed unsecure port list.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    pub fn otIp6RemoveAllUnsecurePorts(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Returns a pointer to the unsecure port list.
    ///
    /// @note Port value 0 is used to indicate an invalid entry.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aNumEntries  The number of entries in the list.
    ///
    /// @returns A pointer to the unsecure port list.
    pub fn otIp6GetUnsecurePorts(aInstance: *mut otInstance, aNumEntries: *mut u8) -> *const u16;
}
unsafe extern "C" {
    /// Test if two IPv6 addresses are the same.
    ///
    /// @param[in]  aFirst   A pointer to the first IPv6 address to compare.
    /// @param[in]  aSecond  A pointer to the second IPv6 address to compare.
    ///
    /// @retval TRUE   The two IPv6 addresses are the same.
    /// @retval FALSE  The two IPv6 addresses are not the same.
    pub fn otIp6IsAddressEqual(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> bool;
}
unsafe extern "C" {
    /// Test if two IPv6 prefixes are the same.
    ///
    /// @param[in]  aFirst   A pointer to the first IPv6 prefix to compare.
    /// @param[in]  aSecond  A pointer to the second IPv6 prefix to compare.
    ///
    /// @retval TRUE   The two IPv6 prefixes are the same.
    /// @retval FALSE  The two IPv6 prefixes are not the same.
    pub fn otIp6ArePrefixesEqual(aFirst: *const otIp6Prefix, aSecond: *const otIp6Prefix) -> bool;
}
unsafe extern "C" {
    /// Converts a human-readable IPv6 address string into a binary representation.
    ///
    /// @param[in]   aString   A pointer to a NULL-terminated string.
    /// @param[out]  aAddress  A pointer to an IPv6 address.
    ///
    /// @retval OT_ERROR_NONE   Successfully parsed @p aString and updated @p aAddress.
    /// @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 address.
    pub fn otIp6AddressFromString(
        aString: *const ::core::ffi::c_char,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts a human-readable IPv6 prefix string into a binary representation.
    ///
    /// The @p aString parameter should be a string in the format "<address>/<plen>", where `<address>` is an IPv6
    /// address and `<plen>` is a prefix length.
    ///
    /// @param[in]   aString  A pointer to a NULL-terminated string.
    /// @param[out]  aPrefix  A pointer to an IPv6 prefix.
    ///
    /// @retval OT_ERROR_NONE   Successfully parsed the string as an IPv6 prefix and updated @p aPrefix.
    /// @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 prefix.
    pub fn otIp6PrefixFromString(
        aString: *const ::core::ffi::c_char,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts a given IPv6 address to a human-readable string.
    ///
    /// The IPv6 address string is formatted as 16 hex values separated by ':' (i.e., "%x:%x:%x:...:%x").
    ///
    /// If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated
    /// but the outputted string is always null-terminated.
    ///
    /// @param[in]  aAddress  A pointer to an IPv6 address (MUST NOT be NULL).
    /// @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).
    /// @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_ADDRESS_STRING_SIZE`.
    pub fn otIp6AddressToString(
        aAddress: *const otIp6Address,
        aBuffer: *mut ::core::ffi::c_char,
        aSize: u16,
    );
}
unsafe extern "C" {
    /// Converts a given IPv6 socket address to a human-readable string.
    ///
    /// The IPv6 socket address string is formatted as [`address`]:`port` where `address` is shown
    /// as 16 hex values separated by `:` and `port` is the port number in decimal format,
    /// for example "[%x:%x:...:%x]:%u".
    ///
    /// If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated
    /// but the outputted string is always null-terminated.
    ///
    /// @param[in]  aSockAddr A pointer to an IPv6 socket address (MUST NOT be NULL).
    /// @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).
    /// @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_SOCK_ADDR_STRING_SIZE`.
    pub fn otIp6SockAddrToString(
        aSockAddr: *const otSockAddr,
        aBuffer: *mut ::core::ffi::c_char,
        aSize: u16,
    );
}
unsafe extern "C" {
    /// Converts a given IPv6 prefix to a human-readable string.
    ///
    /// The IPv6 address string is formatted as "%x:%x:%x:...[::]/plen".
    ///
    /// If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated
    /// but the outputted string is always null-terminated.
    ///
    /// @param[in]  aPrefix   A pointer to an IPv6 prefix (MUST NOT be NULL).
    /// @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).
    /// @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_PREFIX_STRING_SIZE`.
    pub fn otIp6PrefixToString(
        aPrefix: *const otIp6Prefix,
        aBuffer: *mut ::core::ffi::c_char,
        aSize: u16,
    );
}
unsafe extern "C" {
    /// Returns the prefix match length (bits) for two IPv6 addresses.
    ///
    /// @param[in]  aFirst   A pointer to the first IPv6 address.
    /// @param[in]  aSecond  A pointer to the second IPv6 address.
    ///
    /// @returns  The prefix match length in bits.
    pub fn otIp6PrefixMatch(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> u8;
}
unsafe extern "C" {
    /// Gets a prefix with @p aLength from @p aAddress.
    ///
    /// @param[in]  aAddress   A pointer to an IPv6 address.
    /// @param[in]  aLength    The length of prefix in bits.
    /// @param[out] aPrefix    A pointer to output the IPv6 prefix.
    pub fn otIp6GetPrefix(aAddress: *const otIp6Address, aLength: u8, aPrefix: *mut otIp6Prefix);
}
unsafe extern "C" {
    /// Indicates whether or not a given IPv6 address is the Unspecified Address.
    ///
    /// @param[in]  aAddress   A pointer to an IPv6 address.
    ///
    /// @retval TRUE   If the IPv6 address is the Unspecified Address.
    /// @retval FALSE  If the IPv6 address is not the Unspecified Address.
    pub fn otIp6IsAddressUnspecified(aAddress: *const otIp6Address) -> bool;
}
unsafe extern "C" {
    /// Perform OpenThread source address selection.
    ///
    /// @param[in]      aInstance     A pointer to an OpenThread instance.
    /// @param[in,out]  aMessageInfo  A pointer to the message information.
    ///
    /// @retval  OT_ERROR_NONE       Found a source address and is filled into mSockAddr of @p aMessageInfo.
    /// @retval  OT_ERROR_NOT_FOUND  No source address was found and @p aMessageInfo is unchanged.
    pub fn otIp6SelectSourceAddress(
        aInstance: *mut otInstance,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// Indicates whether the SLAAC module is enabled or not.
    ///
    /// `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.
    ///
    /// @retval TRUE    SLAAC module is enabled.
    /// @retval FALSE   SLAAC module is disabled.
    pub fn otIp6IsSlaacEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Enables/disables the SLAAC module.
    ///
    /// `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.
    ///
    /// When SLAAC module is enabled, SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface.
    /// When SLAAC module is disabled any previously added SLAAC address is removed.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    /// @param[in] aEnabled  TRUE to enable, FALSE to disable.
    pub fn otIp6SetSlaacEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
/// Pointer allows user to filter prefixes and not allow an SLAAC address based on a prefix to be added.
///
/// `otIp6SetSlaacPrefixFilter()` can be used to set the filter handler. The filter handler is invoked by SLAAC module
/// when it is about to add a SLAAC address based on a prefix. Its boolean return value determines whether the address
/// is filtered (not added) or not.
///
/// @param[in] aInstance   A pointer to an OpenThread instance.
/// @param[in] aPrefix     A pointer to prefix for which SLAAC address is about to be added.
///
/// @retval TRUE    Indicates that the SLAAC address based on the prefix should be filtered and NOT added.
/// @retval FALSE   Indicates that the SLAAC address based on the prefix should be added.
pub type otIp6SlaacPrefixFilter = ::core::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aPrefix: *const otIp6Prefix) -> bool,
>;
unsafe extern "C" {
    /// Sets the SLAAC module filter handler.
    ///
    /// `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` build-time feature must be enabled.
    ///
    /// The filter handler is called by SLAAC module when it is about to add a SLAAC address based on a prefix to decide
    /// whether the address should be added or not.
    ///
    /// A NULL filter handler disables filtering and allows all SLAAC addresses to be added.
    ///
    /// If this function is not called, the default filter used by SLAAC module will be NULL (filtering is disabled).
    ///
    /// @param[in] aInstance    A pointer to an OpenThread instance.
    /// @param[in] aFilter      A pointer to SLAAC prefix filter handler, or NULL to disable filtering.
    pub fn otIp6SetSlaacPrefixFilter(aInstance: *mut otInstance, aFilter: otIp6SlaacPrefixFilter);
}
/// Pointer is called with results of `otIp6RegisterMulticastListeners`.
///
/// @param[in]  aContext  A pointer to the user context.
/// @param[in]  aError    OT_ERROR_NONE when successfully sent MLR.req and received MLR.rsp,
///                       OT_ERROR_RESPONSE_TIMEOUT when failed to receive MLR.rsp,
///                       OT_ERROR_PARSE when failed to parse MLR.rsp.
/// @param[in]  aMlrStatus         The Multicast Listener Registration status when @p aError is OT_ERROR_NONE.
/// @param[in]  aFailedAddresses   A pointer to the failed IPv6 addresses when @p aError is OT_ERROR_NONE.
/// @param[in]  aFailedAddressNum  The number of failed IPv6 addresses when @p aError is OT_ERROR_NONE.
///
/// @sa otIp6RegisterMulticastListeners
pub type otIp6RegisterMulticastListenersCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::core::ffi::c_void,
        aError: otError,
        aMlrStatus: u8,
        aFailedAddresses: *const otIp6Address,
        aFailedAddressNum: u8,
    ),
>;
unsafe extern "C" {
    /// Registers Multicast Listeners to Primary Backbone Router.
    ///
    /// `OPENTHREAD_CONFIG_TMF_PROXY_MLR_ENABLE` and `OPENTHREAD_CONFIG_COMMISSIONER_ENABLE`
    /// must be enabled.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aAddresses   A Multicast Address Array to register.
    /// @param[in]  aAddressNum  The number of Multicast Address to register (0 if @p aAddresses is NULL).
    /// @param[in]  aTimeout     A pointer to the timeout value (in seconds) to be included in MLR.req. A timeout value of 0
    ///                          removes the corresponding Multicast Listener. If NULL, MLR.req would have no Timeout Tlv by
    ///                          default.
    /// @param[in]  aCallback    A pointer to the callback function.
    /// @param[in]  aContext     A pointer to the user context.
    ///
    /// @retval OT_ERROR_NONE           Successfully sent MLR.req. The @p aCallback will be called iff this method
    ///                                 returns OT_ERROR_NONE.
    /// @retval OT_ERROR_BUSY           If a previous registration was ongoing.
    /// @retval OT_ERROR_INVALID_ARGS   If one or more arguments are invalid.
    /// @retval OT_ERROR_INVALID_STATE  If the device was not in a valid state to send MLR.req (e.g. Commissioner not
    ///                                 started, Primary Backbone Router not found).
    /// @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.
    ///
    /// @sa otIp6RegisterMulticastListenersCallback
    pub fn otIp6RegisterMulticastListeners(
        aInstance: *mut otInstance,
        aAddresses: *const otIp6Address,
        aAddressNum: u8,
        aTimeout: *const u32,
        aCallback: otIp6RegisterMulticastListenersCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets the Mesh Local IID (for test purpose).
    ///
    /// Requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`.
    ///
    /// @param[in]   aInstance   A pointer to an OpenThread instance.
    /// @param[in]   aIid        A pointer to the Mesh Local IID to set.
    ///
    /// @retval  OT_ERROR_NONE           Successfully set the Mesh Local IID.
    /// @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    pub fn otIp6SetMeshLocalIid(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts a given IP protocol number to a human-readable string.
    ///
    /// @param[in] aIpProto   An IP protocol number (`OT_IP6_PROTO_*` enumeration).
    ///
    /// @returns A string representing @p aIpProto.
    pub fn otIp6ProtoToString(aIpProto: u8) -> *const ::core::ffi::c_char;
}
/// Represents the counters for packets and bytes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPacketsAndBytes {
    ///< The number of packets.
    pub mPackets: u64,
    ///< The number of bytes.
    pub mBytes: u64,
}
/// Represents the counters of packets forwarded via Border Routing.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBorderRoutingCounters {
    ///< The counters for inbound unicast.
    pub mInboundUnicast: otPacketsAndBytes,
    ///< The counters for inbound multicast.
    pub mInboundMulticast: otPacketsAndBytes,
    ///< The counters for outbound unicast.
    pub mOutboundUnicast: otPacketsAndBytes,
    ///< The counters for outbound multicast.
    pub mOutboundMulticast: otPacketsAndBytes,
    ///< The counters for inbound Internet when DHCPv6 PD enabled.
    pub mInboundInternet: otPacketsAndBytes,
    ///< The counters for outbound Internet when DHCPv6 PD enabled.
    pub mOutboundInternet: otPacketsAndBytes,
    ///< The number of received RA packets.
    pub mRaRx: u32,
    ///< The number of RA packets successfully transmitted.
    pub mRaTxSuccess: u32,
    ///< The number of RA packets failed to transmit.
    pub mRaTxFailure: u32,
    ///< The number of received RS packets.
    pub mRsRx: u32,
    ///< The number of RS packets successfully transmitted.
    pub mRsTxSuccess: u32,
    ///< The number of RS packets failed to transmit.
    pub mRsTxFailure: u32,
}
unsafe extern "C" {
    /// Gets the Border Routing counters.
    ///
    /// `OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE` build-time feature must be enabled.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Border Routing counters.
    pub fn otIp6GetBorderRoutingCounters(
        aInstance: *mut otInstance,
    ) -> *const otBorderRoutingCounters;
}
unsafe extern "C" {
    /// Resets the Border Routing counters.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otIp6ResetBorderRoutingCounters(aInstance: *mut otInstance);
}
/// This callback allows OpenThread to provide specific handlers for certain UDP messages.
///
/// @retval  true    The message is handled by this receiver and should not be further processed.
/// @retval  false   The message is not handled by this receiver.
pub type otUdpHandler = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::core::ffi::c_void,
        aMessage: *const otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> bool,
>;
/// Represents a UDP receiver.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpReceiver {
    ///< A pointer to the next UDP receiver (internal use only).
    pub mNext: *mut otUdpReceiver,
    ///< A function pointer to the receiver callback.
    pub mHandler: otUdpHandler,
    ///< A pointer to application-specific context.
    pub mContext: *mut ::core::ffi::c_void,
}
unsafe extern "C" {
    /// Adds a UDP receiver.
    ///
    /// @param[in]   aInstance       A pointer to an OpenThread instance.
    /// @param[in]   aUdpReceiver    A pointer to the UDP receiver.
    ///
    /// @retval  OT_ERROR_NONE       The receiver is successfully added.
    /// @retval  OT_ERROR_ALREADY    The UDP receiver was already added.
    pub fn otUdpAddReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a UDP receiver.
    ///
    /// @param[in]   aInstance       A pointer to an OpenThread instance.
    /// @param[in]   aUdpReceiver    A pointer to the UDP receiver.
    ///
    /// @retval  OT_ERROR_NONE       The receiver is successfully removed.
    /// @retval  OT_ERROR_NOT_FOUND  The UDP receiver was not added.
    pub fn otUdpRemoveReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends a UDP message without socket.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aMessage      A pointer to a message without UDP header.
    /// @param[in]  aMessageInfo  A pointer to a message info associated with @p aMessage.
    ///
    /// @retval OT_ERROR_NONE          Successfully enqueued the message into an output interface.
    /// @retval OT_ERROR_NO_BUFS       Insufficient available buffer to add the IPv6 headers.
    /// @retval OT_ERROR_INVALID_ARGS  Invalid arguments are given.
    pub fn otUdpSendDatagram(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
/// This callback allows OpenThread to inform the application of a received UDP message.
pub type otUdpReceive = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::core::ffi::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
/// Represents a UDP socket.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpSocket {
    ///< The local IPv6 socket address.
    pub mSockName: otSockAddr,
    ///< The peer IPv6 socket address.
    pub mPeerName: otSockAddr,
    ///< A function pointer to the application callback.
    pub mHandler: otUdpReceive,
    ///< A pointer to application-specific context.
    pub mContext: *mut ::core::ffi::c_void,
    ///< A handle to platform's UDP.
    pub mHandle: *mut ::core::ffi::c_void,
    ///< A pointer to the next UDP socket (internal use only).
    pub mNext: *mut otUdpSocket,
}
///< Unspecified network interface.
pub const otNetifIdentifier_OT_NETIF_UNSPECIFIED: otNetifIdentifier = 0;
///< The Thread interface.
pub const otNetifIdentifier_OT_NETIF_THREAD: otNetifIdentifier = 1;
///< The Backbone interface.
pub const otNetifIdentifier_OT_NETIF_BACKBONE: otNetifIdentifier = 2;
/// Defines the OpenThread network interface identifiers.
pub type otNetifIdentifier = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Allocate a new message buffer for sending a UDP message.
    ///
    /// @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to
    /// OT_MESSAGE_PRIORITY_NORMAL by default.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSettings  A pointer to the message settings or NULL to use default settings.
    ///
    /// @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.
    ///
    /// @sa otMessageFree
    pub fn otUdpNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
unsafe extern "C" {
    /// Open a UDP/IPv6 socket.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSocket    A pointer to a UDP socket structure.
    /// @param[in]  aCallback  A pointer to the application callback function.
    /// @param[in]  aContext   A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE    Successfully opened the socket.
    /// @retval OT_ERROR_FAILED  Failed to open the socket.
    pub fn otUdpOpen(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aCallback: otUdpReceive,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Check if a UDP socket is open.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSocket    A pointer to a UDP socket structure.
    ///
    /// @returns Whether the UDP socket is open.
    pub fn otUdpIsOpen(aInstance: *mut otInstance, aSocket: *const otUdpSocket) -> bool;
}
unsafe extern "C" {
    /// Close a UDP/IPv6 socket.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSocket    A pointer to a UDP socket structure.
    ///
    /// @retval OT_ERROR_NONE   Successfully closed the socket.
    /// @retval OT_ERROR_FAILED Failed to close UDP Socket.
    pub fn otUdpClose(aInstance: *mut otInstance, aSocket: *mut otUdpSocket) -> otError;
}
unsafe extern "C" {
    /// Bind a UDP/IPv6 socket.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSocket    A pointer to a UDP socket structure.
    /// @param[in]  aSockName  A pointer to an IPv6 socket address structure.
    /// @param[in]  aNetif     The network interface to bind.
    ///
    /// @retval OT_ERROR_NONE   Bind operation was successful.
    /// @retval OT_ERROR_FAILED Failed to bind UDP socket.
    pub fn otUdpBind(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
        aNetif: otNetifIdentifier,
    ) -> otError;
}
unsafe extern "C" {
    /// Connect a UDP/IPv6 socket.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aSocket    A pointer to a UDP socket structure.
    /// @param[in]  aSockName  A pointer to an IPv6 socket address structure.
    ///
    /// @retval OT_ERROR_NONE   Connect operation was successful.
    /// @retval OT_ERROR_FAILED Failed to connect UDP socket.
    pub fn otUdpConnect(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
    ) -> otError;
}
unsafe extern "C" {
    /// Send a UDP/IPv6 message.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aSocket       A pointer to a UDP socket structure.
    /// @param[in]  aMessage      A pointer to a message buffer.
    /// @param[in]  aMessageInfo  A pointer to a message info structure.
    ///
    /// If the return value is OT_ERROR_NONE, OpenThread takes ownership of @p aMessage, and the caller should no longer
    /// reference @p aMessage. If the return value is not OT_ERROR_NONE, the caller retains ownership of @p aMessage,
    /// including freeing @p aMessage if the message buffer is no longer needed.
    ///
    /// @retval OT_ERROR_NONE           The message is successfully scheduled for sending.
    /// @retval OT_ERROR_INVALID_ARGS   Invalid arguments are given.
    /// @retval OT_ERROR_NO_BUFS        Insufficient available buffer to add the UDP and IPv6 headers.
    pub fn otUdpSend(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the head of linked list of UDP Sockets.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the head of UDP Socket linked list.
    pub fn otUdpGetSockets(aInstance: *mut otInstance) -> *mut otUdpSocket;
}
/// Pointer delivers the UDP packet to host and host should send the packet through its own network stack.
///
/// @param[in]  aMessage   A pointer to the UDP Message.
/// @param[in]  aPeerPort  The destination UDP port.
/// @param[in]  aPeerAddr  A pointer to the destination IPv6 address.
/// @param[in]  aSockPort  The source UDP port.
/// @param[in]  aContext   A pointer to application-specific context.
pub type otUdpForwarder = ::core::option::Option<
    unsafe extern "C" fn(
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *mut otIp6Address,
        aSockPort: u16,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Set UDP forward callback to deliver UDP packets to host.
    ///
    /// @param[in]  aInstance            A pointer to an OpenThread instance.
    /// @param[in]  aForwarder           A pointer to a function called to forward UDP packet to host.
    /// @param[in]  aContext             A pointer to application-specific context.
    pub fn otUdpForwardSetForwarder(
        aInstance: *mut otInstance,
        aForwarder: otUdpForwarder,
        aContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Handle a UDP packet received from host.
    ///
    /// @param[in]  aInstance            A pointer to an OpenThread instance.
    /// @param[in]  aMessage             A pointer to the UDP Message.
    /// @param[in]  aPeerPort            The source UDP port.
    /// @param[in]  aPeerAddr            A pointer to the source address.
    /// @param[in]  aSockPort            The destination UDP port.
    ///
    /// @warning No matter the call success or fail, the message is freed.
    pub fn otUdpForwardReceive(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *const otIp6Address,
        aSockPort: u16,
    );
}
unsafe extern "C" {
    /// Determines if the given UDP port is exclusively opened by OpenThread API.
    ///
    /// @param[in]  aInstance            A pointer to an OpenThread instance.
    /// @param[in]  port                 UDP port number to verify.
    ///
    /// @retval true    The port is being used exclusively by OpenThread.
    /// @retval false   The port is not used by any of the OpenThread API or is shared (e.g. is Backbone socket).
    pub fn otUdpIsPortInUse(aInstance: *mut otInstance, port: u16) -> bool;
}
/// @struct otNetworkKey
///
/// Represents a Thread Network Key.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otNetworkKey {
    ///< Byte values
    pub m8: [u8; 16usize],
}
/// This datatype represents KeyRef to NetworkKey.
pub type otNetworkKeyRef = otCryptoKeyRef;
/// Represents a Network Name.
///
/// The `otNetworkName` is a null terminated C string (i.e., `m8` char array MUST end with null char `\0`).
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkName {
    ///< Byte values. The `+ 1` is for null char.
    pub m8: [::core::ffi::c_char; 17usize],
}
/// Represents an Extended PAN ID.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otExtendedPanId {
    ///< Byte values
    pub m8: [u8; 8usize],
}
/// Represents a Mesh Local Prefix.
pub type otMeshLocalPrefix = otIp6NetworkPrefix;
/// Represents PSKc.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otPskc {
    ///< Byte values
    pub m8: [u8; 16usize],
}
/// This datatype represents KeyRef to PSKc.
pub type otPskcRef = otCryptoKeyRef;
/// Represent Security Policy.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSecurityPolicy {
    ///< The value for thrKeyRotation in units of hours.
    pub mRotationTime: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otSecurityPolicy {
    #[inline]
    pub fn mObtainNetworkKeyEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mObtainNetworkKeyEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mObtainNetworkKeyEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mObtainNetworkKeyEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mNativeCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNativeCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mNativeCommissioningEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mNativeCommissioningEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mRoutersEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mRoutersEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mExternalCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mExternalCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mExternalCommissioningEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mExternalCommissioningEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mCommercialCommissioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCommercialCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mCommercialCommissioningEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mCommercialCommissioningEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mAutonomousEnrollmentEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAutonomousEnrollmentEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mAutonomousEnrollmentEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mAutonomousEnrollmentEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mNetworkKeyProvisioningEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkKeyProvisioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mNetworkKeyProvisioningEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mNetworkKeyProvisioningEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mTobleLinkEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mTobleLinkEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mTobleLinkEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mTobleLinkEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mNonCcmRoutersEnabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNonCcmRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mNonCcmRoutersEnabled_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mNonCcmRoutersEnabled_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mVersionThresholdForRouting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mVersionThresholdForRouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mVersionThresholdForRouting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mVersionThresholdForRouting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mObtainNetworkKeyEnabled: bool,
        mNativeCommissioningEnabled: bool,
        mRoutersEnabled: bool,
        mExternalCommissioningEnabled: bool,
        mCommercialCommissioningEnabled: bool,
        mAutonomousEnrollmentEnabled: bool,
        mNetworkKeyProvisioningEnabled: bool,
        mTobleLinkEnabled: bool,
        mNonCcmRoutersEnabled: bool,
        mVersionThresholdForRouting: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mObtainNetworkKeyEnabled: u8 =
                unsafe { ::core::mem::transmute(mObtainNetworkKeyEnabled) };
            mObtainNetworkKeyEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mNativeCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNativeCommissioningEnabled) };
            mNativeCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mRoutersEnabled: u8 = unsafe { ::core::mem::transmute(mRoutersEnabled) };
            mRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mExternalCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mExternalCommissioningEnabled) };
            mExternalCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mCommercialCommissioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mCommercialCommissioningEnabled) };
            mCommercialCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mAutonomousEnrollmentEnabled: u8 =
                unsafe { ::core::mem::transmute(mAutonomousEnrollmentEnabled) };
            mAutonomousEnrollmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mNetworkKeyProvisioningEnabled: u8 =
                unsafe { ::core::mem::transmute(mNetworkKeyProvisioningEnabled) };
            mNetworkKeyProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mTobleLinkEnabled: u8 = unsafe { ::core::mem::transmute(mTobleLinkEnabled) };
            mTobleLinkEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mNonCcmRoutersEnabled: u8 =
                unsafe { ::core::mem::transmute(mNonCcmRoutersEnabled) };
            mNonCcmRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mVersionThresholdForRouting: u8 =
                unsafe { ::core::mem::transmute(mVersionThresholdForRouting) };
            mVersionThresholdForRouting as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Represents Channel Mask.
pub type otChannelMask = u32;
/// Represents presence of different components in Active or Pending Operational Dataset.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otOperationalDatasetComponents {
    ///< TRUE if Active Timestamp is present, FALSE otherwise.
    pub mIsActiveTimestampPresent: bool,
    ///< TRUE if Pending Timestamp is present, FALSE otherwise.
    pub mIsPendingTimestampPresent: bool,
    ///< TRUE if Network Key is present, FALSE otherwise.
    pub mIsNetworkKeyPresent: bool,
    ///< TRUE if Network Name is present, FALSE otherwise.
    pub mIsNetworkNamePresent: bool,
    ///< TRUE if Extended PAN ID is present, FALSE otherwise.
    pub mIsExtendedPanIdPresent: bool,
    ///< TRUE if Mesh Local Prefix is present, FALSE otherwise.
    pub mIsMeshLocalPrefixPresent: bool,
    ///< TRUE if Delay Timer is present, FALSE otherwise.
    pub mIsDelayPresent: bool,
    ///< TRUE if PAN ID is present, FALSE otherwise.
    pub mIsPanIdPresent: bool,
    ///< TRUE if Channel is present, FALSE otherwise.
    pub mIsChannelPresent: bool,
    ///< TRUE if PSKc is present, FALSE otherwise.
    pub mIsPskcPresent: bool,
    ///< TRUE if Security Policy is present, FALSE otherwise.
    pub mIsSecurityPolicyPresent: bool,
    ///< TRUE if Channel Mask is present, FALSE otherwise.
    pub mIsChannelMaskPresent: bool,
    ///< TRUE if Wake-up Channel is present, FALSE otherwise.
    pub mIsWakeupChannelPresent: bool,
}
/// Represents a Thread Dataset timestamp component.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTimestamp {
    pub mSeconds: u64,
    pub mTicks: u16,
    pub mAuthoritative: bool,
}
/// Represents an Active or Pending Operational Dataset.
///
/// Components in Dataset are optional. `mComponents` structure specifies which components are present in the Dataset.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otOperationalDataset {
    ///< Active Timestamp
    pub mActiveTimestamp: otTimestamp,
    ///< Pending Timestamp
    pub mPendingTimestamp: otTimestamp,
    ///< Network Key
    pub mNetworkKey: otNetworkKey,
    ///< Network Name
    pub mNetworkName: otNetworkName,
    ///< Extended PAN ID
    pub mExtendedPanId: otExtendedPanId,
    ///< Mesh Local Prefix
    pub mMeshLocalPrefix: otMeshLocalPrefix,
    ///< Delay Timer
    pub mDelay: u32,
    ///< PAN ID
    pub mPanId: otPanId,
    ///< Channel
    pub mChannel: u16,
    ///< Wake-up Channel
    pub mWakeupChannel: u16,
    ///< PSKc
    pub mPskc: otPskc,
    ///< Security Policy
    pub mSecurityPolicy: otSecurityPolicy,
    ///< Channel Mask
    pub mChannelMask: otChannelMask,
    ///< Specifies which components are set in the Dataset.
    pub mComponents: otOperationalDatasetComponents,
}
/// Represents an Active or Pending Operational Dataset.
///
/// The Operational Dataset is TLV encoded as specified by Thread.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otOperationalDatasetTlvs {
    ///< Operational Dataset TLVs.
    pub mTlvs: [u8; 254usize],
    ///< Size of Operational Dataset in bytes.
    pub mLength: u8,
}
///< meshcop Channel TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNEL: otMeshcopTlvType = 0;
///< meshcop Pan Id TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PANID: otMeshcopTlvType = 1;
///< meshcop Extended Pan Id TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_EXTPANID: otMeshcopTlvType = 2;
///< meshcop Network Name TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKNAME: otMeshcopTlvType = 3;
///< meshcop PSKc TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PSKC: otMeshcopTlvType = 4;
///< meshcop Network Key TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORKKEY: otMeshcopTlvType = 5;
///< meshcop Network Key Sequence TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_NETWORK_KEY_SEQUENCE: otMeshcopTlvType = 6;
///< meshcop Mesh Local Prefix TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_MESHLOCALPREFIX: otMeshcopTlvType = 7;
///< meshcop Steering Data TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STEERING_DATA: otMeshcopTlvType = 8;
///< meshcop Border Agent Locator TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_BORDER_AGENT_RLOC: otMeshcopTlvType = 9;
///< meshcop Commissioner ID TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_ID: otMeshcopTlvType = 10;
///< meshcop Commissioner Session ID TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMM_SESSION_ID: otMeshcopTlvType = 11;
///< meshcop Security Policy TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SECURITYPOLICY: otMeshcopTlvType = 12;
///< meshcop Get TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_GET: otMeshcopTlvType = 13;
///< meshcop Active Timestamp TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ACTIVETIMESTAMP: otMeshcopTlvType = 14;
///< meshcop Commissioner UDP Port TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COMMISSIONER_UDP_PORT: otMeshcopTlvType = 15;
///< meshcop State TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_STATE: otMeshcopTlvType = 16;
///< meshcop Joiner DTLS Encapsulation TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_DTLS: otMeshcopTlvType = 17;
///< meshcop Joiner UDP Port TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_UDP_PORT: otMeshcopTlvType = 18;
///< meshcop Joiner IID TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_IID: otMeshcopTlvType = 19;
///< meshcop Joiner Router Locator TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_RLOC: otMeshcopTlvType = 20;
///< meshcop Joiner Router KEK TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINER_ROUTER_KEK: otMeshcopTlvType = 21;
///< meshcop Provisioning URL TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PROVISIONING_URL: otMeshcopTlvType = 32;
///< meshcop Vendor Name TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_NAME_TLV: otMeshcopTlvType = 33;
///< meshcop Vendor Model TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_MODEL_TLV: otMeshcopTlvType = 34;
///< meshcop Vendor SW Version TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_SW_VERSION_TLV: otMeshcopTlvType = 35;
///< meshcop Vendor Data TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_DATA_TLV: otMeshcopTlvType = 36;
///< meshcop Vendor Stack Version TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_VENDOR_STACK_VERSION_TLV: otMeshcopTlvType = 37;
///< meshcop UDP encapsulation TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_UDP_ENCAPSULATION_TLV: otMeshcopTlvType = 48;
///< meshcop IPv6 address TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_IPV6_ADDRESS_TLV: otMeshcopTlvType = 49;
///< meshcop Pending Timestamp TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PENDINGTIMESTAMP: otMeshcopTlvType = 51;
///< meshcop Delay Timer TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DELAYTIMER: otMeshcopTlvType = 52;
///< meshcop Channel Mask TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_CHANNELMASK: otMeshcopTlvType = 53;
///< meshcop Count TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_COUNT: otMeshcopTlvType = 54;
///< meshcop Period TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_PERIOD: otMeshcopTlvType = 55;
///< meshcop Scan Duration TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_SCAN_DURATION: otMeshcopTlvType = 56;
///< meshcop Energy List TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_ENERGY_LIST: otMeshcopTlvType = 57;
///< meshcop Thread Domain Name TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_THREAD_DOMAIN_NAME: otMeshcopTlvType = 59;
///< meshcop Wake-up Channel TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_WAKEUP_CHANNEL: otMeshcopTlvType = 74;
///< meshcop Discovery Request TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYREQUEST: otMeshcopTlvType = 128;
///< meshcop Discovery Response TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_DISCOVERYRESPONSE: otMeshcopTlvType = 129;
///< meshcop Joiner Advertisement TLV
pub const otMeshcopTlvType_OT_MESHCOP_TLV_JOINERADVERTISEMENT: otMeshcopTlvType = 241;
/// Represents meshcop TLV types.
pub type otMeshcopTlvType = ::core::ffi::c_uint;
/// Pointer is called when a response to a MGMT_SET request is received or times out.
///
/// @param[in]  aResult   A result of the operation.
/// @param[in]  aContext  A pointer to application-specific context.
///
/// @retval  OT_ERROR_NONE              The request was accepted by the leader.
/// @retval  OT_ERROR_REJECTED          The request was rejected by the leader.
/// @retval  OT_ERROR_PARSE             An error occurred during parsing the response.
/// @retval  OT_ERROR_ABORT             The request was reset by peer.
/// @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period.
pub type otDatasetMgmtSetCallback = ::core::option::Option<
    unsafe extern "C" fn(aResult: otError, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Indicates whether a valid network is present in the Active Operational Dataset or not.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns TRUE if a valid network is present in the Active Operational Dataset, FALSE otherwise.
    pub fn otDatasetIsCommissioned(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Gets the Active Operational Dataset.
    ///
    /// @param[in]   aInstance A pointer to an OpenThread instance.
    /// @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.
    /// @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.
    pub fn otDatasetGetActive(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Active Operational Dataset.
    ///
    /// @param[in]   aInstance A pointer to an OpenThread instance.
    /// @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.
    /// @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.
    pub fn otDatasetGetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets the Active Operational Dataset.
    ///
    /// If the dataset does not include an Active Timestamp, the dataset is only partially complete.
    ///
    /// If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to
    /// an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to
    /// attach to a network.
    ///
    /// If channel is not included in the dataset, the device will send MLE Announce messages across different channels to
    /// find neighbors on other channels.
    ///
    /// If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from
    /// its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a
    /// complete Active Dataset.
    ///
    /// This function consistently returns `OT_ERROR_NONE` and can effectively be treated as having a `void` return type.
    /// Previously, other errors (e.g., `OT_ERROR_NOT_IMPLEMENTED`) were allowed for legacy reasons. However, as
    /// non-volatile storage is now mandatory for Thread operation, any failure to save the dataset will trigger an
    /// assertion. The `otError` return type is retained for backward compatibility.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aDataset  A pointer to the Active Operational Dataset.
    ///
    /// @retval OT_ERROR_NONE    Successfully set the Active Operational Dataset.
    pub fn otDatasetSetActive(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets the Active Operational Dataset.
    ///
    /// If the dataset does not include an Active Timestamp, the dataset is only partially complete.
    ///
    /// If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to
    /// an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to
    /// attach to a network.
    ///
    /// If channel is not included in the dataset, the device will send MLE Announce messages across different channels to
    /// find neighbors on other channels.
    ///
    /// If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from
    /// its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a
    /// complete Active Dataset.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aDataset  A pointer to the Active Operational Dataset.
    ///
    /// @retval OT_ERROR_NONE          Successfully set the Active Operational Dataset.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aDataset is invalid. It is too long or contains incorrect TLV formatting.
    pub fn otDatasetSetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Pending Operational Dataset.
    ///
    /// @param[in]   aInstance A pointer to an OpenThread instance.
    /// @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.
    /// @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.
    pub fn otDatasetGetPending(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Pending Operational Dataset.
    ///
    /// @param[in]   aInstance A pointer to an OpenThread instance.
    /// @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.
    /// @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.
    pub fn otDatasetGetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets the Pending Operational Dataset.
    ///
    /// This function consistently returns `OT_ERROR_NONE` and can effectively be treated as having a `void` return type.
    /// Previously, other errors (e.g., `OT_ERROR_NOT_IMPLEMENTED`) were allowed for legacy reasons. However, as
    /// non-volatile storage is now mandatory for Thread operation, any failure to save the dataset will trigger an
    /// assertion. The `otError` return type is retained for backward compatibility.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aDataset  A pointer to the Pending Operational Dataset.
    ///
    /// @retval OT_ERROR_NONE    Successfully set the Pending Operational Dataset.
    pub fn otDatasetSetPending(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets the Pending Operational Dataset.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aDataset  A pointer to the Pending Operational Dataset.
    ///
    /// @retval OT_ERROR_NONE          Successfully set the Pending Operational Dataset.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aDataset is invalid. It is too long or contains incorrect TLV formatting.
    pub fn otDatasetSetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_ACTIVE_GET.
    ///
    /// @param[in]  aInstance           A pointer to an OpenThread instance.
    /// @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.
    /// @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.
    /// @param[in]  aLength             The length of @p aTlvTypes.
    /// @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    pub fn otDatasetSendMgmtActiveGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_ACTIVE_SET.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aDataset   A pointer to operational dataset.
    /// @param[in]  aTlvs      A pointer to TLVs.
    /// @param[in]  aLength    The length of TLVs.
    /// @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.
    /// @param[in]  aContext   A pointer to application-specific context for @p aCallback.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    /// @retval OT_ERROR_BUSY          A previous request is ongoing.
    pub fn otDatasetSendMgmtActiveSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_PENDING_GET.
    ///
    /// @param[in]  aInstance           A pointer to an OpenThread instance.
    /// @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.
    /// @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.
    /// @param[in]  aLength             The length of @p aTlvTypes.
    /// @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    pub fn otDatasetSendMgmtPendingGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_PENDING_SET.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aDataset   A pointer to operational dataset.
    /// @param[in]  aTlvs      A pointer to TLVs.
    /// @param[in]  aLength    The length of TLVs.
    /// @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.
    /// @param[in]  aContext   A pointer to application-specific context for @p aCallback.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    /// @retval OT_ERROR_BUSY          A previous request is ongoing.
    pub fn otDatasetSendMgmtPendingSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Generates PSKc from a given pass-phrase, network name, and extended PAN ID.
    ///
    /// PSKc is used to establish the Commissioner Session.
    ///
    /// @param[in]  aPassPhrase   The commissioning pass-phrase.
    /// @param[in]  aNetworkName  The network name for PSKc computation.
    /// @param[in]  aExtPanId     The extended PAN ID for PSKc computation.
    /// @param[out] aPskc         A pointer to variable to output the generated PSKc.
    ///
    /// @retval OT_ERROR_NONE          Successfully generate PSKc.
    /// @retval OT_ERROR_INVALID_ARGS  If any of the input arguments is invalid.
    pub fn otDatasetGeneratePskc(
        aPassPhrase: *const ::core::ffi::c_char,
        aNetworkName: *const otNetworkName,
        aExtPanId: *const otExtendedPanId,
        aPskc: *mut otPskc,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets an `otNetworkName` instance from a given null terminated C string.
    ///
    /// @p aNameString must follow UTF-8 encoding and the Network Name length must not be longer than
    /// `OT_NETWORK_NAME_MAX_SIZE`.
    ///
    /// @param[out] aNetworkName        A pointer to the `otNetworkName` to set.
    /// @param[in]  aNameString         A name C string.
    ///
    /// @retval OT_ERROR_NONE           Successfully set @p aNetworkName from @p aNameString.
    /// @retval OT_ERROR_INVALID_ARGS   @p aNameStrng is invalid (too long or does not follow UTF-8 encoding).
    pub fn otNetworkNameFromString(
        aNetworkName: *mut otNetworkName,
        aNameString: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Parses an Operational Dataset from a given `otOperationalDatasetTlvs`.
    ///
    /// @param[in]  aDatasetTlvs  A pointer to dataset TLVs.
    /// @param[out] aDataset      A pointer to where the dataset will be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully set @p aDataset from @p aDatasetTlvs.
    /// @retval OT_ERROR_INVALID_ARGS  @p aDatasetTlvs's length is longer than `OT_OPERATIONAL_DATASET_MAX_LENGTH`.
    pub fn otDatasetParseTlvs(
        aDatasetTlvs: *const otOperationalDatasetTlvs,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts a given Operational Dataset to `otOperationalDatasetTlvs`.
    ///
    /// @param[in]  aDataset      An Operational dataset to convert to TLVs.
    /// @param[out] aDatasetTlvs  A pointer to dataset TLVs to return the result.
    pub fn otDatasetConvertToTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    );
}
unsafe extern "C" {
    /// Updates a given Operational Dataset.
    ///
    /// @p aDataset contains the fields to be updated and their new value.
    ///
    /// @param[in]     aDataset      Specifies the set of types and values to update.
    /// @param[in,out] aDatasetTlvs  A pointer to dataset TLVs to update.
    ///
    /// @retval OT_ERROR_NONE          Successfully updated @p aDatasetTlvs.
    /// @retval OT_ERROR_INVALID_ARGS  @p aDataset contains invalid values.
    /// @retval OT_ERROR_NO_BUFS       Not enough space space in @p aDatasetTlvs to apply the update.
    pub fn otDatasetUpdateTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
pub const otJoinerState_OT_JOINER_STATE_IDLE: otJoinerState = 0;
pub const otJoinerState_OT_JOINER_STATE_DISCOVER: otJoinerState = 1;
pub const otJoinerState_OT_JOINER_STATE_CONNECT: otJoinerState = 2;
pub const otJoinerState_OT_JOINER_STATE_CONNECTED: otJoinerState = 3;
pub const otJoinerState_OT_JOINER_STATE_ENTRUST: otJoinerState = 4;
pub const otJoinerState_OT_JOINER_STATE_JOINED: otJoinerState = 5;
/// Defines the Joiner State.
pub type otJoinerState = ::core::ffi::c_uint;
/// Represents a Joiner Discerner.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerDiscerner {
    ///< Discerner value (the lowest `mLength` bits specify the discerner).
    pub mValue: u64,
    ///< Length (number of bits) - must be non-zero and at most `OT_JOINER_MAX_DISCERNER_LENGTH`.
    pub mLength: u8,
}
/// Pointer is called to notify the completion of a join operation.
///
/// @param[in]  aError    OT_ERROR_NONE if the join process succeeded.
///                       OT_ERROR_SECURITY if the join process failed due to security credentials.
///                       OT_ERROR_NOT_FOUND if no joinable network was discovered.
///                       OT_ERROR_RESPONSE_TIMEOUT if a response timed out.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Enables the Thread Joiner role.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aPskd             A pointer to the PSKd.
    /// @param[in]  aProvisioningUrl  A pointer to the Provisioning URL (may be NULL).
    /// @param[in]  aVendorName       A pointer to the Vendor Name (may be NULL).
    /// @param[in]  aVendorModel      A pointer to the Vendor Model (may be NULL).
    /// @param[in]  aVendorSwVersion  A pointer to the Vendor SW Version (may be NULL).
    /// @param[in]  aVendorData       A pointer to the Vendor Data (may be NULL).
    /// @param[in]  aCallback         A pointer to a function that is called when the join operation completes.
    /// @param[in]  aContext          A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE              Successfully started the Joiner role.
    /// @retval OT_ERROR_BUSY              The previous attempt is still on-going.
    /// @retval OT_ERROR_INVALID_ARGS      @p aPskd or @p aProvisioningUrl is invalid.
    /// @retval OT_ERROR_INVALID_STATE     The IPv6 stack is not enabled or Thread stack is fully enabled.
    pub fn otJoinerStart(
        aInstance: *mut otInstance,
        aPskd: *const ::core::ffi::c_char,
        aProvisioningUrl: *const ::core::ffi::c_char,
        aVendorName: *const ::core::ffi::c_char,
        aVendorModel: *const ::core::ffi::c_char,
        aVendorSwVersion: *const ::core::ffi::c_char,
        aVendorData: *const ::core::ffi::c_char,
        aCallback: otJoinerCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Disables the Thread Joiner role.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otJoinerStop(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets the Joiner State.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns The joiner state.
    pub fn otJoinerGetState(aInstance: *mut otInstance) -> otJoinerState;
}
unsafe extern "C" {
    /// Gets the Joiner ID.
    ///
    /// If a Joiner Discerner is not set, Joiner ID is the first 64 bits of the result of computing SHA-256 over
    /// factory-assigned IEEE EUI-64. Otherwise the Joiner ID is calculated from the Joiner Discerner value.
    ///
    /// The Joiner ID is also used as the device's IEEE 802.15.4 Extended Address during the commissioning process.
    ///
    /// @param[in]   aInstance  A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to the Joiner ID.
    pub fn otJoinerGetId(aInstance: *mut otInstance) -> *const otExtAddress;
}
unsafe extern "C" {
    /// Sets the Joiner Discerner.
    ///
    /// The Joiner Discerner is used to calculate the Joiner ID during the Thread Commissioning process. For more
    /// information, refer to #otJoinerGetId.
    /// @note The Joiner Discerner takes the place of the Joiner EUI-64 during the joiner session of Thread Commissioning.
    ///
    /// @param[in]   aInstance    A pointer to the OpenThread instance.
    /// @param[in]   aDiscerner   A pointer to a Joiner Discerner. If NULL clears any previously set discerner.
    ///
    /// @retval OT_ERROR_NONE           The Joiner Discerner updated successfully.
    /// @retval OT_ERROR_INVALID_ARGS   @p aDiscerner is not valid (specified length is not within valid range).
    /// @retval OT_ERROR_INVALID_STATE  There is an ongoing Joining process so Joiner Discerner could not be changed.
    pub fn otJoinerSetDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *mut otJoinerDiscerner,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Joiner Discerner. For more information, refer to #otJoinerSetDiscerner.
    ///
    /// @param[in]   aInstance       A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to Joiner Discerner or NULL if none is set.
    pub fn otJoinerGetDiscerner(aInstance: *mut otInstance) -> *const otJoinerDiscerner;
}
unsafe extern "C" {
    /// Converts a given joiner state enumeration value to a human-readable string.
    ///
    /// @param[in] aState   The joiner state.
    ///
    /// @returns A human-readable string representation of @p aState.
    pub fn otJoinerStateToString(aState: otJoinerState) -> *const ::core::ffi::c_char;
}
///< Commissioner role is disabled.
pub const otCommissionerState_OT_COMMISSIONER_STATE_DISABLED: otCommissionerState = 0;
///< Currently petitioning to become a Commissioner.
pub const otCommissionerState_OT_COMMISSIONER_STATE_PETITION: otCommissionerState = 1;
///< Commissioner role is active.
pub const otCommissionerState_OT_COMMISSIONER_STATE_ACTIVE: otCommissionerState = 2;
/// Defines the Commissioner State.
pub type otCommissionerState = ::core::ffi::c_uint;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_START: otCommissionerJoinerEvent = 0;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_CONNECTED: otCommissionerJoinerEvent = 1;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_FINALIZE: otCommissionerJoinerEvent = 2;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_END: otCommissionerJoinerEvent = 3;
pub const otCommissionerJoinerEvent_OT_COMMISSIONER_JOINER_REMOVED: otCommissionerJoinerEvent = 4;
/// Defines a Joiner Event on the Commissioner.
pub type otCommissionerJoinerEvent = ::core::ffi::c_uint;
/// Represents the steering data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSteeringData {
    ///< Length of steering data (bytes)
    pub mLength: u8,
    ///< Byte values
    pub m8: [u8; 16usize],
}
/// Represents a Commissioning Dataset.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCommissioningDataset {
    ///< Border Router RLOC16
    pub mLocator: u16,
    ///< Commissioner Session Id
    pub mSessionId: u16,
    ///< Steering Data
    pub mSteeringData: otSteeringData,
    ///< Joiner UDP Port
    pub mJoinerUdpPort: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otCommissioningDataset {
    #[inline]
    pub fn mIsLocatorSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsLocatorSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsLocatorSet_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsLocatorSet_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsSessionIdSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSessionIdSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsSessionIdSet_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsSessionIdSet_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsSteeringDataSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSteeringDataSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsSteeringDataSet_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsSteeringDataSet_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsJoinerUdpPortSet(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinerUdpPortSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsJoinerUdpPortSet_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsJoinerUdpPortSet_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mHasExtraTlv(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mHasExtraTlv(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mHasExtraTlv_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mHasExtraTlv_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsLocatorSet: bool,
        mIsSessionIdSet: bool,
        mIsSteeringDataSet: bool,
        mIsJoinerUdpPortSet: bool,
        mHasExtraTlv: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsLocatorSet: u8 = unsafe { ::core::mem::transmute(mIsLocatorSet) };
            mIsLocatorSet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsSessionIdSet: u8 = unsafe { ::core::mem::transmute(mIsSessionIdSet) };
            mIsSessionIdSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsSteeringDataSet: u8 = unsafe { ::core::mem::transmute(mIsSteeringDataSet) };
            mIsSteeringDataSet as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsJoinerUdpPortSet: u8 = unsafe { ::core::mem::transmute(mIsJoinerUdpPortSet) };
            mIsJoinerUdpPortSet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mHasExtraTlv: u8 = unsafe { ::core::mem::transmute(mHasExtraTlv) };
            mHasExtraTlv as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Represents a Joiner PSKd.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerPskd {
    ///< Char string array (must be null terminated - +1 is for null char).
    pub m8: [::core::ffi::c_char; 33usize],
}
///< Accept any Joiner (no EUI64 or Discerner is specified).
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_ANY: otJoinerInfoType = 0;
///< Joiner EUI-64 is specified (`mSharedId.mEui64` in `otJoinerInfo`).
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_EUI64: otJoinerInfoType = 1;
///< Joiner Discerner is specified (`mSharedId.mDiscerner` in `otJoinerInfo`).
pub const otJoinerInfoType_OT_JOINER_INFO_TYPE_DISCERNER: otJoinerInfoType = 2;
/// Defines a Joiner Info Type.
pub type otJoinerInfoType = ::core::ffi::c_uint;
/// Represents a Joiner Info.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerInfo {
    ///< Joiner type.
    pub mType: otJoinerInfoType,
    ///< Shared fields
    pub mSharedId: otJoinerInfo__bindgen_ty_1,
    ///< Joiner PSKd
    pub mPskd: otJoinerPskd,
    ///< Joiner expiration time in msec
    pub mExpirationTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otJoinerInfo__bindgen_ty_1 {
    ///< Joiner EUI64 (when `mType` is `OT_JOINER_INFO_TYPE_EUI64`)
    pub mEui64: otExtAddress,
    ///< Joiner Discerner (when `mType` is `OT_JOINER_INFO_TYPE_DISCERNER`)
    pub mDiscerner: otJoinerDiscerner,
}
/// Pointer is called whenever the commissioner state changes.
///
/// @param[in]  aState    The Commissioner state.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otCommissionerStateCallback = ::core::option::Option<
    unsafe extern "C" fn(aState: otCommissionerState, aContext: *mut ::core::ffi::c_void),
>;
/// Pointer is called whenever the joiner state changes.
///
/// @param[in]  aEvent       The joiner event type.
/// @param[in]  aJoinerInfo  A pointer to the Joiner Info.
/// @param[in]  aJoinerId    A pointer to the Joiner ID (if not known, it will be NULL).
/// @param[in]  aContext     A pointer to application-specific context.
pub type otCommissionerJoinerCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aEvent: otCommissionerJoinerEvent,
        aJoinerInfo: *const otJoinerInfo,
        aJoinerId: *const otExtAddress,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Enables the Thread Commissioner role.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aStateCallback    A pointer to a function that is called when the commissioner state changes.
    /// @param[in]  aJoinerCallback   A pointer to a function that is called with a joiner event occurs.
    /// @param[in]  aCallbackContext  A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE           Successfully started the Commissioner service.
    /// @retval OT_ERROR_ALREADY        Commissioner is already started.
    /// @retval OT_ERROR_INVALID_STATE  Device is not currently attached to a network.
    pub fn otCommissionerStart(
        aInstance: *mut otInstance,
        aStateCallback: otCommissionerStateCallback,
        aJoinerCallback: otCommissionerJoinerCallback,
        aCallbackContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Disables the Thread Commissioner role.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE     Successfully stopped the Commissioner service.
    /// @retval OT_ERROR_ALREADY  Commissioner is already stopped.
    pub fn otCommissionerStop(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Returns the Commissioner Id.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    ///
    /// @returns The Commissioner Id.
    pub fn otCommissionerGetId(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Sets the Commissioner Id.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aId           A pointer to a string character array. Must be null terminated.
    ///
    /// @retval OT_ERROR_NONE            Successfully set the Commissioner Id.
    /// @retval OT_ERROR_INVALID_ARGS    Given name is too long.
    /// @retval OT_ERROR_INVALID_STATE   The commissioner is active and id cannot be changed.
    pub fn otCommissionerSetId(
        aInstance: *mut otInstance,
        aId: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Adds a Joiner entry.
    ///
    /// @param[in]  aInstance          A pointer to an OpenThread instance.
    /// @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.
    /// @param[in]  aPskd              A pointer to the PSKd.
    /// @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.
    ///
    /// @retval OT_ERROR_NONE          Successfully added the Joiner.
    /// @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.
    /// @retval OT_ERROR_INVALID_ARGS  @p aEui64 or @p aPskd is invalid.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerAddJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
        aPskd: *const ::core::ffi::c_char,
        aTimeout: u32,
    ) -> otError;
}
unsafe extern "C" {
    /// Adds a Joiner entry with a given Joiner Discerner value.
    ///
    /// @param[in]  aInstance          A pointer to an OpenThread instance.
    /// @param[in]  aDiscerner         A pointer to the Joiner Discerner.
    /// @param[in]  aPskd              A pointer to the PSKd.
    /// @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.
    ///
    /// @retval OT_ERROR_NONE          Successfully added the Joiner.
    /// @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.
    /// @retval OT_ERROR_INVALID_ARGS  @p aDiscerner or @p aPskd is invalid.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerAddJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
        aPskd: *const ::core::ffi::c_char,
        aTimeout: u32,
    ) -> otError;
}
unsafe extern "C" {
    /// Get joiner info at aIterator position.
    ///
    /// @param[in]      aInstance   A pointer to instance.
    /// @param[in,out]  aIterator   A pointer to the Joiner Info iterator context.
    /// @param[out]     aJoiner     A reference to Joiner info.
    ///
    /// @retval OT_ERROR_NONE       Successfully get the Joiner info.
    /// @retval OT_ERROR_NOT_FOUND  Not found next Joiner.
    pub fn otCommissionerGetNextJoinerInfo(
        aInstance: *mut otInstance,
        aIterator: *mut u16,
        aJoiner: *mut otJoinerInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a Joiner entry.
    ///
    /// @param[in]  aInstance          A pointer to an OpenThread instance.
    /// @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.
    ///
    /// @retval OT_ERROR_NONE          Successfully removed the Joiner.
    /// @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.
    /// @retval OT_ERROR_INVALID_ARGS  @p aEui64 is invalid.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerRemoveJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a Joiner entry.
    ///
    /// @param[in]  aInstance          A pointer to an OpenThread instance.
    /// @param[in]  aDiscerner         A pointer to the Joiner Discerner.
    ///
    /// @retval OT_ERROR_NONE          Successfully removed the Joiner.
    /// @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.
    /// @retval OT_ERROR_INVALID_ARGS  @p aDiscerner is invalid.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerRemoveJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Provisioning URL.
    ///
    /// @param[in]    aInstance       A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the URL string.
    pub fn otCommissionerGetProvisioningUrl(
        aInstance: *mut otInstance,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Sets the Provisioning URL.
    ///
    /// @param[in]  aInstance             A pointer to an OpenThread instance.
    /// @param[in]  aProvisioningUrl      A pointer to the Provisioning URL (may be NULL to set as empty string).
    ///
    /// @retval OT_ERROR_NONE          Successfully set the Provisioning URL.
    /// @retval OT_ERROR_INVALID_ARGS  @p aProvisioningUrl is invalid (too long).
    pub fn otCommissionerSetProvisioningUrl(
        aInstance: *mut otInstance,
        aProvisioningUrl: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends an Announce Begin message.
    ///
    /// @param[in]  aInstance             A pointer to an OpenThread instance.
    /// @param[in]  aChannelMask          The channel mask value.
    /// @param[in]  aCount                The number of Announcement messages per channel.
    /// @param[in]  aPeriod               The time between two successive MLE Announce transmissions (in milliseconds).
    /// @param[in]  aAddress              A pointer to the IPv6 destination.
    ///
    /// @retval OT_ERROR_NONE          Successfully enqueued the Announce Begin message.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Announce Begin message.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerAnnounceBegin(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aAddress: *const otIp6Address,
    ) -> otError;
}
/// Pointer is called when the Commissioner receives an Energy Report.
///
/// @param[in]  aChannelMask       The channel mask value.
/// @param[in]  aEnergyList        A pointer to the energy measurement list.
/// @param[in]  aEnergyListLength  Number of entries in @p aEnergyListLength.
/// @param[in]  aContext           A pointer to application-specific context.
pub type otCommissionerEnergyReportCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aChannelMask: u32,
        aEnergyList: *const u8,
        aEnergyListLength: u8,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Sends an Energy Scan Query message.
    ///
    /// @param[in]  aInstance             A pointer to an OpenThread instance.
    /// @param[in]  aChannelMask          The channel mask value.
    /// @param[in]  aCount                The number of energy measurements per channel.
    /// @param[in]  aPeriod               The time between energy measurements (milliseconds).
    /// @param[in]  aScanDuration         The scan duration for each energy measurement (milliseconds).
    /// @param[in]  aAddress              A pointer to the IPv6 destination.
    /// @param[in]  aCallback             A pointer to a function called on receiving an Energy Report message.
    /// @param[in]  aContext              A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE          Successfully enqueued the Energy Scan Query message.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Energy Scan Query message.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerEnergyScan(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aScanDuration: u16,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerEnergyReportCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
/// Pointer is called when the Commissioner receives a PAN ID Conflict message.
///
/// @param[in]  aPanId             The PAN ID value.
/// @param[in]  aChannelMask       The channel mask value.
/// @param[in]  aContext           A pointer to application-specific context.
pub type otCommissionerPanIdConflictCallback = ::core::option::Option<
    unsafe extern "C" fn(aPanId: u16, aChannelMask: u32, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Sends a PAN ID Query message.
    ///
    /// @param[in]  aInstance             A pointer to an OpenThread instance.
    /// @param[in]  aPanId                The PAN ID to query.
    /// @param[in]  aChannelMask          The channel mask value.
    /// @param[in]  aAddress              A pointer to the IPv6 destination.
    /// @param[in]  aCallback             A pointer to a function called on receiving a PAN ID Conflict message.
    /// @param[in]  aContext              A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE          Successfully enqueued the PAN ID Query message.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate a PAN ID Query message.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    ///
    /// @note Only use this after successfully starting the Commissioner role with otCommissionerStart().
    pub fn otCommissionerPanIdQuery(
        aInstance: *mut otInstance,
        aPanId: u16,
        aChannelMask: u32,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerPanIdConflictCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_COMMISSIONER_GET.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aTlvs      A pointer to TLVs.
    /// @param[in]  aLength    The length of TLVs.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    pub fn otCommissionerSendMgmtGet(
        aInstance: *mut otInstance,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
unsafe extern "C" {
    /// Sends MGMT_COMMISSIONER_SET.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aDataset   A pointer to commissioning dataset.
    /// @param[in]  aTlvs      A pointer to TLVs.
    /// @param[in]  aLength    The length of TLVs.
    ///
    /// @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.
    /// @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.
    /// @retval OT_ERROR_INVALID_STATE The commissioner is not active.
    pub fn otCommissionerSendMgmtSet(
        aInstance: *mut otInstance,
        aDataset: *const otCommissioningDataset,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
unsafe extern "C" {
    /// Returns the Commissioner Session ID.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns The current commissioner session id.
    pub fn otCommissionerGetSessionId(aInstance: *mut otInstance) -> u16;
}
unsafe extern "C" {
    /// Returns the Commissioner State.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @retval OT_COMMISSIONER_STATE_DISABLED  Commissioner disabled.
    /// @retval OT_COMMISSIONER_STATE_PETITION  Becoming the commissioner.
    /// @retval OT_COMMISSIONER_STATE_ACTIVE    Commissioner enabled.
    pub fn otCommissionerGetState(aInstance: *mut otInstance) -> otCommissionerState;
}
pub type otMacFilterIterator = u8;
///< Address filter is disabled.
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DISABLED: otMacFilterAddressMode = 0;
///< Allowlist address filter mode is enabled.
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_ALLOWLIST: otMacFilterAddressMode = 1;
///< Denylist address filter mode is enabled.
pub const otMacFilterAddressMode_OT_MAC_FILTER_ADDRESS_MODE_DENYLIST: otMacFilterAddressMode = 2;
/// Defines address mode of the mac filter.
pub type otMacFilterAddressMode = ::core::ffi::c_uint;
/// Represents a Mac Filter entry.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacFilterEntry {
    ///< IEEE 802.15.4 Extended Address
    pub mExtAddress: otExtAddress,
    ///< Received signal strength
    pub mRssIn: i8,
}
/// Represents the MAC layer counters.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacCounters {
    /// The total number of unique MAC frame transmission requests.
    ///
    /// Note that this counter is incremented for each MAC transmission request only by one,
    /// regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions.
    ///
    /// This increment rule applies to the following counters:
    ///   - @p mTxUnicast
    ///   - @p mTxBroadcast
    ///   - @p mTxAckRequested
    ///   - @p mTxNoAckRequested
    ///   - @p mTxData
    ///   - @p mTxDataPoll
    ///   - @p mTxBeacon
    ///   - @p mTxBeaconRequest
    ///   - @p mTxOther
    ///   - @p mTxErrAbort
    ///   - @p mTxErrBusyChannel
    ///
    /// The following equations are valid:
    ///   - @p mTxTotal = @p mTxUnicast + @p mTxBroadcast
    ///   - @p mTxTotal = @p mTxAckRequested + @p mTxNoAckRequested
    ///   - @p mTxTotal = @p mTxData + @p mTxDataPoll + @p mTxBeacon + @p mTxBeaconRequest + @p mTxOther
    pub mTxTotal: u32,
    /// The total number of unique unicast MAC frame transmission requests.
    pub mTxUnicast: u32,
    /// The total number of unique broadcast MAC frame transmission requests.
    pub mTxBroadcast: u32,
    /// The total number of unique MAC frame transmission requests with requested acknowledgment.
    pub mTxAckRequested: u32,
    /// The total number of unique MAC frame transmission requests that were acked.
    pub mTxAcked: u32,
    /// The total number of unique MAC frame transmission requests without requested acknowledgment.
    pub mTxNoAckRequested: u32,
    /// The total number of unique MAC Data frame transmission requests.
    pub mTxData: u32,
    /// The total number of unique MAC Data Poll frame transmission requests.
    pub mTxDataPoll: u32,
    /// The total number of unique MAC Beacon frame transmission requests.
    pub mTxBeacon: u32,
    /// The total number of unique MAC Beacon Request frame transmission requests.
    pub mTxBeaconRequest: u32,
    /// The total number of unique other MAC frame transmission requests.
    ///
    /// This counter is currently used for counting out-of-band frames.
    pub mTxOther: u32,
    /// The total number of MAC retransmission attempts.
    ///
    /// Note that this counter is incremented by one for each retransmission attempt that may be
    /// triggered by lack of acknowledgement, CSMA/CA failure, or other type of transmission error.
    /// The @p mTxRetry counter is incremented both for unicast and broadcast MAC frames.
    ///
    /// Modify the following configuration parameters to control the amount of retransmissions in the system:
    ///
    /// - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_DIRECT
    /// - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_INDIRECT
    /// - OPENTHREAD_CONFIG_MAC_TX_NUM_BCAST
    /// - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_DIRECT
    /// - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_INDIRECT
    ///
    /// Currently, this counter is invalid if the platform's radio driver capability includes
    /// @ref OT_RADIO_CAPS_TRANSMIT_RETRIES.
    pub mTxRetry: u32,
    /// The total number of unique MAC transmission packets that meet maximal retry limit for direct packets.
    pub mTxDirectMaxRetryExpiry: u32,
    /// The total number of unique MAC transmission packets that meet maximal retry limit for indirect packets.
    pub mTxIndirectMaxRetryExpiry: u32,
    /// The total number of CCA failures.
    ///
    /// The meaning of this counter can be different and it depends on the platform's radio driver capabilities.
    ///
    /// If @ref OT_RADIO_CAPS_CSMA_BACKOFF is enabled, this counter represents the total number of full CSMA/CA
    /// failed attempts and it is incremented by one also for each retransmission (in case of a CSMA/CA fail).
    ///
    /// If @ref OT_RADIO_CAPS_TRANSMIT_RETRIES is enabled, this counter represents the total number of full CSMA/CA
    /// failed attempts and it is incremented by one for each individual data frame request (regardless of the
    /// amount of retransmissions).
    pub mTxErrCca: u32,
    /// The total number of unique MAC transmission request failures cause by an abort error.
    pub mTxErrAbort: u32,
    /// The total number of unique MAC transmission requests failures caused by a busy channel (a CSMA/CA fail).
    pub mTxErrBusyChannel: u32,
    /// The total number of received frames.
    ///
    /// This counter counts all frames reported by the platform's radio driver, including frames
    /// that were dropped, for example because of an FCS error.
    pub mRxTotal: u32,
    /// The total number of unicast frames received.
    pub mRxUnicast: u32,
    /// The total number of broadcast frames received.
    pub mRxBroadcast: u32,
    /// The total number of MAC Data frames received.
    pub mRxData: u32,
    /// The total number of MAC Data Poll frames received.
    pub mRxDataPoll: u32,
    /// The total number of MAC Beacon frames received.
    pub mRxBeacon: u32,
    /// The total number of MAC Beacon Request frames received.
    pub mRxBeaconRequest: u32,
    /// The total number of other types of frames received.
    pub mRxOther: u32,
    /// The total number of frames dropped by MAC Filter module, for example received from denylisted node.
    pub mRxAddressFiltered: u32,
    /// The total number of frames dropped by destination address check, for example received frame for other node.
    pub mRxDestAddrFiltered: u32,
    /// The total number of frames dropped due to duplication, that is when the frame has been already received.
    ///
    /// This counter may be incremented, for example when ACK frame generated by the receiver hasn't reached
    /// transmitter node which performed retransmission.
    pub mRxDuplicated: u32,
    /// The total number of frames dropped because of missing or malformed content.
    pub mRxErrNoFrame: u32,
    /// The total number of frames dropped due to unknown neighbor.
    pub mRxErrUnknownNeighbor: u32,
    /// The total number of frames dropped due to invalid source address.
    pub mRxErrInvalidSrcAddr: u32,
    /// The total number of frames dropped due to security error.
    ///
    /// This counter may be incremented, for example when lower than expected Frame Counter is used
    /// to encrypt the frame.
    pub mRxErrSec: u32,
    /// The total number of frames dropped due to invalid FCS.
    pub mRxErrFcs: u32,
    /// The total number of frames dropped due to other error.
    pub mRxErrOther: u32,
}
/// Represents a received IEEE 802.15.4 Beacon.
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otActiveScanResult {
    ///< IEEE 802.15.4 Extended Address
    pub mExtAddress: otExtAddress,
    ///< Thread Network Name
    pub mNetworkName: otNetworkName,
    ///< Thread Extended PAN ID
    pub mExtendedPanId: otExtendedPanId,
    ///< Steering Data
    pub mSteeringData: otSteeringData,
    ///< IEEE 802.15.4 PAN ID
    pub mPanId: u16,
    ///< Joiner UDP Port
    pub mJoinerUdpPort: u16,
    ///< IEEE 802.15.4 Channel
    pub mChannel: u8,
    ///< RSSI (dBm)
    pub mRssi: i8,
    ///< LQI
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otActiveScanResult {
    #[inline]
    pub fn mVersion(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mVersion_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mVersion_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsNative(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNative(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsNative_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsNative_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mDiscover(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDiscover(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mDiscover_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mDiscover_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsJoinable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsJoinable_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsJoinable_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mVersion: ::core::ffi::c_uint,
        mIsNative: bool,
        mDiscover: bool,
        mIsJoinable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u32 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsNative: u8 = unsafe { ::core::mem::transmute(mIsNative) };
            mIsNative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mDiscover: u8 = unsafe { ::core::mem::transmute(mDiscover) };
            mDiscover as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsJoinable: u8 = unsafe { ::core::mem::transmute(mIsJoinable) };
            mIsJoinable as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Represents an energy scan result.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otEnergyScanResult {
    ///< IEEE 802.15.4 Channel
    pub mChannel: u8,
    ///< The max RSSI (dBm)
    pub mMaxRssi: i8,
}
/// Pointer is called during an IEEE 802.15.4 Active Scan when an IEEE 802.15.4 Beacon is received or
/// the scan completes.
///
/// @param[in]  aResult   A valid pointer to the beacon information or NULL when the active scan completes.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otHandleActiveScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otActiveScanResult, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Starts an IEEE 802.15.4 Active Scan
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aScanChannels     A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).
    /// @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.
    /// @param[in]  aCallback         A pointer to a function called on receiving a beacon or scan completes.
    /// @param[in]  aCallbackContext  A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE  Accepted the Active Scan request.
    /// @retval OT_ERROR_BUSY  Already performing an Active Scan.
    pub fn otLinkActiveScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Indicates whether or not an IEEE 802.15.4 Active Scan is currently in progress.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns true if an IEEE 802.15.4 Active Scan is in progress, false otherwise.
    pub fn otLinkIsActiveScanInProgress(aInstance: *mut otInstance) -> bool;
}
/// Pointer is called during an IEEE 802.15.4 Energy Scan when the result for a channel is ready or the
/// scan completes.
///
/// @param[in]  aResult   A valid pointer to the energy scan result information or NULL when the energy scan completes.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otHandleEnergyScanResult = ::core::option::Option<
    unsafe extern "C" fn(aResult: *mut otEnergyScanResult, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Starts an IEEE 802.15.4 Energy Scan
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aScanChannels     A bit vector indicating on which channels to perform energy scan.
    /// @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.
    /// @param[in]  aCallback         A pointer to a function called to pass on scan result on indicate scan completion.
    /// @param[in]  aCallbackContext  A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE  Accepted the Energy Scan request.
    /// @retval OT_ERROR_BUSY  Could not start the energy scan.
    pub fn otLinkEnergyScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleEnergyScanResult,
        aCallbackContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Indicates whether or not an IEEE 802.15.4 Energy Scan is currently in progress.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns true if an IEEE 802.15.4 Energy Scan is in progress, false otherwise.
    pub fn otLinkIsEnergyScanInProgress(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Enqueues an IEEE 802.15.4 Data Request message for transmission.
    ///
    /// @param[in] aInstance  A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE           Successfully enqueued an IEEE 802.15.4 Data Request message.
    /// @retval OT_ERROR_INVALID_STATE  Device is not in rx-off-when-idle mode.
    /// @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.
    pub fn otLinkSendDataRequest(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Indicates whether or not an IEEE 802.15.4 MAC is in the transmit state.
    ///
    /// MAC module is in the transmit state during CSMA/CA procedure, CCA, Data, Beacon or Data Request frame transmission
    /// and receiving an ACK of a transmitted frame. MAC module is not in the transmit state during transmission of an ACK
    /// frame or a Beacon Request frame.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns true if an IEEE 802.15.4 MAC is in the transmit state, false otherwise.
    pub fn otLinkIsInTransmitState(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Get the IEEE 802.15.4 channel.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The IEEE 802.15.4 channel.
    ///
    /// @sa otLinkSetChannel
    pub fn otLinkGetChannel(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Set the IEEE 802.15.4 channel
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful call to this function invalidates the
    /// Active and Pending Operational Datasets in non-volatile memory.
    ///
    /// @param[in]  aInstance   A pointer to an OpenThread instance.
    /// @param[in]  aChannel    The IEEE 802.15.4 channel.
    ///
    /// @retval  OT_ERROR_NONE           Successfully set the channel.
    /// @retval  OT_ERROR_INVALID_ARGS   If @p aChannel is not in the range [11, 26] or is not in the supported channel mask.
    /// @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    ///
    /// @sa otLinkGetChannel
    pub fn otLinkSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
unsafe extern "C" {
    /// Get the supported channel mask of MAC layer.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The supported channel mask as `uint32_t` with bit 0 (lsb) mapping to channel 0, bit 1 to channel 1, so on.
    pub fn otLinkGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Set the supported channel mask of MAC layer.
    ///
    /// Succeeds only when Thread protocols are disabled.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aChannelMask  The supported channel mask (bit 0 or lsb mapping to channel 0, and so on).
    ///
    /// @retval  OT_ERROR_NONE           Successfully set the supported channel mask.
    /// @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    pub fn otLinkSetSupportedChannelMask(aInstance: *mut otInstance, aChannelMask: u32) -> otError;
}
unsafe extern "C" {
    /// Gets the IEEE 802.15.4 Extended Address.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the IEEE 802.15.4 Extended Address.
    pub fn otLinkGetExtendedAddress(aInstance: *mut otInstance) -> *const otExtAddress;
}
unsafe extern "C" {
    /// Sets the IEEE 802.15.4 Extended Address.
    ///
    /// @note Only succeeds when Thread protocols are disabled.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the IEEE 802.15.4 Extended Address.
    /// @retval OT_ERROR_INVALID_ARGS   @p aExtAddress was NULL.
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    pub fn otLinkSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the factory-assigned IEEE EUI-64.
    ///
    /// @param[in]   aInstance  A pointer to the OpenThread instance.
    /// @param[out]  aEui64     A pointer to where the factory-assigned IEEE EUI-64 is placed.
    pub fn otLinkGetFactoryAssignedIeeeEui64(aInstance: *mut otInstance, aEui64: *mut otExtAddress);
}
unsafe extern "C" {
    /// Get the IEEE 802.15.4 PAN ID.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The IEEE 802.15.4 PAN ID.
    ///
    /// @sa otLinkSetPanId
    pub fn otLinkGetPanId(aInstance: *mut otInstance) -> otPanId;
}
unsafe extern "C" {
    /// Set the IEEE 802.15.4 PAN ID.
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful call to this function also invalidates
    /// the Active and Pending Operational Datasets in non-volatile memory.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aPanId       The IEEE 802.15.4 PAN ID.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the PAN ID.
    /// @retval OT_ERROR_INVALID_ARGS   If aPanId is not in the range [0, 65534].
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    ///
    /// @sa otLinkGetPanId
    pub fn otLinkSetPanId(aInstance: *mut otInstance, aPanId: otPanId) -> otError;
}
unsafe extern "C" {
    /// Get the data poll period of sleepy end device.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns  The data poll period of sleepy end device in milliseconds.
    ///
    /// @sa otLinkSetPollPeriod
    pub fn otLinkGetPollPeriod(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Set/clear user-specified/external data poll period for sleepy end device.
    ///
    /// @note This function updates only poll period of sleepy end device. To update child timeout the function
    ///       `otThreadSetChildTimeout()` shall be called.
    ///
    /// @note Minimal non-zero value should be `OPENTHREAD_CONFIG_MAC_MINIMUM_POLL_PERIOD` (10ms).
    ///       Or zero to clear user-specified poll period.
    ///
    /// @note User-specified value should be no more than the maximal value 0x3FFFFFF ((1 << 26) - 1) allowed,
    /// otherwise it would be clipped by the maximal value.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aPollPeriod  data poll period in milliseconds.
    ///
    /// @retval OT_ERROR_NONE           Successfully set/cleared user-specified poll period.
    /// @retval OT_ERROR_INVALID_ARGS   If aPollPeriod is invalid.
    ///
    /// @sa otLinkGetPollPeriod
    pub fn otLinkSetPollPeriod(aInstance: *mut otInstance, aPollPeriod: u32) -> otError;
}
unsafe extern "C" {
    /// Get the IEEE 802.15.4 Short Address.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the IEEE 802.15.4 Short Address.
    pub fn otLinkGetShortAddress(aInstance: *mut otInstance) -> otShortAddress;
}
unsafe extern "C" {
    /// Returns the maximum number of frame retries during direct transmission.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The maximum number of retries during direct transmission.
    pub fn otLinkGetMaxFrameRetriesDirect(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Sets the maximum number of frame retries during direct transmission.
    ///
    /// @param[in]  aInstance               A pointer to an OpenThread instance.
    /// @param[in]  aMaxFrameRetriesDirect  The maximum number of retries during direct transmission.
    pub fn otLinkSetMaxFrameRetriesDirect(aInstance: *mut otInstance, aMaxFrameRetriesDirect: u8);
}
unsafe extern "C" {
    /// Returns the maximum number of frame retries during indirect transmission.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The maximum number of retries during indirect transmission.
    pub fn otLinkGetMaxFrameRetriesIndirect(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Sets the maximum number of frame retries during indirect transmission.
    ///
    /// @param[in]  aInstance                 A pointer to an OpenThread instance.
    /// @param[in]  aMaxFrameRetriesIndirect  The maximum number of retries during indirect transmission.
    pub fn otLinkSetMaxFrameRetriesIndirect(
        aInstance: *mut otInstance,
        aMaxFrameRetriesIndirect: u8,
    );
}
unsafe extern "C" {
    /// Gets the current MAC frame counter value.
    ///
    /// @param[in] aInstance    A pointer to the OpenThread instance.
    ///
    /// @returns The current MAC frame counter value.
    pub fn otLinkGetFrameCounter(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Gets the address mode of MAC filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns  the address mode.
    pub fn otLinkFilterGetAddressMode(aInstance: *mut otInstance) -> otMacFilterAddressMode;
}
unsafe extern "C" {
    /// Sets the address mode of MAC filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aMode      The address mode to set.
    pub fn otLinkFilterSetAddressMode(aInstance: *mut otInstance, aMode: otMacFilterAddressMode);
}
unsafe extern "C" {
    /// Adds an Extended Address to MAC filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).
    ///
    /// @retval OT_ERROR_NONE           Successfully added @p aExtAddress to MAC filter.
    /// @retval OT_ERROR_NO_BUFS        No available entry exists.
    pub fn otLinkFilterAddAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes an Extended Address from MAC filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// No action is performed if there is no existing entry in Filter matching the given Extended Address.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).
    pub fn otLinkFilterRemoveAddress(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
unsafe extern "C" {
    /// Clears all the Extended Addresses from MAC filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otLinkFilterClearAddresses(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets an in-use address filter entry.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]      aInstance  A pointer to an OpenThread instance.
    /// @param[in,out]  aIterator  A pointer to the MAC filter iterator context. To get the first in-use address filter
    ///                            entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT. MUST NOT be NULL.
    /// @param[out]     aEntry     A pointer to where the information is placed. MUST NOT be NULL.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved an in-use address filter entry.
    /// @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.
    pub fn otLinkFilterGetNextAddress(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
unsafe extern "C" {
    /// Adds the specified Extended Address to the `RssIn` list (or modifies an existing
    /// address in the `RssIn` list) and sets the received signal strength (in dBm) entry
    /// for messages from that address. The Extended Address does not necessarily have
    /// to be in the `address allowlist/denylist` filter to set the `rss`.
    /// @note The `RssIn` list contains Extended Addresses whose `rss` or link quality indicator (`lqi`)
    /// values have been set to be different from the defaults.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.
    /// @param[in]  aRss         A received signal strength (in dBm).
    ///
    /// @retval OT_ERROR_NONE           Successfully added an entry for @p aExtAddress and @p aRss.
    /// @retval OT_ERROR_NO_BUFS        No available entry exists.
    pub fn otLinkFilterAddRssIn(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aRss: i8,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes the specified Extended Address from the `RssIn` list. Once removed
    /// from the `RssIn` list, this MAC address will instead use the default `rss`
    /// and `lqi` settings, assuming defaults have been set.
    /// (If no defaults have been set, the over-air signal is used.)
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// No action is performed if there is no existing entry in the `RssIn` list matching the specified Extended Address.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.
    pub fn otLinkFilterRemoveRssIn(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
unsafe extern "C" {
    /// Sets the default received signal strength (in dBm) on MAC Filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// The default RSS value is used for all received frames from addresses for which there is no explicit RSS-IN entry
    /// in the Filter list (added using `otLinkFilterAddRssIn()`).
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    /// @param[in]  aRss         The default received signal strength (in dBm) to set.
    pub fn otLinkFilterSetDefaultRssIn(aInstance: *mut otInstance, aRss: i8);
}
unsafe extern "C" {
    /// Clears any previously set default received signal strength (in dBm) on MAC Filter.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance    A pointer to an OpenThread instance.
    pub fn otLinkFilterClearDefaultRssIn(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Clears all the received signal strength (`rss`) and link quality
    /// indicator (`lqi`) entries (including defaults) from the `RssIn` list.
    /// Performing this action means that all Extended Addresses will use the on-air signal.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    pub fn otLinkFilterClearAllRssIn(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets an in-use RssIn filter entry.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @param[in]      aInstance  A pointer to an OpenThread instance.
    /// @param[in,out]  aIterator  A pointer to the MAC filter iterator context. MUST NOT be NULL.
    ///                            To get the first entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT.
    /// @param[out]     aEntry     A pointer to where the information is placed. The last entry would have the extended
    ///                            address as all 0xff to indicate the default received signal strength if it was set.
    ///@p aEntry MUST NOT be NULL.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the next entry.
    /// @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.
    pub fn otLinkFilterGetNextRssIn(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
unsafe extern "C" {
    /// Enables/disables IEEE 802.15.4 radio filter mode.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// The radio filter is mainly intended for testing. It can be used to temporarily block all tx/rx on the 802.15.4 radio.
    /// When radio filter is enabled, radio is put to sleep instead of receive (to ensure device does not receive any frame
    /// and/or potentially send ack). Also the frame transmission requests return immediately without sending the frame over
    /// the air (return "no ack" error if ack is requested, otherwise return success).
    ///
    /// @param[in] aInstance         A pointer to an OpenThread instance.
    /// @param[in] aFilterEnabled    TRUE to enable radio filter, FALSE to disable
    pub fn otLinkSetRadioFilterEnabled(aInstance: *mut otInstance, aFilterEnabled: bool);
}
unsafe extern "C" {
    /// Indicates whether the IEEE 802.15.4 radio filter is enabled or not.
    ///
    /// Is available when `OPENTHREAD_CONFIG_MAC_FILTER_ENABLE` configuration is enabled.
    ///
    /// @retval TRUE   If the radio filter is enabled.
    /// @retval FALSE  If the radio filter is disabled.
    pub fn otLinkIsRadioFilterEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Converts received signal strength to link quality.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aRss       The received signal strength value to be converted.
    ///
    /// @return Link quality value mapping to @p aRss.
    pub fn otLinkConvertRssToLinkQuality(aInstance: *mut otInstance, aRss: i8) -> u8;
}
unsafe extern "C" {
    /// Converts link quality to typical received signal strength.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aLinkQuality  LinkQuality value, should be in range [0,3].
    ///
    /// @return Typical platform received signal strength mapping to @p aLinkQuality.
    pub fn otLinkConvertLinkQualityToRss(aInstance: *mut otInstance, aLinkQuality: u8) -> i8;
}
unsafe extern "C" {
    /// Gets histogram of retries for a single direct packet until success.
    ///
    /// Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.
    ///
    /// @param[in]   aInstance          A pointer to an OpenThread instance.
    /// @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.
    ///
    /// @returns     A pointer to the histogram of retries (in a form of an array).
    ///              The n-th element indicates that the packet has been sent with n-th retry.
    pub fn otLinkGetTxDirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
unsafe extern "C" {
    /// Gets histogram of retries for a single indirect packet until success.
    ///
    /// Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.
    ///
    /// @param[in]   aInstance          A pointer to an OpenThread instance.
    /// @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.
    ///
    /// @returns     A pointer to the histogram of retries (in a form of an array).
    ///              The n-th element indicates that the packet has been sent with n-th retry.
    pub fn otLinkGetTxIndirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
unsafe extern "C" {
    /// Clears histogram statistics for direct and indirect transmissions.
    ///
    /// Is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.
    ///
    /// @param[in]   aInstance          A pointer to an OpenThread instance.
    pub fn otLinkResetTxRetrySuccessHistogram(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Get the MAC layer counters.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the MAC layer counters.
    pub fn otLinkGetCounters(aInstance: *mut otInstance) -> *const otMacCounters;
}
unsafe extern "C" {
    /// Resets the MAC layer counters.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    pub fn otLinkResetCounters(aInstance: *mut otInstance);
}
/// Pointer is called when an IEEE 802.15.4 frame is received.
///
/// @note This callback is called after FCS processing and @p aFrame may not contain the actual FCS that was received.
///
/// @note This callback is called before IEEE 802.15.4 security processing.
///
/// @param[in]  aFrame    A pointer to the received IEEE 802.15.4 frame.
/// @param[in]  aIsTx     Whether this frame is transmitted, not received.
/// @param[in]  aContext  A pointer to application-specific context.
pub type otLinkPcapCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aFrame: *const otRadioFrame,
        aIsTx: bool,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Registers a callback to provide received raw IEEE 802.15.4 frames.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aPcapCallback     A pointer to a function that is called when receiving an IEEE 802.15.4 link frame or
    ///                               NULL to disable the callback.
    /// @param[in]  aCallbackContext  A pointer to application-specific context.
    pub fn otLinkSetPcapCallback(
        aInstance: *mut otInstance,
        aPcapCallback: otLinkPcapCallback,
        aCallbackContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Indicates whether or not promiscuous mode is enabled at the link layer.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   Promiscuous mode is enabled.
    /// @retval FALSE  Promiscuous mode is not enabled.
    pub fn otLinkIsPromiscuous(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Enables or disables the link layer promiscuous mode.
    ///
    /// @note Promiscuous mode may only be enabled when the Thread interface is disabled.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aPromiscuous  true to enable promiscuous mode, or false otherwise.
    ///
    /// @retval OT_ERROR_NONE           Successfully enabled promiscuous mode.
    /// @retval OT_ERROR_INVALID_STATE  Could not enable promiscuous mode because
    ///                                 the Thread interface is enabled.
    pub fn otLinkSetPromiscuous(aInstance: *mut otInstance, aPromiscuous: bool) -> otError;
}
unsafe extern "C" {
    /// Gets the CSL channel.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    ///
    /// @returns The CSL channel.
    pub fn otLinkGetCslChannel(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Sets the CSL channel.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    /// @param[in]  aChannel       The CSL sample channel. Channel value should be `0` (Set CSL Channel unspecified) or
    ///                            within the range [1, 10] (if 915-MHz supported) and [11, 26] (if 2.4 GHz supported).
    ///
    /// @retval OT_ERROR_NONE           Successfully set the CSL parameters.
    /// @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel.
    pub fn otLinkSetCslChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
unsafe extern "C" {
    /// Gets the CSL period in microseconds
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    ///
    /// @returns The CSL period in microseconds.
    pub fn otLinkGetCslPeriod(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the CSL period in microseconds. Disable CSL by setting this parameter to `0`.
    ///
    /// The CSL period MUST be a multiple of `OT_LINK_CSL_PERIOD_TEN_SYMBOLS_UNIT_IN_USEC`, otherwise `OT_ERROR_INVALID_ARGS`
    /// is returned.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    /// @param[in]  aPeriod        The CSL period in microseconds.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the CSL period.
    /// @retval OT_ERROR_INVALID_ARGS   Invalid CSL period
    pub fn otLinkSetCslPeriod(aInstance: *mut otInstance, aPeriod: u32) -> otError;
}
unsafe extern "C" {
    /// Gets the CSL timeout.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    ///
    /// @returns The CSL timeout in seconds.
    pub fn otLinkGetCslTimeout(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the CSL timeout in seconds.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    /// @param[in]  aTimeout       The CSL timeout in seconds.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the CSL timeout.
    /// @retval OT_ERROR_INVALID_ARGS   Invalid CSL timeout.
    pub fn otLinkSetCslTimeout(aInstance: *mut otInstance, aTimeout: u32) -> otError;
}
unsafe extern "C" {
    /// Returns the current CCA (Clear Channel Assessment) failure rate.
    ///
    /// The rate is maintained over a window of (roughly) last `OPENTHREAD_CONFIG_CCA_FAILURE_RATE_AVERAGING_WINDOW`
    /// frame transmissions.
    ///
    /// @returns The CCA failure rate with maximum value `0xffff` corresponding to 100% failure rate.
    pub fn otLinkGetCcaFailureRate(aInstance: *mut otInstance) -> u16;
}
unsafe extern "C" {
    /// Enables or disables the link layer.
    ///
    /// @note The link layer may only be enabled / disabled when the Thread Interface is disabled.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aEnable       true to enable the link layer, or false otherwise.
    ///
    /// @retval OT_ERROR_NONE          Successfully enabled / disabled the link layer.
    /// @retval OT_ERROR_INVALID_STATE Could not disable the link layer because
    ///                                the Thread interface is enabled.
    pub fn otLinkSetEnabled(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
unsafe extern "C" {
    /// Indicates whether or not the link layer is enabled.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   Link layer is enabled.
    /// @retval FALSE  Link layer is not enabled.
    pub fn otLinkIsEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Indicates whether or not CSL is enabled.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   Link layer is CSL enabled.
    /// @retval FALSE  Link layer is not CSL enabled.
    pub fn otLinkIsCslEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Indicates whether the device is connected to a parent which supports CSL.
    ///
    /// @retval TRUE   If parent supports CSL.
    /// @retval FALSE  If parent does not support CSL.
    pub fn otLinkIsCslSupported(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Instructs the device to send an empty IEEE 802.15.4 data frame.
    ///
    /// Is only supported on an Rx-Off-When-Idle device to send an empty data frame to its parent.
    /// Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.
    ///
    /// @param[in] aInstance  A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE           Successfully enqueued an empty message.
    /// @retval OT_ERROR_INVALID_STATE  Device is not in Rx-Off-When-Idle mode.
    /// @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.
    pub fn otLinkSendEmptyData(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Sets the region code.
    ///
    /// The radio region format is the 2-bytes ascii representation of the ISO 3166 alpha-2 code.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[in]  aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char
    ///                          and the `aRegionCode & 0xff` is the second ascii char.
    ///
    /// @retval  OT_ERROR_FAILED           Other platform specific errors.
    /// @retval  OT_ERROR_NONE             Successfully set region code.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
    pub fn otLinkSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
unsafe extern "C" {
    /// Get the region code.
    ///
    /// The radio region format is the 2-bytes ascii representation of the ISO 3166 alpha-2 code.
    ///
    /// @param[in]  aInstance    The OpenThread instance structure.
    /// @param[out] aRegionCode  The radio region code. The `aRegionCode >> 8` is first ascii char
    ///                          and the `aRegionCode & 0xff` is the second ascii char.
    ///
    /// @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.
    /// @retval  OT_ERROR_FAILED           Other platform specific errors.
    /// @retval  OT_ERROR_NONE             Successfully got region code.
    /// @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.
    pub fn otLinkGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
unsafe extern "C" {
    /// Gets the Wake-up channel.
    ///
    /// Requires `OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE` or `OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE`.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns The Wake-up channel.
    pub fn otLinkGetWakeupChannel(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Sets the Wake-up channel.
    ///
    /// Requires `OPENTHREAD_CONFIG_WAKEUP_COORDINATOR_ENABLE` or `OPENTHREAD_CONFIG_WAKEUP_END_DEVICE_ENABLE`.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aChannel   The Wake-up sample channel. Channel value should be `0` (Set Wake-up Channel unspecified,
    ///                        which means the device will use the PAN channel) or within the range [1, 10] (if 915-MHz
    ///                        supported) and [11, 26] (if 2.4 GHz supported).
    ///
    /// @retval OT_ERROR_NONE           Successfully set the Wake-up channel.
    /// @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel.
    pub fn otLinkSetWakeupChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
///< The Thread stack is disabled.
pub const otDeviceRole_OT_DEVICE_ROLE_DISABLED: otDeviceRole = 0;
///< Not currently participating in a Thread network/partition.
pub const otDeviceRole_OT_DEVICE_ROLE_DETACHED: otDeviceRole = 1;
///< The Thread Child role.
pub const otDeviceRole_OT_DEVICE_ROLE_CHILD: otDeviceRole = 2;
///< The Thread Router role.
pub const otDeviceRole_OT_DEVICE_ROLE_ROUTER: otDeviceRole = 3;
///< The Thread Leader role.
pub const otDeviceRole_OT_DEVICE_ROLE_LEADER: otDeviceRole = 4;
/// Represents a Thread device role.
pub type otDeviceRole = ::core::ffi::c_uint;
/// Represents an MLE Link Mode configuration.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLinkModeConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkModeConfig {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mRxOnWhenIdle_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mRxOnWhenIdle_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mDeviceType(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDeviceType(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mDeviceType_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mDeviceType_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mNetworkData_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mNetworkData_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mDeviceType: bool,
        mNetworkData: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mDeviceType: u8 = unsafe { ::core::mem::transmute(mDeviceType) };
            mDeviceType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNetworkData: u8 = unsafe { ::core::mem::transmute(mNetworkData) };
            mNetworkData as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Holds diagnostic information for a neighboring Thread node
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNeighborInfo {
    ///< IEEE 802.15.4 Extended Address
    pub mExtAddress: otExtAddress,
    ///< Seconds since last heard
    pub mAge: u32,
    ///< Seconds since link establishment (requires `CONFIG_UPTIME_ENABLE`)
    pub mConnectionTime: u32,
    ///< RLOC16
    pub mRloc16: u16,
    ///< Link Frame Counter
    pub mLinkFrameCounter: u32,
    ///< MLE Frame Counter
    pub mMleFrameCounter: u32,
    ///< Link Quality In
    pub mLinkQualityIn: u8,
    ///< Average RSSI
    pub mAverageRssi: i8,
    ///< Last observed RSSI
    pub mLastRssi: i8,
    ///< Link Margin
    pub mLinkMargin: u8,
    ///< Frame error rate (0xffff->100%). Requires error tracking feature.
    pub mFrameErrorRate: u16,
    ///< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature.
    pub mMessageErrorRate: u16,
    ///< Thread version of the neighbor
    pub mVersion: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otNeighborInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mRxOnWhenIdle_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mRxOnWhenIdle_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mFullThreadDevice_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mFullThreadDevice_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mFullNetworkData_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mFullNetworkData_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsChild(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsChild_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsChild_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsChild: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::core::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::core::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::core::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsChild: u8 = unsafe { ::core::mem::transmute(mIsChild) };
            mIsChild as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otNeighborInfoIterator = i16;
/// Represents the Thread Leader Data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLeaderData {
    ///< Partition ID
    pub mPartitionId: u32,
    ///< Leader Weight
    pub mWeighting: u8,
    ///< Full Network Data Version
    pub mDataVersion: u8,
    ///< Stable Network Data Version
    pub mStableDataVersion: u8,
    ///< Leader Router ID
    pub mLeaderRouterId: u8,
}
/// Holds diagnostic information for a Thread Router
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRouterInfo {
    ///< IEEE 802.15.4 Extended Address
    pub mExtAddress: otExtAddress,
    ///< RLOC16
    pub mRloc16: u16,
    ///< Router ID
    pub mRouterId: u8,
    ///< Next hop to router
    pub mNextHop: u8,
    ///< Path cost to router
    pub mPathCost: u8,
    ///< Link Quality In
    pub mLinkQualityIn: u8,
    ///< Link Quality Out
    pub mLinkQualityOut: u8,
    ///< Time last heard
    pub mAge: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    ///< Thread version
    pub mVersion: u8,
    ///< CSL clock accuracy, in  ppm
    pub mCslClockAccuracy: u8,
    ///< CSL uncertainty, in 10 us
    pub mCslUncertainty: u8,
}
impl otRouterInfo {
    #[inline]
    pub fn mAllocated(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllocated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mAllocated_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mAllocated_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mLinkEstablished(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkEstablished(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mLinkEstablished_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mLinkEstablished_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAllocated: bool,
        mLinkEstablished: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAllocated: u8 = unsafe { ::core::mem::transmute(mAllocated) };
            mAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLinkEstablished: u8 = unsafe { ::core::mem::transmute(mLinkEstablished) };
            mLinkEstablished as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Represents the IP level counters.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIpCounters {
    ///< The number of IPv6 packets successfully transmitted.
    pub mTxSuccess: u32,
    ///< The number of IPv6 packets successfully received.
    pub mRxSuccess: u32,
    ///< The number of IPv6 packets failed to transmit.
    pub mTxFailure: u32,
    ///< The number of IPv6 packets failed to receive.
    pub mRxFailure: u32,
}
/// Represents the Thread MLE counters.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMleCounters {
    ///< Number of times device entered OT_DEVICE_ROLE_DISABLED role.
    pub mDisabledRole: u16,
    ///< Number of times device entered OT_DEVICE_ROLE_DETACHED role.
    pub mDetachedRole: u16,
    ///< Number of times device entered OT_DEVICE_ROLE_CHILD role.
    pub mChildRole: u16,
    ///< Number of times device entered OT_DEVICE_ROLE_ROUTER role.
    pub mRouterRole: u16,
    ///< Number of times device entered OT_DEVICE_ROLE_LEADER role.
    pub mLeaderRole: u16,
    ///< Number of attach attempts while device was detached.
    pub mAttachAttempts: u16,
    ///< Number of changes to partition ID.
    pub mPartitionIdChanges: u16,
    ///< Number of attempts to attach to a better partition.
    pub mBetterPartitionAttachAttempts: u16,
    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role.
    pub mDisabledTime: u64,
    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role.
    pub mDetachedTime: u64,
    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role.
    pub mChildTime: u64,
    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_ROUTER role.
    pub mRouterTime: u64,
    ///< Number of milliseconds device has been in OT_DEVICE_ROLE_LEADER role.
    pub mLeaderTime: u64,
    ///< Number of milliseconds tracked by previous counters.
    pub mTrackedTime: u64,
    /// Number of times device changed its parent.
    ///
    /// A parent change can happen if device detaches from its current parent and attaches to a different one, or even
    /// while device is attached when the periodic parent search feature is enabled  (please see option
    /// OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE).
    pub mParentChanges: u16,
}
/// Represents the MLE Parent Response data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadParentResponseInfo {
    ///< IEEE 802.15.4 Extended Address of the Parent
    pub mExtAddr: otExtAddress,
    ///< Short address of the Parent
    pub mRloc16: u16,
    ///< Rssi of the Parent
    pub mRssi: i8,
    ///< Parent priority
    pub mPriority: i8,
    ///< Parent Link Quality 3
    pub mLinkQuality3: u8,
    ///< Parent Link Quality 2
    pub mLinkQuality2: u8,
    ///< Parent Link Quality 1
    pub mLinkQuality1: u8,
    ///< Is the node receiving parent response attached
    pub mIsAttached: bool,
}
/// This callback informs the application that the detaching process has finished.
///
/// @param[in] aContext A pointer to application-specific context.
pub type otDetachGracefullyCallback =
    ::core::option::Option<unsafe extern "C" fn(aContext: *mut ::core::ffi::c_void)>;
unsafe extern "C" {
    /// Starts Thread protocol operation.
    ///
    /// The interface must be up when calling this function.
    ///
    /// Calling this function with @p aEnabled set to FALSE stops any ongoing processes of detaching started by
    /// otThreadDetachGracefully(). Its callback will be called.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    /// @param[in] aEnabled  TRUE if Thread is enabled, FALSE otherwise.
    ///
    /// @retval OT_ERROR_NONE           Successfully started Thread protocol operation.
    /// @retval OT_ERROR_INVALID_STATE  The network interface was not up.
    pub fn otThreadSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
unsafe extern "C" {
    /// Gets the Thread protocol version.
    ///
    /// The constants `OT_THREAD_VERSION_*` define the numerical version values.
    ///
    /// @returns the Thread protocol version.
    pub fn otThreadGetVersion() -> u16;
}
unsafe extern "C" {
    /// Indicates whether a node is the only router on the network.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   It is the only router in the network.
    /// @retval FALSE  It is a child or is not a single router in the network.
    pub fn otThreadIsSingleton(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Starts a Thread Discovery scan.
    ///
    /// @note A successful call to this function enables the rx-on-when-idle mode for the entire scan procedure.
    ///
    /// @param[in]  aInstance              A pointer to an OpenThread instance.
    /// @param[in]  aScanChannels          A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).
    /// @param[in]  aPanId                 The PAN ID filter (set to Broadcast PAN to disable filter).
    /// @param[in]  aJoiner                Value of the Joiner Flag in the Discovery Request TLV.
    /// @param[in]  aEnableEui64Filtering  TRUE to filter responses on EUI-64, FALSE otherwise.
    /// @param[in]  aCallback              A pointer to a function called on receiving an MLE Discovery Response or
    ///                                    scan completes.
    /// @param[in]  aCallbackContext       A pointer to application-specific context.
    ///
    /// @retval OT_ERROR_NONE           Successfully started a Thread Discovery Scan.
    /// @retval OT_ERROR_INVALID_STATE  The IPv6 interface is not enabled (netif is not up).
    /// @retval OT_ERROR_NO_BUFS        Could not allocate message for Discovery Request.
    /// @retval OT_ERROR_BUSY           Thread Discovery Scan is already in progress.
    pub fn otThreadDiscover(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aPanId: u16,
        aJoiner: bool,
        aEnableEui64Filtering: bool,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Determines if an MLE Thread Discovery is currently in progress.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    pub fn otThreadIsDiscoverInProgress(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Sets the Thread Joiner Advertisement when discovering Thread network.
    ///
    /// Thread Joiner Advertisement is used to allow a Joiner to advertise its own application-specific information
    /// (such as Vendor ID, Product ID, Discriminator, etc.) via a newly-proposed Joiner Advertisement TLV,
    /// and to make this information available to Commissioners or Commissioner Candidates without human interaction.
    ///
    /// @param[in]  aInstance        A pointer to an OpenThread instance.
    /// @param[in]  aOui             The Vendor IEEE OUI value that will be included in the Joiner Advertisement. Only the
    ///                              least significant 3 bytes will be used, and the most significant byte will be ignored.
    /// @param[in]  aAdvData         A pointer to the AdvData that will be included in the Joiner Advertisement.
    /// @param[in]  aAdvDataLength   The length of AdvData in bytes.
    ///
    /// @retval OT_ERROR_NONE         Successfully set Joiner Advertisement.
    /// @retval OT_ERROR_INVALID_ARGS Invalid AdvData.
    pub fn otThreadSetJoinerAdvertisement(
        aInstance: *mut otInstance,
        aOui: u32,
        aAdvData: *const u8,
        aAdvDataLength: u8,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Thread Child Timeout (in seconds) used when operating in the Child role.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The Thread Child Timeout value in seconds.
    ///
    /// @sa otThreadSetChildTimeout
    pub fn otThreadGetChildTimeout(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the Thread Child Timeout (in seconds) used when operating in the Child role.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aTimeout  The timeout value in seconds.
    ///
    /// @sa otThreadGetChildTimeout
    pub fn otThreadSetChildTimeout(aInstance: *mut otInstance, aTimeout: u32);
}
unsafe extern "C" {
    /// Gets the IEEE 802.15.4 Extended PAN ID.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the IEEE 802.15.4 Extended PAN ID.
    ///
    /// @sa otThreadSetExtendedPanId
    pub fn otThreadGetExtendedPanId(aInstance: *mut otInstance) -> *const otExtendedPanId;
}
unsafe extern "C" {
    /// Sets the IEEE 802.15.4 Extended PAN ID.
    ///
    /// @note Can only be called while Thread protocols are disabled. A successful
    /// call to this function invalidates the Active and Pending Operational Datasets in
    /// non-volatile memory.
    ///
    /// @param[in]  aInstance       A pointer to an OpenThread instance.
    /// @param[in]  aExtendedPanId  A pointer to the IEEE 802.15.4 Extended PAN ID.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the Extended PAN ID.
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    ///
    /// @sa otThreadGetExtendedPanId
    pub fn otThreadSetExtendedPanId(
        aInstance: *mut otInstance,
        aExtendedPanId: *const otExtendedPanId,
    ) -> otError;
}
unsafe extern "C" {
    /// Returns a pointer to the Leader's RLOC.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aLeaderRloc  A pointer to the Leader's RLOC.
    ///
    /// @retval OT_ERROR_NONE          The Leader's RLOC was successfully written to @p aLeaderRloc.
    /// @retval OT_ERROR_INVALID_ARGS  @p aLeaderRloc was NULL.
    /// @retval OT_ERROR_DETACHED      Not currently attached to a Thread Partition.
    pub fn otThreadGetLeaderRloc(
        aInstance: *mut otInstance,
        aLeaderRloc: *mut otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the MLE Link Mode configuration.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The MLE Link Mode configuration.
    ///
    /// @sa otThreadSetLinkMode
    pub fn otThreadGetLinkMode(aInstance: *mut otInstance) -> otLinkModeConfig;
}
unsafe extern "C" {
    /// Set the MLE Link Mode configuration.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    /// @param[in]  aConfig   A pointer to the Link Mode configuration.
    ///
    /// @retval OT_ERROR_NONE  Successfully set the MLE Link Mode configuration.
    ///
    /// @sa otThreadGetLinkMode
    pub fn otThreadSetLinkMode(aInstance: *mut otInstance, aConfig: otLinkModeConfig) -> otError;
}
unsafe extern "C" {
    /// Get the Thread Network Key.
    ///
    /// @param[in]   aInstance     A pointer to an OpenThread instance.
    /// @param[out]  aNetworkKey   A pointer to an `otNetworkKey` to return the Thread Network Key.
    ///
    /// @sa otThreadSetNetworkKey
    pub fn otThreadGetNetworkKey(aInstance: *mut otInstance, aNetworkKey: *mut otNetworkKey);
}
unsafe extern "C" {
    /// Get the `otNetworkKeyRef` for Thread Network Key.
    ///
    /// Requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.
    ///
    /// @param[in]   aInstance   A pointer to an OpenThread instance.
    ///
    /// @returns Reference to the Thread Network Key stored in memory.
    ///
    /// @sa otThreadSetNetworkKeyRef
    pub fn otThreadGetNetworkKeyRef(aInstance: *mut otInstance) -> otNetworkKeyRef;
}
unsafe extern "C" {
    /// Set the Thread Network Key.
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful
    /// call to this function invalidates the Active and Pending Operational Datasets in
    /// non-volatile memory.
    ///
    /// @param[in]  aInstance   A pointer to an OpenThread instance.
    /// @param[in]  aKey        A pointer to a buffer containing the Thread Network Key.
    ///
    /// @retval OT_ERROR_NONE            Successfully set the Thread Network Key.
    /// @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.
    ///
    /// @sa otThreadGetNetworkKey
    pub fn otThreadSetNetworkKey(aInstance: *mut otInstance, aKey: *const otNetworkKey) -> otError;
}
unsafe extern "C" {
    /// Set the Thread Network Key as a `otNetworkKeyRef`.
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful
    /// call to this function invalidates the Active and Pending Operational Datasets in
    /// non-volatile memory.
    ///
    /// Requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.
    ///
    /// @param[in]  aInstance   A pointer to an OpenThread instance.
    /// @param[in]  aKeyRef     Reference to the Thread Network Key.
    ///
    /// @retval OT_ERROR_NONE            Successfully set the Thread Network Key.
    /// @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.
    ///
    /// @sa otThreadGetNetworkKeyRef
    pub fn otThreadSetNetworkKeyRef(
        aInstance: *mut otInstance,
        aKeyRef: otNetworkKeyRef,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Thread Routing Locator (RLOC) address.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Thread Routing Locator (RLOC) address.
    pub fn otThreadGetRloc(aInstance: *mut otInstance) -> *const otIp6Address;
}
unsafe extern "C" {
    /// Gets the Mesh Local EID address.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Mesh Local EID address.
    pub fn otThreadGetMeshLocalEid(aInstance: *mut otInstance) -> *const otIp6Address;
}
unsafe extern "C" {
    /// Returns a pointer to the Mesh Local Prefix.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Mesh Local Prefix.
    pub fn otThreadGetMeshLocalPrefix(aInstance: *mut otInstance) -> *const otMeshLocalPrefix;
}
unsafe extern "C" {
    /// Sets the Mesh Local Prefix.
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful
    /// call to this function invalidates the Active and Pending Operational Datasets in
    /// non-volatile memory.
    ///
    /// @param[in]  aInstance         A pointer to an OpenThread instance.
    /// @param[in]  aMeshLocalPrefix  A pointer to the Mesh Local Prefix.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the Mesh Local Prefix.
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    pub fn otThreadSetMeshLocalPrefix(
        aInstance: *mut otInstance,
        aMeshLocalPrefix: *const otMeshLocalPrefix,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Thread link-local IPv6 address.
    ///
    /// The Thread link local address is derived using IEEE802.15.4 Extended Address as Interface Identifier.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to Thread link-local IPv6 address.
    pub fn otThreadGetLinkLocalIp6Address(aInstance: *mut otInstance) -> *const otIp6Address;
}
unsafe extern "C" {
    /// Gets the Thread Link-Local All Thread Nodes multicast address.
    ///
    /// The address is a link-local Unicast Prefix-Based Multicast Address [RFC 3306], with:
    ///   - flgs set to 3 (P = 1 and T = 1)
    ///   - scop set to 2
    ///   - plen set to 64
    ///   - network prefix set to the Mesh Local Prefix
    ///   - group ID set to 1
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to Thread Link-Local All Thread Nodes multicast address.
    pub fn otThreadGetLinkLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
unsafe extern "C" {
    /// Gets the Thread Realm-Local All Thread Nodes multicast address.
    ///
    /// The address is a realm-local Unicast Prefix-Based Multicast Address [RFC 3306], with:
    ///   - flgs set to 3 (P = 1 and T = 1)
    ///   - scop set to 3
    ///   - plen set to 64
    ///   - network prefix set to the Mesh Local Prefix
    ///   - group ID set to 1
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to Thread Realm-Local All Thread Nodes multicast address.
    pub fn otThreadGetRealmLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
unsafe extern "C" {
    /// Retrieves the Service ALOC for given Service ID.
    ///
    /// @param[in]   aInstance     A pointer to an OpenThread instance.
    /// @param[in]   aServiceId    Service ID to get ALOC for.
    /// @param[out]  aServiceAloc  A pointer to output the Service ALOC. MUST NOT BE NULL.
    ///
    /// @retval OT_ERROR_NONE      Successfully retrieved the Service ALOC.
    /// @retval OT_ERROR_DETACHED  The Thread interface is not currently attached to a Thread Partition.
    pub fn otThreadGetServiceAloc(
        aInstance: *mut otInstance,
        aServiceId: u8,
        aServiceAloc: *mut otIp6Address,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the Thread Network Name.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Thread Network Name.
    ///
    /// @sa otThreadSetNetworkName
    pub fn otThreadGetNetworkName(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Set the Thread Network Name.
    ///
    /// Succeeds only when Thread protocols are disabled.  A successful
    /// call to this function invalidates the Active and Pending Operational Datasets in
    /// non-volatile memory.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aNetworkName  A pointer to the Thread Network Name.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the Thread Network Name.
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    ///
    /// @sa otThreadGetNetworkName
    pub fn otThreadSetNetworkName(
        aInstance: *mut otInstance,
        aNetworkName: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Thread Domain Name.
    ///
    /// @note Available since Thread 1.2.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Thread Domain Name.
    ///
    /// @sa otThreadSetDomainName
    pub fn otThreadGetDomainName(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Sets the Thread Domain Name. Only succeeds when Thread protocols are disabled.
    ///
    /// @note Available since Thread 1.2.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aDomainName   A pointer to the Thread Domain Name.
    ///
    /// @retval OT_ERROR_NONE           Successfully set the Thread Domain Name.
    /// @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.
    ///
    /// @sa otThreadGetDomainName
    pub fn otThreadSetDomainName(
        aInstance: *mut otInstance,
        aDomainName: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets or clears the Interface Identifier manually specified for the Thread Domain Unicast Address.
    ///
    /// Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.
    ///
    /// @note Only available since Thread 1.2.
    ///
    /// @param[in]  aInstance   A pointer to an OpenThread instance.
    /// @param[in]  aIid        A pointer to the Interface Identifier to set or NULL to clear.
    ///
    /// @retval OT_ERROR_NONE           Successfully set/cleared the Interface Identifier.
    /// @retval OT_ERROR_INVALID_ARGS   The specified Interface Identifier is reserved.
    ///
    /// @sa otThreadGetFixedDuaInterfaceIdentifier
    pub fn otThreadSetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the Interface Identifier manually specified for the Thread Domain Unicast Address.
    ///
    /// Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.
    ///
    /// @note Only available since Thread 1.2.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Interface Identifier which was set manually, or NULL if none was set.
    ///
    /// @sa otThreadSetFixedDuaInterfaceIdentifier
    pub fn otThreadGetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
    ) -> *const otIp6InterfaceIdentifier;
}
unsafe extern "C" {
    /// Gets the thrKeySequenceCounter.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The thrKeySequenceCounter value.
    ///
    /// @sa otThreadSetKeySequenceCounter
    pub fn otThreadGetKeySequenceCounter(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the thrKeySequenceCounter.
    ///
    /// @note This API is reserved for testing and demo purposes only. Changing settings with
    /// this API will render a production application non-compliant with the Thread Specification.
    ///
    /// @param[in]  aInstance            A pointer to an OpenThread instance.
    /// @param[in]  aKeySequenceCounter  The thrKeySequenceCounter value.
    ///
    /// @sa otThreadGetKeySequenceCounter
    pub fn otThreadSetKeySequenceCounter(aInstance: *mut otInstance, aKeySequenceCounter: u32);
}
unsafe extern "C" {
    /// Gets the thrKeySwitchGuardTime (in hours).
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The thrKeySwitchGuardTime value (in hours).
    ///
    /// @sa otThreadSetKeySwitchGuardTime
    pub fn otThreadGetKeySwitchGuardTime(aInstance: *mut otInstance) -> u16;
}
unsafe extern "C" {
    /// Sets the thrKeySwitchGuardTime (in hours).
    ///
    /// @note This API is reserved for testing and demo purposes only. Changing settings with
    /// this API will render a production application non-compliant with the Thread Specification.
    ///
    /// @param[in]  aInstance            A pointer to an OpenThread instance.
    /// @param[in]  aKeySwitchGuardTime  The thrKeySwitchGuardTime value (in hours).
    ///
    /// @sa otThreadGetKeySwitchGuardTime
    pub fn otThreadSetKeySwitchGuardTime(aInstance: *mut otInstance, aKeySwitchGuardTime: u16);
}
unsafe extern "C" {
    /// Detach from the Thread network.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE           Successfully detached from the Thread network.
    /// @retval OT_ERROR_INVALID_STATE  Thread is disabled.
    pub fn otThreadBecomeDetached(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Attempt to reattach as a child.
    ///
    /// @note This API is reserved for testing and demo purposes only. Changing settings with
    /// this API will render a production application non-compliant with the Thread Specification.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval OT_ERROR_NONE           Successfully begin attempt to become a child.
    /// @retval OT_ERROR_INVALID_STATE  Thread is disabled.
    pub fn otThreadBecomeChild(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Gets the next neighbor information. It is used to go through the entries of
    /// the neighbor table.
    ///
    /// @param[in]      aInstance  A pointer to an OpenThread instance.
    /// @param[in,out]  aIterator  A pointer to the iterator context. To get the first neighbor entry
    ///it should be set to OT_NEIGHBOR_INFO_ITERATOR_INIT.
    /// @param[out]     aInfo      A pointer to the neighbor information.
    ///
    /// @retval OT_ERROR_NONE         Successfully found the next neighbor entry in table.
    /// @retval OT_ERROR_NOT_FOUND     No subsequent neighbor entry exists in the table.
    /// @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aInfo was NULL.
    pub fn otThreadGetNextNeighborInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNeighborInfoIterator,
        aInfo: *mut otNeighborInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the device role.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @retval OT_DEVICE_ROLE_DISABLED  The Thread stack is disabled.
    /// @retval OT_DEVICE_ROLE_DETACHED  The device is not currently participating in a Thread network/partition.
    /// @retval OT_DEVICE_ROLE_CHILD     The device is currently operating as a Thread Child.
    /// @retval OT_DEVICE_ROLE_ROUTER    The device is currently operating as a Thread Router.
    /// @retval OT_DEVICE_ROLE_LEADER    The device is currently operating as a Thread Leader.
    pub fn otThreadGetDeviceRole(aInstance: *mut otInstance) -> otDeviceRole;
}
unsafe extern "C" {
    /// Convert the device role to human-readable string.
    ///
    /// @param[in] aRole   The device role to convert.
    ///
    /// @returns A string representing @p aRole.
    pub fn otThreadDeviceRoleToString(aRole: otDeviceRole) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Get the Thread Leader Data.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aLeaderData  A pointer to where the leader data is placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the leader data.
    /// @retval OT_ERROR_DETACHED      Not currently attached.
    pub fn otThreadGetLeaderData(
        aInstance: *mut otInstance,
        aLeaderData: *mut otLeaderData,
    ) -> otError;
}
unsafe extern "C" {
    /// Get the Leader's Router ID.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The Leader's Router ID.
    pub fn otThreadGetLeaderRouterId(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Get the Leader's Weight.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The Leader's Weight.
    pub fn otThreadGetLeaderWeight(aInstance: *mut otInstance) -> u8;
}
unsafe extern "C" {
    /// Get the Partition ID.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The Partition ID.
    pub fn otThreadGetPartitionId(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Get the RLOC16.
    ///
    /// @param[in]  aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The RLOC16.
    pub fn otThreadGetRloc16(aInstance: *mut otInstance) -> u16;
}
unsafe extern "C" {
    /// The function retrieves diagnostic information for a Thread Router as parent.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aParentInfo  A pointer to where the parent router information is placed.
    pub fn otThreadGetParentInfo(
        aInstance: *mut otInstance,
        aParentInfo: *mut otRouterInfo,
    ) -> otError;
}
unsafe extern "C" {
    /// The function retrieves the average RSSI for the Thread Parent.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aParentRssi  A pointer to where the parent RSSI should be placed.
    pub fn otThreadGetParentAverageRssi(
        aInstance: *mut otInstance,
        aParentRssi: *mut i8,
    ) -> otError;
}
unsafe extern "C" {
    /// The function retrieves the RSSI of the last packet from the Thread Parent.
    ///
    /// @param[in]   aInstance    A pointer to an OpenThread instance.
    /// @param[out]  aLastRssi    A pointer to where the last RSSI should be placed.
    ///
    /// @retval OT_ERROR_NONE          Successfully retrieved the RSSI data.
    /// @retval OT_ERROR_FAILED        Unable to get RSSI data.
    /// @retval OT_ERROR_INVALID_ARGS  @p aLastRssi is NULL.
    pub fn otThreadGetParentLastRssi(aInstance: *mut otInstance, aLastRssi: *mut i8) -> otError;
}
unsafe extern "C" {
    /// Starts the process for child to search for a better parent while staying attached to its current parent.
    ///
    /// Must be used when device is attached as a child.
    ///
    /// @retval OT_ERROR_NONE           Successfully started the process to search for a better parent.
    /// @retval OT_ERROR_INVALID_STATE  Device role is not child.
    pub fn otThreadSearchForBetterParent(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Gets the IPv6 counters.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the IPv6 counters.
    pub fn otThreadGetIp6Counters(aInstance: *mut otInstance) -> *const otIpCounters;
}
unsafe extern "C" {
    /// Resets the IPv6 counters.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otThreadResetIp6Counters(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets the time-in-queue histogram for messages in the TX queue.
    ///
    /// Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.
    ///
    /// Histogram of the time-in-queue of messages in the transmit queue is collected. The time-in-queue is tracked for
    /// direct transmissions only and is measured as the duration from when a message is added to the transmit queue until
    /// it is passed to the MAC layer for transmission or dropped.
    ///
    /// The histogram is returned as an array of `uint32_t` values with `aNumBins` entries. The first entry in the array
    /// (at index 0) represents the number of messages with a time-in-queue less than `aBinInterval`. The second entry
    /// represents the number of messages with a time-in-queue greater than or equal to `aBinInterval`, but less than
    /// `2 * aBinInterval`. And so on. The last entry represents the number of messages with time-in-queue  greater than or
    /// equal to `(aNumBins - 1) * aBinInterval`.
    ///
    /// The collected statistics can be reset by calling `otThreadResetTimeInQueueStat()`. The histogram information is
    /// collected since the OpenThread instance was initialized or since the last time statistics collection was reset by
    /// calling the `otThreadResetTimeInQueueStat()`.
    ///
    /// Pointers @p aNumBins and @p aBinInterval MUST NOT be NULL.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    /// @param[out] aNumBins       Pointer to return the number of bins in histogram (array length).
    /// @param[out] aBinInterval   Pointer to return the histogram bin interval length in milliseconds.
    ///
    /// @returns A pointer to an array of @p aNumBins entries representing the collected histogram info.
    pub fn otThreadGetTimeInQueueHistogram(
        aInstance: *mut otInstance,
        aNumBins: *mut u16,
        aBinInterval: *mut u32,
    ) -> *const u32;
}
unsafe extern "C" {
    /// Gets the maximum time-in-queue for messages in the TX queue.
    ///
    /// Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.
    ///
    /// The time-in-queue is tracked for direct transmissions only and is measured as the duration from when a message is
    /// added to the transmit queue until it is passed to the MAC layer for transmission or dropped.
    ///
    /// The collected statistics can be reset by calling `otThreadResetTimeInQueueStat()`.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    ///
    /// @returns The maximum time-in-queue in milliseconds for all messages in the TX queue (so far).
    pub fn otThreadGetMaxTimeInQueue(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Resets the TX queue time-in-queue statistics.
    ///
    /// Requires `OPENTHREAD_CONFIG_TX_QUEUE_STATISTICS_ENABLE`.
    ///
    /// @param[in]  aInstance      A pointer to an OpenThread instance.
    pub fn otThreadResetTimeInQueueStat(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets the Thread MLE counters.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    ///
    /// @returns A pointer to the Thread MLE counters.
    pub fn otThreadGetMleCounters(aInstance: *mut otInstance) -> *const otMleCounters;
}
unsafe extern "C" {
    /// Resets the Thread MLE counters.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    pub fn otThreadResetMleCounters(aInstance: *mut otInstance);
}
/// Pointer is called every time an MLE Parent Response message is received.
///
/// This is used in `otThreadRegisterParentResponseCallback()`.
///
/// @param[in]  aInfo     A pointer to a location on stack holding the stats data.
/// @param[in]  aContext  A pointer to callback client-specific context.
pub type otThreadParentResponseCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *mut otThreadParentResponseInfo,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Registers a callback to receive MLE Parent Response data.
    ///
    /// Requires `OPENTHREAD_CONFIG_MLE_PARENT_RESPONSE_CALLBACK_API_ENABLE`.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Parent Response message.
    /// @param[in]  aContext   A pointer to callback client-specific context.
    pub fn otThreadRegisterParentResponseCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadParentResponseCallback,
        aContext: *mut ::core::ffi::c_void,
    );
}
/// Represents the Thread Discovery Request data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otThreadDiscoveryRequestInfo {
    ///< IEEE 802.15.4 Extended Address of the requester
    pub mExtAddress: otExtAddress,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otThreadDiscoveryRequestInfo {
    #[inline]
    pub fn mVersion(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mVersion_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mVersion_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mIsJoiner(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoiner(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mIsJoiner_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mIsJoiner_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mVersion: u8, mIsJoiner: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u8 = unsafe { ::core::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsJoiner: u8 = unsafe { ::core::mem::transmute(mIsJoiner) };
            mIsJoiner as u64
        });
        __bindgen_bitfield_unit
    }
}
/// Pointer is called every time an MLE Discovery Request message is received.
///
/// @param[in]  aInfo     A pointer to the Discovery Request info data.
/// @param[in]  aContext  A pointer to callback application-specific context.
pub type otThreadDiscoveryRequestCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aInfo: *const otThreadDiscoveryRequestInfo,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    /// Sets a callback to receive MLE Discovery Request data.
    ///
    /// @param[in]  aInstance  A pointer to an OpenThread instance.
    /// @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Discovery Request message.
    /// @param[in]  aContext   A pointer to callback application-specific context.
    pub fn otThreadSetDiscoveryRequestCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadDiscoveryRequestCallback,
        aContext: *mut ::core::ffi::c_void,
    );
}
/// Pointer type defines the callback to notify the outcome of a `otThreadLocateAnycastDestination()`
/// request.
///
/// @param[in] aContext            A pointer to an arbitrary context (provided when callback is registered).
/// @param[in] aError              The error when handling the request. OT_ERROR_NONE indicates success.
///                                OT_ERROR_RESPONSE_TIMEOUT indicates a destination could not be found.
///                                OT_ERROR_ABORT indicates the request was aborted.
/// @param[in] aMeshLocalAddress   A pointer to the mesh-local EID of the closest destination of the anycast address
///                                when @p aError is OT_ERROR_NONE, NULL otherwise.
/// @param[in] aRloc16             The RLOC16 of the destination if found, otherwise invalid RLOC16 (0xfffe).
pub type otThreadAnycastLocatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::core::ffi::c_void,
        aError: otError,
        aMeshLocalAddress: *const otIp6Address,
        aRloc16: u16,
    ),
>;
unsafe extern "C" {
    /// Requests the closest destination of a given anycast address to be located.
    ///
    /// Is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.
    ///
    /// If a previous request is ongoing, a subsequent call to this function will cancel and replace the earlier request.
    ///
    /// @param[in] aInstance         A pointer to an OpenThread instance.
    /// @param[in] aAnycastAddress   The anycast address to locate. MUST NOT be NULL.
    /// @param[in] aCallback         The callback function to report the result.
    /// @param[in] aContext          An arbitrary context used with @p aCallback.
    ///
    /// @retval OT_ERROR_NONE          The request started successfully. @p aCallback will be invoked to report the result.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aAnycastAddress is not a valid anycast address or @p aCallback is NULL.
    /// @retval OT_ERROR_NO_BUFS       Out of buffer to prepare and send the request message.
    pub fn otThreadLocateAnycastDestination(
        aInstance: *mut otInstance,
        aAnycastAddress: *const otIp6Address,
        aCallback: otThreadAnycastLocatorCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Indicates whether an anycast locate request is currently in progress.
    ///
    /// Is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns TRUE if an anycast locate request is currently in progress, FALSE otherwise.
    pub fn otThreadIsAnycastLocateInProgress(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Sends a Proactive Address Notification (ADDR_NTF.ntf) message.
    ///
    /// Is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.
    ///
    /// @param[in]  aInstance     A pointer to an OpenThread instance.
    /// @param[in]  aDestination  The destination to send the ADDR_NTF.ntf message.
    /// @param[in]  aTarget       The target address of the ADDR_NTF.ntf message.
    /// @param[in]  aMlIid        The ML-IID of the ADDR_NTF.ntf message.
    pub fn otThreadSendAddressNotification(
        aInstance: *mut otInstance,
        aDestination: *mut otIp6Address,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
    );
}
unsafe extern "C" {
    /// Sends a Proactive Backbone Notification (PRO_BB.ntf) message on the Backbone link.
    ///
    /// Is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.
    ///
    /// @param[in]  aInstance                    A pointer to an OpenThread instance.
    /// @param[in]  aTarget                      The target address of the PRO_BB.ntf message.
    /// @param[in]  aMlIid                       The ML-IID of the PRO_BB.ntf message.
    /// @param[in]  aTimeSinceLastTransaction    Time since last transaction (in seconds).
    ///
    /// @retval OT_ERROR_NONE           Successfully sent PRO_BB.ntf on backbone link.
    /// @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.
    pub fn otThreadSendProactiveBackboneNotification(
        aInstance: *mut otInstance,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
        aTimeSinceLastTransaction: u32,
    ) -> otError;
}
unsafe extern "C" {
    /// Notifies other nodes in the network (if any) and then stops Thread protocol operation.
    ///
    /// It sends an Address Release if it's a router, or sets its child timeout to 0 if it's a child.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    /// @param[in] aCallback A pointer to a function that is called upon finishing detaching.
    /// @param[in] aContext  A pointer to callback application-specific context.
    ///
    /// @retval OT_ERROR_NONE Successfully started detaching.
    /// @retval OT_ERROR_BUSY Detaching is already in progress.
    pub fn otThreadDetachGracefully(
        aInstance: *mut otInstance,
        aCallback: otDetachGracefullyCallback,
        aContext: *mut ::core::ffi::c_void,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts an `uint32_t` duration (in seconds) to a human-readable string.
    ///
    /// Requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.
    ///
    /// The string follows the format "<hh>:<mm>:<ss>" for hours, minutes, seconds (if duration is shorter than one day) or
    /// "<dd>d.<hh>:<mm>:<ss>" (if longer than a day).
    ///
    /// If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated
    /// but the outputted string is always null-terminated.
    ///
    /// Is intended for use with `mAge` or `mConnectionTime` in `otNeighborInfo` or `otChildInfo` structures.
    ///
    /// @param[in]  aDuration A duration interval in seconds.
    /// @param[out] aBuffer   A pointer to a char array to output the string.
    /// @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_DURATION_STRING_SIZE`.
    pub fn otConvertDurationInSecondsToString(
        aDuration: u32,
        aBuffer: *mut ::core::ffi::c_char,
        aSize: u16,
    );
}
unsafe extern "C" {
    /// Sets the store frame counter ahead.
    ///
    /// Requires `OPENTHREAD_CONFIG_DYNAMIC_STORE_FRAME_AHEAD_COUNTER_ENABLE` to be enabled.
    ///
    /// The OpenThread stack stores the MLE and MAC security frame counter values in non-volatile storage,
    /// ensuring they persist across device resets. These saved values are set to be ahead of their current
    /// values by the "frame counter ahead" value.
    ///
    /// @param[in] aInstance                  A pointer to an OpenThread instance.
    /// @param[in] aStoreFrameCounterAhead    The store frame counter ahead to set.
    pub fn otThreadSetStoreFrameCounterAhead(
        aInstance: *mut otInstance,
        aStoreFrameCounterAhead: u32,
    );
}
unsafe extern "C" {
    /// Gets the store frame counter ahead.
    ///
    /// Requires `OPENTHREAD_CONFIG_DYNAMIC_STORE_FRAME_AHEAD_COUNTER_ENABLE` to be enabled.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @returns The current store frame counter ahead.
    pub fn otThreadGetStoreFrameCounterAhead(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Run all queued OpenThread tasklets at the time this is called.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    pub fn otTaskletsProcess(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Indicates whether or not OpenThread has tasklets pending.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    ///
    /// @retval TRUE   If there are tasklets pending.
    /// @retval FALSE  If there are no tasklets pending.
    pub fn otTaskletsArePending(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// OpenThread calls this function when the tasklet queue transitions from empty to non-empty.
    ///
    /// @param[in] aInstance A pointer to an OpenThread instance.
    pub fn otTaskletsSignalPending(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Set the alarm to fire at @p aDt milliseconds after @p aT0.
    ///
    /// For @p aT0 the platform MUST support all values in [0, 2^32-1].
    /// For @p aDt, the platform MUST support all values in [0, 2^31-1].
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aT0        The reference time.
    /// @param[in] aDt        The time delay in milliseconds from @p aT0.
    pub fn otPlatAlarmMilliStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
unsafe extern "C" {
    /// Stop the alarm.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatAlarmMilliStop(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Get the current time.
    ///
    /// The current time MUST represent a free-running timer. When maintaining current time, the time value MUST utilize the
    /// entire range [0, 2^32-1] and MUST NOT wrap before 2^32.
    ///
    /// @returns The current time in milliseconds.
    pub fn otPlatAlarmMilliGetNow() -> u32;
}
unsafe extern "C" {
    /// Signal that the alarm has fired.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatAlarmMilliFired(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Signal diagnostics module that the alarm has fired.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatDiagAlarmFired(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Performs a software reset on the platform, if supported.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatReset(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Performs a hardware reset on the platform to launch bootloader mode, if supported.
    ///
    /// Used when `OPENTHREAD_CONFIG_PLATFORM_BOOTLOADER_MODE_ENABLE` is enabled.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    ///
    /// @retval OT_ERROR_NONE         Reset to bootloader successfully.
    /// @retval OT_ERROR_BUSY         Failed due to another operation is ongoing.
    /// @retval OT_ERROR_NOT_CAPABLE  Not capable of resetting to bootloader.
    pub fn otPlatResetToBootloader(aInstance: *mut otInstance) -> otError;
}
pub const otPlatResetReason_OT_PLAT_RESET_REASON_POWER_ON: otPlatResetReason = 0;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_EXTERNAL: otPlatResetReason = 1;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_SOFTWARE: otPlatResetReason = 2;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_FAULT: otPlatResetReason = 3;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_CRASH: otPlatResetReason = 4;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_ASSERT: otPlatResetReason = 5;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_OTHER: otPlatResetReason = 6;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_UNKNOWN: otPlatResetReason = 7;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_WATCHDOG: otPlatResetReason = 8;
pub const otPlatResetReason_OT_PLAT_RESET_REASON_COUNT: otPlatResetReason = 9;
/// Enumeration of possible reset reason codes.
///
/// These are in the same order as the Spinel reset reason codes.
pub type otPlatResetReason = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Returns the reason for the last platform reset.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatGetResetReason(aInstance: *mut otInstance) -> otPlatResetReason;
}
unsafe extern "C" {
    /// Provides a platform specific implementation for assert.
    ///
    /// @param[in] aFilename    The name of the file where the assert occurred.
    /// @param[in] aLineNumber  The line number in the file where the assert occurred.
    pub fn otPlatAssertFail(aFilename: *const ::core::ffi::c_char, aLineNumber: ::core::ffi::c_int);
}
unsafe extern "C" {
    /// Performs a platform specific operation to wake the host MCU.
    /// This is used only for NCP configurations.
    pub fn otPlatWakeHost();
}
/// NCP's MCU stays on and active all the time.
///
/// When the NCP's desired power state is set to `ON`, host can send messages to NCP without requiring any "poke" or
/// external triggers.
///
/// @note The `ON` power state only determines the MCU's power mode and is not related to radio's state.
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_ON: otPlatMcuPowerState = 0;
/// NCP's MCU can enter low-power (energy-saving) state.
///
/// When the NCP's desired power state is set to `LOW_POWER`, host is expected to "poke" the NCP (e.g., an external
/// trigger like an interrupt) before it can communicate with the NCP (send a message to the NCP). The "poke"
/// mechanism is determined by the platform code (based on NCP's interface to the host).
///
/// While power state is set to `LOW_POWER`, NCP can still (at any time) send messages to host. Note that receiving
/// a message from the NCP does NOT indicate that the NCP's power state has changed, i.e., host is expected to
/// continue to "poke" when it wants to talk to the NCP until the power state is explicitly changed (by a successful
/// call to `otPlatSetMcuPowerState()` changing the state to `ON`).
///
/// @note The `LOW_POWER` power state only determines the MCU's power mode and is not related to radio's state
/// (radio is managed by OpenThread core and device role, e.g., device being sleepy or not.
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_LOW_POWER: otPlatMcuPowerState = 1;
/// NCP is fully off.
///
/// An NCP hardware reset (via a RESET pin) is required to bring the NCP back to `SPINEL_MCU_POWER_STATE_ON`.
/// RAM is not retained after reset.
pub const otPlatMcuPowerState_OT_PLAT_MCU_POWER_STATE_OFF: otPlatMcuPowerState = 2;
/// Enumeration of micro-controller's power states.
///
/// These values are used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL` is enabled.
///
/// The power state specifies the desired power state of NCP's micro-controller (MCU) when the underlying platform's
/// operating system enters idle mode (i.e., all active tasks/events are processed and the MCU can potentially enter a
/// energy-saving power state).
///
/// The power state primarily determines how the host should interact with the NCP and whether the host needs an
/// external trigger (a "poke") to NCP before it can communicate with the NCP or not.
///
/// After a reset, the MCU power state MUST be `OT_PLAT_POWER_STATE_ON`.
pub type otPlatMcuPowerState = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Sets the desired MCU power state.
    ///
    /// This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`
    /// is enabled.
    ///
    /// @param[in] aInstance      A pointer to OpenThread instance.
    /// @param[in] aState         The new MCU power state.
    ///
    /// @retval OT_ERROR_NONE     The power state updated successfully.
    /// @retval OT_ERROR_FAILED   The given MCU power state is not supported by the platform.
    pub fn otPlatSetMcuPowerState(
        aInstance: *mut otInstance,
        aState: otPlatMcuPowerState,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the current desired MCU power state.
    ///
    /// This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`
    /// is enabled.
    ///
    /// After a reset, the power state MUST return `OT_PLAT_POWER_STATE_ON`. During operation, power state SHOULD only
    /// change through an explicit successful call to `otPlatSetMcuPowerState()`.
    ///
    /// @param[in] aInstance  A pointer to OpenThread instance.
    ///
    /// @returns The current power state.
    pub fn otPlatGetMcuPowerState(aInstance: *mut otInstance) -> otPlatMcuPowerState;
}
unsafe extern "C" {
    /// Logs a crash dump using OpenThread logging APIs
    ///
    /// @note This API is an optional logging platform API. It's up to the platform layer to implement it.
    ///
    /// @retval OT_ERROR_NONE            Crash dump was logged successfully
    /// @retval OT_ERROR_NOT_CAPABLE     Platform is not capable of logging a crash dump
    pub fn otPlatLogCrashDump() -> otError;
}
unsafe extern "C" {
    /// Fill buffer with entropy.
    ///
    /// MUST be implemented using a true random number generator (TRNG).
    ///
    /// @param[out]  aOutput              A pointer to where the true random values are placed.  Must not be NULL.
    /// @param[in]   aOutputLength        Size of @p aBuffer.
    ///
    /// @retval OT_ERROR_NONE          Successfully filled @p aBuffer with true random values.
    /// @retval OT_ERROR_FAILED        Failed to fill @p aBuffer with true random values.
    /// @retval OT_ERROR_INVALID_ARGS  @p aBuffer was set to NULL.
    pub fn otPlatEntropyGet(aOutput: *mut u8, aOutputLength: u16) -> otError;
}
///< Active Operational Dataset.
pub const OT_SETTINGS_KEY_ACTIVE_DATASET: _bindgen_ty_10 = 1;
///< Pending Operational Dataset.
pub const OT_SETTINGS_KEY_PENDING_DATASET: _bindgen_ty_10 = 2;
///< Thread network information.
pub const OT_SETTINGS_KEY_NETWORK_INFO: _bindgen_ty_10 = 3;
///< Parent information.
pub const OT_SETTINGS_KEY_PARENT_INFO: _bindgen_ty_10 = 4;
///< Child information.
pub const OT_SETTINGS_KEY_CHILD_INFO: _bindgen_ty_10 = 5;
///< SLAAC key to generate semantically opaque IID.
pub const OT_SETTINGS_KEY_SLAAC_IID_SECRET_KEY: _bindgen_ty_10 = 7;
///< Duplicate Address Detection (DAD) information.
pub const OT_SETTINGS_KEY_DAD_INFO: _bindgen_ty_10 = 8;
///< SRP client ECDSA public/private key pair.
pub const OT_SETTINGS_KEY_SRP_ECDSA_KEY: _bindgen_ty_10 = 11;
///< The SRP client info (selected SRP server address).
pub const OT_SETTINGS_KEY_SRP_CLIENT_INFO: _bindgen_ty_10 = 12;
///< The SRP server info (UDP port).
pub const OT_SETTINGS_KEY_SRP_SERVER_INFO: _bindgen_ty_10 = 13;
///< BR ULA prefix.
pub const OT_SETTINGS_KEY_BR_ULA_PREFIX: _bindgen_ty_10 = 15;
///< BR local on-link prefixes.
pub const OT_SETTINGS_KEY_BR_ON_LINK_PREFIXES: _bindgen_ty_10 = 16;
///< Unique Border Agent/Router ID.
pub const OT_SETTINGS_KEY_BORDER_AGENT_ID: _bindgen_ty_10 = 17;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MIN: _bindgen_ty_10 = 32768;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MAX: _bindgen_ty_10 = 65535;
/// Defines the keys of settings.
///
/// Note: When adding a new settings key, if the settings corresponding to the key contains security sensitive
///       information, the developer MUST add the key to the array `aSensitiveKeys` which is passed in
///       `otPlatSettingsInit()`.
pub type _bindgen_ty_10 = ::core::ffi::c_uint;
unsafe extern "C" {
    /// Performs any initialization for the settings subsystem, if necessary.
    ///
    /// Also sets the sensitive keys that should be stored in the secure area.
    ///
    /// Note that the memory pointed by @p aSensitiveKeys MUST not be released before @p aInstance is destroyed.
    ///
    /// @param[in]  aInstance             The OpenThread instance structure.
    /// @param[in]  aSensitiveKeys        A pointer to an array containing the list of sensitive keys. May be NULL only if
    ///                                   @p aSensitiveKeysLength is 0, which means that there is no sensitive keys.
    /// @param[in]  aSensitiveKeysLength  The number of entries in the @p aSensitiveKeys array.
    pub fn otPlatSettingsInit(
        aInstance: *mut otInstance,
        aSensitiveKeys: *const u16,
        aSensitiveKeysLength: u16,
    );
}
unsafe extern "C" {
    /// Performs any de-initialization for the settings subsystem, if necessary.
    ///
    /// @param[in]  aInstance The OpenThread instance structure.
    pub fn otPlatSettingsDeinit(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Fetches the value of a setting.
    ///
    /// Fetches the value of the setting identified
    /// by @p aKey and write it to the memory pointed to by aValue.
    /// It then writes the length to the integer pointed to by
    /// @p aValueLength. The initial value of @p aValueLength is the
    /// maximum number of bytes to be written to @p aValue.
    ///
    /// Can be used to check for the existence of
    /// a key without fetching the value by setting @p aValue and
    /// @p aValueLength to NULL. You can also check the length of
    /// the setting without fetching it by setting only aValue
    /// to NULL.
    ///
    /// Note that the underlying storage implementation is not
    /// required to maintain the order of settings with multiple
    /// values. The order of such values MAY change after ANY
    /// write operation to the store.
    ///
    /// @param[in]      aInstance     The OpenThread instance structure.
    /// @param[in]      aKey          The key associated with the requested setting.
    /// @param[in]      aIndex        The index of the specific item to get.
    /// @param[out]     aValue        A pointer to where the value of the setting should be written. May be set to NULL if
    ///                               just testing for the presence or length of a setting.
    /// @param[in,out]  aValueLength  A pointer to the length of the value. When called, this pointer should point to an
    ///                               integer containing the maximum value size that can be written to @p aValue. At return,
    ///                               the actual length of the setting is written. This may be set to NULL if performing
    ///                               a presence check.
    ///
    /// @retval OT_ERROR_NONE             The given setting was found and fetched successfully.
    /// @retval OT_ERROR_NOT_FOUND        The given setting was not found in the setting store.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.
    pub fn otPlatSettingsGet(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::core::ffi::c_int,
        aValue: *mut u8,
        aValueLength: *mut u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Sets or replaces the value of a setting.
    ///
    /// Sets or replaces the value of a setting
    /// identified by @p aKey.
    ///
    /// Calling this function successfully may cause unrelated
    /// settings with multiple values to be reordered.
    ///
    /// OpenThread stack guarantees to use `otPlatSettingsSet()`
    /// method for a @p aKey that was either previously set using
    /// `otPlatSettingsSet()` (i.e., contains a single value) or
    /// is empty and/or fully deleted (contains no value).
    ///
    /// Platform layer can rely and use this fact for optimizing
    /// its implementation.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[in]  aKey          The key associated with the setting to change.
    /// @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL if
    ///                           @p aValueLength is non-zero.
    /// @param[in]  aValueLength  The length of the data pointed to by aValue. May be zero.
    ///
    /// @retval OT_ERROR_NONE             The given setting was changed or staged.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.
    /// @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting.
    pub fn otPlatSettingsSet(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Adds a value to a setting.
    ///
    /// Adds the value to a setting
    /// identified by @p aKey, without replacing any existing
    /// values.
    ///
    /// Note that the underlying implementation is not required
    /// to maintain the order of the items associated with a
    /// specific key. The added value may be added to the end,
    /// the beginning, or even somewhere in the middle. The order
    /// of any pre-existing values may also change.
    ///
    /// Calling this function successfully may cause unrelated
    /// settings with multiple values to be reordered.
    ///
    /// OpenThread stack guarantees to use `otPlatSettingsAdd()`
    /// method for a @p aKey that was either previously managed by
    /// `otPlatSettingsAdd()` (i.e., contains one or more items) or
    /// is empty and/or fully deleted (contains no value).
    ///
    /// Platform layer can rely and use this fact for optimizing
    /// its implementation.
    ///
    /// @param[in]  aInstance     The OpenThread instance structure.
    /// @param[in]  aKey          The key associated with the setting to change.
    /// @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL
    ///                           if @p aValueLength is non-zero.
    /// @param[in]  aValueLength  The length of the data pointed to by @p aValue. May be zero.
    ///
    /// @retval OT_ERROR_NONE             The given setting was added or staged to be added.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.
    /// @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting.
    pub fn otPlatSettingsAdd(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes a setting from the setting store.
    ///
    /// Deletes a specific value from the
    /// setting identified by aKey from the settings store.
    ///
    /// Note that the underlying implementation is not required
    /// to maintain the order of the items associated with a
    /// specific key.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    /// @param[in] aKey       The key associated with the requested setting.
    /// @param[in] aIndex     The index of the value to be removed. If set to -1, all values for this @p aKey will be
    ///                       removed.
    ///
    /// @retval OT_ERROR_NONE             The given key and index was found and removed successfully.
    /// @retval OT_ERROR_NOT_FOUND        The given key or index was not found in the setting store.
    /// @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.
    pub fn otPlatSettingsDelete(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::core::ffi::c_int,
    ) -> otError;
}
unsafe extern "C" {
    /// Removes all settings from the setting store.
    ///
    /// Deletes all settings from the settings
    /// store, resetting it to its initial factory state.
    ///
    /// @param[in] aInstance  The OpenThread instance structure.
    pub fn otPlatSettingsWipe(aInstance: *mut otInstance);
}
/// Represents a TXT record entry representing a key/value pair (RFC 6763 - section 6.3).
///
/// The string buffers pointed to by `mKey` and `mValue` MUST persist and remain unchanged after an instance of such
/// structure is passed to OpenThread (as part of `otSrpClientService` instance).
///
/// An array of `otDnsTxtEntry` entries are used in `otSrpClientService` to specify the full TXT record (a list of
/// entries).
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsTxtEntry {
    /// The TXT record key string.
    ///
    /// If `mKey` is not NULL, then it MUST be a null-terminated C string. The entry is treated as key/value pair with
    /// `mValue` buffer providing the value.
    ///   - The entry is encoded as follows:
    ///        - A single string length byte followed by "key=value" format (without the quotation marks).
    ///- In this case, the overall encoded length must be 255 bytes or less.
    ///   - If `mValue` is NULL, then key is treated as a boolean attribute and encoded as "key" (with no `=`).
    ///   - If `mValue` is not NULL but `mValueLength` is zero, then it is treated as empty value and encoded as "key=".
    ///
    /// If `mKey` is NULL, then `mValue` buffer is treated as an already encoded TXT-DATA and is appended as is in the
    /// DNS message.
    pub mKey: *const ::core::ffi::c_char,
    ///< The TXT record value or already encoded TXT-DATA (depending on `mKey`).
    pub mValue: *const u8,
    ///< Number of bytes in `mValue` buffer.
    pub mValueLength: u16,
}
/// Represents an iterator for TXT record entries (key/value pairs).
///
/// The data fields in this structure are intended for use by OpenThread core and caller should not read or change them.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsTxtEntryIterator {
    pub mPtr: *const ::core::ffi::c_void,
    pub mData: [u16; 2usize],
    pub mChar: [::core::ffi::c_char; 65usize],
}
unsafe extern "C" {
    /// Initializes a TXT record iterator.
    ///
    /// The buffer pointer @p aTxtData and its content MUST persist and remain unchanged while @p aIterator object
    /// is being used.
    ///
    /// @param[in] aIterator       A pointer to the iterator to initialize (MUST NOT be NULL).
    /// @param[in] aTxtData        A pointer to buffer containing the encoded TXT data.
    /// @param[in] aTxtDataLength  The length (number of bytes) of @p aTxtData.
    pub fn otDnsInitTxtEntryIterator(
        aIterator: *mut otDnsTxtEntryIterator,
        aTxtData: *const u8,
        aTxtDataLength: u16,
    );
}
unsafe extern "C" {
    /// Parses the TXT data from an iterator and gets the next TXT record entry (key/value pair).
    ///
    /// The @p aIterator MUST be initialized using `otDnsInitTxtEntryIterator()` before calling this function and the TXT
    /// data buffer used to initialize the iterator MUST persist and remain unchanged. Otherwise the behavior of this
    /// function is undefined.
    ///
    /// If the parsed key string length is smaller than or equal to `OT_DNS_TXT_KEY_ITER_MAX_LENGTH` the key string is
    /// returned in `mKey` in @p aEntry. But if the key is longer, then `mKey` is set to NULL and the entire encoded TXT
    /// entry string is returned in `mValue` and `mValueLength`.
    ///
    /// @param[in]  aIterator   A pointer to the iterator (MUST NOT be NULL).
    /// @param[out] aEntry      A pointer to a `otDnsTxtEntry` structure to output the parsed/read entry (MUST NOT be NULL).
    ///
    /// @retval OT_ERROR_NONE       The next entry was parsed successfully. @p aEntry is updated.
    /// @retval OT_ERROR_NOT_FOUND  No more entries in the TXT data.
    /// @retval OT_ERROR_PARSE      The TXT data from @p aIterator is not well-formed.
    pub fn otDnsGetNextTxtEntry(
        aIterator: *mut otDnsTxtEntryIterator,
        aEntry: *mut otDnsTxtEntry,
    ) -> otError;
}
unsafe extern "C" {
    /// Encodes a given list of TXT record entries (key/value pairs) into TXT data (following format specified by RFC 6763).
    ///
    /// @param[in]      aTxtEntries      Pointer to an array of `otDnsTxtEntry`.
    /// @param[in]      aNumTxtEntries   Number of entries in @p aTxtEntries array.
    /// @param[out]     aTxtData         A pointer to a buffer to output the encoded TXT data.
    /// @param[in,out]  aTxtDataLength   On input, size of buffer @p aTxtData. On output, length of the encoded TXT data.
    ///
    /// @retval OT_ERROR_NONE          Encoded TXT data successfully, @p aTxtData and @p aTxtDataLength are updated.
    /// @retval OT_ERROR_INVALID_ARGS  The @p aTxtEntries is not valid.
    /// @retval OT_ERROR_NO_BUS        Could not fit the encoded data in @p aTxtData buffer with its @p aTxtDataLength.
    pub fn otDnsEncodeTxtData(
        aTxtEntries: *const otDnsTxtEntry,
        aNumTxtEntries: u16,
        aTxtData: *mut u8,
        aTxtDataLength: *mut u16,
    ) -> otError;
}
unsafe extern "C" {
    /// Enables/disables the "DNS name compression" mode.
    ///
    /// By default DNS name compression is enabled. When disabled, DNS names are appended as full and never compressed. This
    /// is applicable to OpenThread's DNS and SRP client/server modules.
    ///
    /// This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.
    ///
    /// Note that in the case `OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE` is used, this mode applies to all OpenThread
    /// instances (i.e., calling this function enables/disables the compression mode on all OpenThread instances).
    ///
    /// @param[in] aEnabled   TRUE to enable the "DNS name compression" mode, FALSE to disable.
    pub fn otDnsSetNameCompressionEnabled(aEnabled: bool);
}
unsafe extern "C" {
    /// Indicates whether the "DNS name compression" mode is enabled or not.
    ///
    /// This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.
    ///
    /// @returns TRUE if the "DNS name compression" mode is enabled, FALSE otherwise.
    pub fn otDnsIsNameCompressionEnabled() -> bool;
}
///< Item to be added/registered.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_ADD: otSrpClientItemState = 0;
///< Item is being added/registered.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_ADDING: otSrpClientItemState = 1;
///< Item to be refreshed (re-register to renew lease).
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_REFRESH: otSrpClientItemState = 2;
///< Item is being refreshed.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REFRESHING: otSrpClientItemState = 3;
///< Item to be removed.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_TO_REMOVE: otSrpClientItemState = 4;
///< Item is being removed.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REMOVING: otSrpClientItemState = 5;
///< Item is registered with server.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REGISTERED: otSrpClientItemState = 6;
///< Item is removed.
pub const otSrpClientItemState_OT_SRP_CLIENT_ITEM_STATE_REMOVED: otSrpClientItemState = 7;
/// Specifies an SRP client item (service or host info) state.
pub type otSrpClientItemState = ::core::ffi::c_uint;
/// Represents an SRP client host info.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSrpClientHostInfo {
    ///< Host name (label) string (NULL if not yet set).
    pub mName: *const ::core::ffi::c_char,
    ///< Array of host IPv6 addresses (NULL if not set or auto address is enabled).
    pub mAddresses: *const otIp6Address,
    ///< Number of IPv6 addresses in `mAddresses` array.
    pub mNumAddresses: u8,
    ///< Indicates whether auto address mode is enabled or not.
    pub mAutoAddress: bool,
    ///< Host info state.
    pub mState: otSrpClientItemState,
}
/// Represents an SRP client service.
///
/// The values in this structure, including the string buffers for the names and the TXT record entries, MUST persist
/// and stay constant after an instance of this structure is passed to OpenThread from `otSrpClientAddService()` or
/// `otSrpClientRemoveService()`.
///
/// The `mState`, `mData`, `mNext` fields are used/managed by OT core only. Their value is ignored when an instance of
/// `otSrpClientService` is passed in `otSrpClientAddService()` or `otSrpClientRemoveService()` or other functions. The
/// caller does not need to set these fields.
///
/// The `mLease` and `mKeyLease` fields specify the desired lease and key lease intervals for this service. Zero value
/// indicates that the interval is unspecified and then the default lease or key lease intervals from
/// `otSrpClientGetLeaseInterval()` and `otSrpClientGetKeyLeaseInterval()` are used for this service. If the key lease
/// interval (whether set explicitly or determined from the default) is shorter than the lease interval for a service,
/// SRP client will re-use the lease interval value for key lease interval as well. For example, if in service `mLease`
/// is explicitly set to 2 days and `mKeyLease` is set to zero and default key lease is set to 1 day, then when
/// registering this service, the requested key lease for this service is also set to 2 days.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSrpClientService {
    ///< The service labels (e.g., "_mt._udp", not the full domain name).
    pub mName: *const ::core::ffi::c_char,
    ///< The service instance name label (not the full name).
    pub mInstanceName: *const ::core::ffi::c_char,
    ///< Array of sub-type labels (must end with `NULL` or can be `NULL`).
    pub mSubTypeLabels: *const *const ::core::ffi::c_char,
    ///< Array of TXT entries (`mNumTxtEntries` gives num of entries).
    pub mTxtEntries: *const otDnsTxtEntry,
    ///< The service port number.
    pub mPort: u16,
    ///< The service priority.
    pub mPriority: u16,
    ///< The service weight.
    pub mWeight: u16,
    ///< Number of entries in the `mTxtEntries` array.
    pub mNumTxtEntries: u8,
    ///< Service state (managed by OT core).
    pub mState: otSrpClientItemState,
    ///< Internal data (used by OT core).
    pub mData: u32,
    ///< Pointer to next entry in a linked-list (managed by OT core).
    pub mNext: *mut otSrpClientService,
    ///< Desired lease interval in sec - zero to use default.
    pub mLease: u32,
    ///< Desired key lease interval in sec - zero to use default.
    pub mKeyLease: u32,
}
/// Pointer type defines the callback used by SRP client to notify user of changes/events/errors.
///
/// This callback is invoked on a successful registration of an update (i.e., add/remove of host-info and/or some
/// service(s)) with the SRP server, or if there is a failure or error (e.g., server rejects a update request or client
/// times out waiting for response, etc).
///
/// In case of a successful reregistration of an update, `aError` parameter would be `OT_ERROR_NONE` and the host info
/// and the full list of services is provided as input parameters to the callback. Note that host info and services each
/// track its own state in the corresponding `mState` member variable of the related data structure (the state
/// indicating whether the host-info/service is registered or removed or still being added/removed, etc).
///
/// The list of removed services is passed as its own linked-list `aRemovedServices` in the callback. Note that when the
/// callback is invoked, the SRP client (OpenThread implementation) is done with the removed service instances listed in
/// `aRemovedServices` and no longer tracks/stores them (i.e., if from the callback we call `otSrpClientGetServices()`
/// the removed services will not be present in the returned list). Providing a separate list of removed services in
/// the callback helps indicate to user which items are now removed and allow user to re-claim/reuse the instances.
///
/// If the server rejects an SRP update request, the DNS response code (RFC 2136) is mapped to the following errors:
///
///  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE
///  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE
///  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED
///  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND
///  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED
///  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY
///  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED
///  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED
///  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND
///  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY
///  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE
///  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE
///  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY
///  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE
///  - Other response codes                                           -> OT_ERROR_FAILED
///
/// The following errors are also possible:
///
///  - OT_ERROR_RESPONSE_TIMEOUT : Timed out waiting for response from server (client would continue to retry).
///  - OT_ERROR_INVALID_ARGS     : The provided service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).
///  - OT_ERROR_NO_BUFS          : Insufficient buffer to prepare or send the update message.
///
/// Note that in case of any failure, the client continues the operation, i.e. it prepares and (re)transmits the SRP
/// update message to the server, after some wait interval. The retry wait interval starts from the minimum value and
/// is increased by the growth factor every failure up to the max value (please see configuration parameter
/// `OPENTHREAD_CONFIG_SRP_CLIENT_MIN_RETRY_WAIT_INTERVAL` and the related ones for more details).
///
/// @param[in] aError            The error (see above).
/// @param[in] aHostInfo         A pointer to host info.
/// @param[in] aServices         The head of linked-list containing all services (excluding the ones removed). NULL if
///                              the list is empty.
/// @param[in] aRemovedServices  The head of linked-list containing all removed services. NULL if the list is empty.
/// @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).
pub type otSrpClientCallback = ::core::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aHostInfo: *const otSrpClientHostInfo,
        aServices: *const otSrpClientService,
        aRemovedServices: *const otSrpClientService,
        aContext: *mut ::core::ffi::c_void,
    ),
>;
/// Pointer type defines the callback used by SRP client to notify user when it is auto-started or stopped.
///
/// This is only used when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.
///
/// This callback is invoked when auto-start mode is enabled and the SRP client is either automatically started or
/// stopped.
///
/// @param[in] aServerSockAddr   A non-NULL pointer indicates SRP server was started and pointer will give the
///                              selected server socket address. A NULL pointer indicates SRP server was stopped.
/// @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).
pub type otSrpClientAutoStartCallback = ::core::option::Option<
    unsafe extern "C" fn(aServerSockAddr: *const otSockAddr, aContext: *mut ::core::ffi::c_void),
>;
unsafe extern "C" {
    /// Starts the SRP client operation.
    ///
    /// SRP client will prepare and send "SRP Update" message to the SRP server once all the following conditions are met:
    ///
    ///  - The SRP client is started - `otSrpClientStart()` is called.
    ///  - Host name is set - `otSrpClientSetHostName()` is called.
    ///  - At least one host IPv6 address is set - `otSrpClientSetHostAddresses()` is called.
    ///  - At least one service is added - `otSrpClientAddService()` is called.
    ///
    /// It does not matter in which order these functions are called. When all conditions are met, the SRP client will
    /// wait for a short delay before preparing an "SRP Update" message and sending it to server. This delay allows for user
    /// to add multiple services and/or IPv6 addresses before the first SRP Update message is sent (ensuring a single SRP
    /// Update is sent containing all the info). The config `OPENTHREAD_CONFIG_SRP_CLIENT_UPDATE_TX_DELAY` specifies the
    /// delay interval.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    /// @param[in] aServerSockAddr  The socket address (IPv6 address and port number) of the SRP server.
    ///
    /// @retval OT_ERROR_NONE       SRP client operation started successfully or it is already running with same server
    ///                             socket address and callback.
    /// @retval OT_ERROR_BUSY       SRP client is busy running with a different socket address.
    /// @retval OT_ERROR_FAILED     Failed to open/connect the client's UDP socket.
    pub fn otSrpClientStart(
        aInstance: *mut otInstance,
        aServerSockAddr: *const otSockAddr,
    ) -> otError;
}
unsafe extern "C" {
    /// Stops the SRP client operation.
    ///
    /// Stops any further interactions with the SRP server. Note that it does not remove or clear host info
    /// and/or list of services. It marks all services to be added/removed again once the client is (re)started.
    ///
    /// @param[in] aInstance       A pointer to the OpenThread instance.
    pub fn otSrpClientStop(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Indicates whether the SRP client is running or not.
    ///
    /// @param[in] aInstance       A pointer to the OpenThread instance.
    ///
    /// @returns TRUE if the SRP client is running, FALSE otherwise.
    pub fn otSrpClientIsRunning(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Gets the socket address (IPv6 address and port number) of the SRP server which is being used by SRP
    /// client.
    ///
    /// If the client is not running, the address is unspecified (all zero) with zero port number.
    ///
    /// @param[in] aInstance       A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to the SRP server's socket address (is always non-NULL).
    pub fn otSrpClientGetServerAddress(aInstance: *mut otInstance) -> *const otSockAddr;
}
unsafe extern "C" {
    /// Sets the callback to notify caller of events/changes from SRP client.
    ///
    /// The SRP client allows a single callback to be registered. So consecutive calls to this function will overwrite any
    /// previously set callback functions.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aCallback   The callback to notify of events and changes. Can be NULL if not needed.
    /// @param[in] aContext    An arbitrary context used with @p aCallback.
    pub fn otSrpClientSetCallback(
        aInstance: *mut otInstance,
        aCallback: otSrpClientCallback,
        aContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Enables the auto-start mode.
    ///
    /// This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.
    ///
    /// Config option `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_DEFAULT_MODE` specifies the default auto-start mode (whether
    /// it is enabled or disabled at the start of OT stack).
    ///
    /// When auto-start is enabled, the SRP client will monitor the Thread Network Data to discover SRP servers and select
    /// the preferred server and automatically start and stop the client when an SRP server is detected.
    ///
    /// There are three categories of Network Data entries indicating presence of SRP sever. They are preferred in the
    /// following order:
    ///
    ///   1) Preferred unicast entries where server address is included in the service data. If there are multiple options,
    ///      the one with numerically lowest IPv6 address is preferred.
    ///
    ///   2) Anycast entries each having a seq number. A larger sequence number in the sense specified by Serial Number
    ///      Arithmetic logic in RFC-1982 is considered more recent and therefore preferred. The largest seq number using
    ///      serial number arithmetic is preferred if it is well-defined (i.e., the seq number is larger than all other
    ///      seq numbers). If it is not well-defined, then the numerically largest seq number is preferred.
    ///
    ///   3) Unicast entries where the server address info is included in server data. If there are multiple options, the
    ///      one with numerically lowest IPv6 address is preferred.
    ///
    /// When there is a change in the Network Data entries, client will check that the currently selected server is still
    /// present in the Network Data and is still the preferred one. Otherwise the client will switch to the new preferred
    /// server or stop if there is none.
    ///
    /// When the SRP client is explicitly started through a successful call to `otSrpClientStart()`, the given SRP server
    /// address in `otSrpClientStart()` will continue to be used regardless of the state of auto-start mode and whether the
    /// same SRP server address is discovered or not in the Thread Network Data. In this case, only an explicit
    /// `otSrpClientStop()` call will stop the client.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aCallback   A callback to notify when client is auto-started/stopped. Can be NULL if not needed.
    /// @param[in] aContext    A context to be passed when invoking @p aCallback.
    pub fn otSrpClientEnableAutoStartMode(
        aInstance: *mut otInstance,
        aCallback: otSrpClientAutoStartCallback,
        aContext: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    /// Disables the auto-start mode.
    ///
    /// This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.
    ///
    /// Disabling the auto-start mode will not stop the client if it is already running but the client stops monitoring
    /// the Thread Network Data to verify that the selected SRP server is still present in it.
    ///
    /// Note that a call to `otSrpClientStop()` will also disable the auto-start mode.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    pub fn otSrpClientDisableAutoStartMode(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Indicates the current state of auto-start mode (enabled or disabled).
    ///
    /// This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    ///
    /// @returns TRUE if the auto-start mode is enabled, FALSE otherwise.
    pub fn otSrpClientIsAutoStartModeEnabled(aInstance: *mut otInstance) -> bool;
}
unsafe extern "C" {
    /// Gets the TTL value in every record included in SRP update requests.
    ///
    /// Note that this is the TTL requested by the SRP client. The server may choose to accept a different TTL.
    ///
    /// By default, the TTL will equal the lease interval. Passing 0 or a value larger than the lease interval via
    /// `otSrpClientSetTtl()` will also cause the TTL to equal the lease interval.
    ///
    /// @param[in] aInstance  A pointer to the OpenThread instance.
    ///
    /// @returns The TTL (in seconds).
    pub fn otSrpClientGetTtl(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the TTL value in every record included in SRP update requests.
    ///
    /// Changing the TTL does not impact the TTL of already registered services/host-info.
    /// It only affects future SRP update messages (i.e., adding new services and/or refreshes of the existing services).
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aTtl        The TTL (in seconds). If value is zero or greater than lease interval, the TTL is set to the
    ///                        lease interval.
    pub fn otSrpClientSetTtl(aInstance: *mut otInstance, aTtl: u32);
}
unsafe extern "C" {
    /// Gets the default lease interval used in SRP update requests.
    ///
    /// The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.
    ///
    /// Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease
    /// interval.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    ///
    /// @returns The lease interval (in seconds).
    pub fn otSrpClientGetLeaseInterval(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the default lease interval used in SRP update requests.
    ///
    /// The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.
    ///
    /// Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.
    /// It only affects any future SRP update messages (i.e., adding new services and/or refreshes of the existing services).
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aInterval   The lease interval (in seconds). If zero, the default value specified by
    ///                        `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_LEASE` would be used.
    pub fn otSrpClientSetLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
unsafe extern "C" {
    /// Gets the default key lease interval used in SRP update requests.
    ///
    /// The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.
    ///
    /// Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease
    /// interval.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    ///
    /// @returns The key lease interval (in seconds).
    pub fn otSrpClientGetKeyLeaseInterval(aInstance: *mut otInstance) -> u32;
}
unsafe extern "C" {
    /// Sets the default key lease interval used in SRP update requests.
    ///
    /// The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.
    ///
    /// Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.
    /// It only affects any future SRP update messages (i.e., adding new services and/or refreshes of existing services).
    ///
    /// @param[in] aInstance    A pointer to the OpenThread instance.
    /// @param[in] aInterval    The key lease interval (in seconds). If zero, the default value specified by
    ///                         `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_KEY_LEASE` would be used.
    pub fn otSrpClientSetKeyLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
unsafe extern "C" {
    /// Gets the host info.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to host info structure.
    pub fn otSrpClientGetHostInfo(aInstance: *mut otInstance) -> *const otSrpClientHostInfo;
}
unsafe extern "C" {
    /// Sets the host name label.
    ///
    /// After a successful call to this function, `otSrpClientCallback` will be called to report the status of host info
    /// registration with SRP server.
    ///
    /// The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.
    /// OpenThread will keep the pointer to the string.
    ///
    /// The host name can be set before client is started or after start but before host info is registered with server
    /// (host info should be in either `STATE_TO_ADD` or `STATE_REMOVED`).
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aName       A pointer to host name label string (MUST NOT be NULL). Pointer to the string buffer MUST
    ///                        persist and remain valid and constant after return from this function.
    ///
    /// @retval OT_ERROR_NONE            The host name label was set successfully.
    /// @retval OT_ERROR_INVALID_ARGS    The @p aName is NULL.
    /// @retval OT_ERROR_INVALID_STATE   The host name is already set and registered with the server.
    pub fn otSrpClientSetHostName(
        aInstance: *mut otInstance,
        aName: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Enables auto host address mode.
    ///
    /// When enabled host IPv6 addresses are automatically set by SRP client using all the preferred unicast addresses on
    /// Thread netif excluding all link-local and mesh-local addresses. If there is no preferred address, then Mesh Local
    /// EID address is added. The SRP client will automatically re-register when/if addresses on Thread netif are updated
    /// (new addresses are added or existing addresses are removed or marked as non-preferred).
    ///
    /// The auto host address mode can be enabled before start or during operation of SRP client except when the host info
    /// is being removed (client is busy handling a remove request from an call to `otSrpClientRemoveHostAndServices()` and
    /// host info still being in  either `STATE_TO_REMOVE` or `STATE_REMOVING` states).
    ///
    /// After auto host address mode is enabled, it can be disabled by a call to `otSrpClientSetHostAddresses()` which
    /// then explicitly sets the host addresses.
    ///
    /// @retval OT_ERROR_NONE            Successfully enabled auto host address mode.
    /// @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot enable auto host address mode.
    pub fn otSrpClientEnableAutoHostAddress(aInstance: *mut otInstance) -> otError;
}
unsafe extern "C" {
    /// Sets/updates the list of host IPv6 address.
    ///
    /// Host IPv6 addresses can be set/changed before start or during operation of SRP client (e.g. to add/remove or change
    /// a previously registered host address), except when the host info is being removed (client is busy handling a remove
    /// request from an earlier call to `otSrpClientRemoveHostAndServices()` and host info still being in  either
    /// `STATE_TO_REMOVE` or `STATE_REMOVING` states).
    ///
    /// The host IPv6 address array pointed to by @p aIp6Addresses MUST persist and remain unchanged after returning from
    /// this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the array.
    ///
    /// After a successful call to this function, `otSrpClientCallback` will be called to report the status of the address
    /// registration with SRP server.
    ///
    /// Calling this function disables auto host address mode if it was previously enabled from a successful call to
    /// `otSrpClientEnableAutoHostAddress()`.
    ///
    /// @param[in] aInstance           A pointer to the OpenThread instance.
    /// @param[in] aIp6Addresses       A pointer to the an array containing the host IPv6 addresses.
    /// @param[in] aNumAddresses       The number of addresses in the @p aIp6Addresses array.
    ///
    /// @retval OT_ERROR_NONE            The host IPv6 address list change started successfully. The `otSrpClientCallback`
    ///                                  will be called to report the status of registering addresses with server.
    /// @retval OT_ERROR_INVALID_ARGS    The address list is invalid (e.g., must contain at least one address).
    /// @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot change host address.
    pub fn otSrpClientSetHostAddresses(
        aInstance: *mut otInstance,
        aIp6Addresses: *const otIp6Address,
        aNumAddresses: u8,
    ) -> otError;
}
unsafe extern "C" {
    /// Adds a service to be registered with server.
    ///
    /// After a successful call to this function, `otSrpClientCallback` will be called to report the status of the service
    /// addition/registration with SRP server.
    ///
    /// The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning
    /// from this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the service instance.
    ///
    /// The `otSrpClientService` instance is not longer tracked by OpenThread and can be reclaimed only when
    ///
    ///  -  It is removed explicitly by a call to `otSrpClientRemoveService()` or removed along with other services by a
    ///     call to `otSrpClientRemoveHostAndServices() and only after the `otSrpClientCallback` is called indicating the
    ///     service was removed. Or,
    ///  -  A call to `otSrpClientClearHostAndServices()` which removes the host and all related services immediately.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    /// @param[in] aService         A pointer to a `otSrpClientService` instance to add.
    ///
    /// @retval OT_ERROR_NONE          The addition of service started successfully. The `otSrpClientCallback` will be
    ///                                called to report the status.
    /// @retval OT_ERROR_ALREADY       A service with the same service and instance names is already in the list.
    /// @retval OT_ERROR_INVALID_ARGS  The service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).
    pub fn otSrpClientAddService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
unsafe extern "C" {
    /// Requests a service to be unregistered with server.
    ///
    /// After a successful call to this function, `otSrpClientCallback` will be called to report the status of remove
    /// request with SRP server.
    ///
    /// The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning
    /// from this function (with `OT_ERROR_NONE`). OpenThread will keep the service instance during the remove process.
    /// Only after the `otSrpClientCallback` is called indicating the service instance is removed from SRP client
    /// service list and can be be freed/reused.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    /// @param[in] aService         A pointer to a `otSrpClientService` instance to remove.
    ///
    /// @retval OT_ERROR_NONE       The removal of service started successfully. The `otSrpClientCallback` will be called to
    ///                             report the status.
    /// @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.
    pub fn otSrpClientRemoveService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
unsafe extern "C" {
    /// Clears a service, immediately removing it from the client service list.
    ///
    /// Unlike `otSrpClientRemoveService()` which sends an update message to the server to remove the service, this function
    /// clears the service from the client's service list without any interaction with the server. On a successful call to
    /// this function, the `otSrpClientCallback` will NOT be called and the @p aService entry can be reclaimed and re-used
    /// by the caller immediately.
    ///
    /// Can be used along with a subsequent call to `otSrpClientAddService()` (potentially reusing the same @p
    /// aService entry with the same service and instance names) to update some of the parameters in an existing service.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    /// @param[in] aService         A pointer to a `otSrpClientService` instance to delete.
    ///
    /// @retval OT_ERROR_NONE       The @p aService is deleted successfully. It can be reclaimed and re-used immediately.
    /// @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.
    pub fn otSrpClientClearService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
unsafe extern "C" {
    /// Gets the list of services being managed by client.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to the head of linked-list of all services or NULL if the list is empty.
    pub fn otSrpClientGetServices(aInstance: *mut otInstance) -> *const otSrpClientService;
}
unsafe extern "C" {
    /// Starts the remove process of the host info and all services.
    ///
    /// After returning from this function, `otSrpClientCallback` will be called to report the status of remove request with
    /// SRP server.
    ///
    /// If the host info is to be permanently removed from server, @p aRemoveKeyLease should be set to `true` which removes
    /// the key lease associated with host on server. Otherwise, the key lease record is kept as before, which ensures
    /// that the server holds the host name in reserve for when the client is once again able to provide and register its
    /// service(s).
    ///
    /// The @p aSendUnregToServer determines the behavior when the host info is not yet registered with the server. If
    /// @p aSendUnregToServer is set to `false` (which is the default/expected value) then the SRP client will immediately
    /// remove the host info and services without sending an update message to server (no need to update the server if
    /// nothing is yet registered with it). If @p aSendUnregToServer is set to `true` then the SRP client will send an
    /// update message to the server. Note that if the host info is registered then the value of @p aSendUnregToServer does
    /// not matter and the SRP client will always send an update message to server requesting removal of all info.
    ///
    /// One situation where @p aSendUnregToServer can be useful is on a device reset/reboot, caller may want to remove any
    /// previously registered services with the server. In this case, caller can `otSrpClientSetHostName()` and then request
    /// `otSrpClientRemoveHostAndServices()` with `aSendUnregToServer` as `true`.
    ///
    /// @param[in] aInstance          A pointer to the OpenThread instance.
    /// @param[in] aRemoveKeyLease    A boolean indicating whether or not the host key lease should also be removed.
    /// @param[in] aSendUnregToServer A boolean indicating whether to send update to server when host info is not registered.
    ///
    /// @retval OT_ERROR_NONE       The removal of host info and services started successfully. The `otSrpClientCallback`
    ///                             will be called to report the status.
    /// @retval OT_ERROR_ALREADY    The host info is already removed.
    pub fn otSrpClientRemoveHostAndServices(
        aInstance: *mut otInstance,
        aRemoveKeyLease: bool,
        aSendUnregToServer: bool,
    ) -> otError;
}
unsafe extern "C" {
    /// Clears all host info and all the services.
    ///
    /// Unlike `otSrpClientRemoveHostAndServices()` which sends an update message to the server to remove all the info, this
    /// function clears all the info immediately without any interaction with the server.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    pub fn otSrpClientClearHostAndServices(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets the domain name being used by SRP client.
    ///
    /// Requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.
    ///
    /// If domain name is not set, "default.service.arpa" will be used.
    ///
    /// @param[in] aInstance        A pointer to the OpenThread instance.
    ///
    /// @returns The domain name string.
    pub fn otSrpClientGetDomainName(aInstance: *mut otInstance) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Sets the domain name to be used by SRP client.
    ///
    /// Requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.
    ///
    /// If not set "default.service.arpa" will be used.
    ///
    /// The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.
    /// OpenThread will keep the pointer to the string.
    ///
    /// The domain name can be set before client is started or after start but before host info is registered with server
    /// (host info should be in either `STATE_TO_ADD` or `STATE_TO_REMOVE`).
    ///
    /// @param[in] aInstance     A pointer to the OpenThread instance.
    /// @param[in] aName         A pointer to the domain name string. If NULL sets it to default "default.service.arpa".
    ///
    /// @retval OT_ERROR_NONE            The domain name label was set successfully.
    /// @retval OT_ERROR_INVALID_STATE   The host info is already registered with server.
    pub fn otSrpClientSetDomainName(
        aInstance: *mut otInstance,
        aName: *const ::core::ffi::c_char,
    ) -> otError;
}
unsafe extern "C" {
    /// Converts a `otSrpClientItemState` to a string.
    ///
    /// @param[in] aItemState  An item state.
    ///
    /// @returns A string representation of @p aItemState.
    pub fn otSrpClientItemStateToString(
        aItemState: otSrpClientItemState,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Enables/disables "service key record inclusion" mode.
    ///
    /// When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages
    /// that it sends.
    ///
    /// Is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.
    ///
    /// @note KEY record is optional in Service Description Instruction (it is required and always included in the Host
    /// Description Instruction). The default behavior of SRP client is to not include it. This function is intended to
    /// override the default behavior for testing only.
    ///
    /// @param[in] aInstance  A pointer to the OpenThread instance.
    /// @param[in] aEnabled   TRUE to enable, FALSE to disable the "service key record inclusion" mode.
    pub fn otSrpClientSetServiceKeyRecordEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
unsafe extern "C" {
    /// Indicates whether the "service key record inclusion" mode is enabled or disabled.
    ///
    /// Is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.
    ///
    /// @param[in] aInstance     A pointer to the OpenThread instance.
    ///
    /// @returns TRUE if "service key record inclusion" mode is enabled, FALSE otherwise.
    pub fn otSrpClientIsServiceKeyRecordEnabled(aInstance: *mut otInstance) -> bool;
}
/// Represents a SRP client service pool entry.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSrpClientBuffersServiceEntry {
    ///< The SRP client service structure.
    pub mService: otSrpClientService,
    ///< The SRP client TXT entry.
    pub mTxtEntry: otDnsTxtEntry,
}
unsafe extern "C" {
    /// Gets the string buffer to use for SRP client host name.
    ///
    /// @param[in]  aInstance  A pointer to the OpenThread instance.
    /// @param[out] aSize      Pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be
    ///                        NULL).
    ///
    /// @returns A pointer to char buffer to use for SRP client host name.
    pub fn otSrpClientBuffersGetHostNameString(
        aInstance: *mut otInstance,
        aSize: *mut u16,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Gets the array of IPv6 address entries to use as SRP client host address list.
    ///
    /// @param[in]  aInstance     A pointer to the OpenThread instance.
    /// @param[out] aArrayLength  Pointer to a variable to return the array length i.e., number of IPv6 address entries in
    ///                           the array (MUST NOT be NULL).
    ///
    /// @returns A pointer to an array of `otIp6Address` entries (number of entries is returned in @p aArrayLength).
    pub fn otSrpClientBuffersGetHostAddressesArray(
        aInstance: *mut otInstance,
        aArrayLength: *mut u8,
    ) -> *mut otIp6Address;
}
unsafe extern "C" {
    /// Allocates a new service entry from the pool.
    ///
    /// The returned service entry instance will be initialized as follows:
    ///
    ///  - `mService.mName` will point to an allocated string buffer which can be retrieved using the function
    ///    `otSrpClientBuffersGetServiceEntryServiceNameString()`.
    ///  - `mService.mInstanceName` will point to an allocated string buffer which can be retrieved using the function
    ///    `otSrpClientBuffersGetServiceEntryInstanceNameString()`.
    ///  - `mService.mSubTypeLabels` points to an array that is returned from `otSrpClientBuffersGetSubTypeLabelsArray()`.
    ///  - `mService.mTxtEntries` will point to `mTxtEntry`.
    ///  - `mService.mNumTxtEntries` will be set to one.
    ///  - Other `mService` fields (port, priority, weight) are set to zero.
    ///  - `mTxtEntry.mKey` is set to NULL (value is treated as already encoded).
    ///  - `mTxtEntry.mValue` will point to an allocated buffer which can be retrieved using the function
    ///    `otSrpClientBuffersGetServiceEntryTxtBuffer()`.
    ///  - `mTxtEntry.mValueLength` is set to zero.
    ///  - All related data/string buffers and arrays are cleared to all zero.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    ///
    /// @returns A pointer to the newly allocated service entry or NULL if not more entry available in the pool.
    pub fn otSrpClientBuffersAllocateService(
        aInstance: *mut otInstance,
    ) -> *mut otSrpClientBuffersServiceEntry;
}
unsafe extern "C" {
    /// Frees a previously allocated service entry.
    ///
    /// The @p aService MUST be previously allocated using `otSrpClientBuffersAllocateService()` and not yet freed. Otherwise
    /// the behavior of this function is undefined.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    /// @param[in] aService    A pointer to the service entry to free (MUST NOT be NULL).
    pub fn otSrpClientBuffersFreeService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientBuffersServiceEntry,
    );
}
unsafe extern "C" {
    /// Frees all previously allocated service entries.
    ///
    /// @param[in] aInstance   A pointer to the OpenThread instance.
    pub fn otSrpClientBuffersFreeAllServices(aInstance: *mut otInstance);
}
unsafe extern "C" {
    /// Gets the string buffer for service name from a service entry.
    ///
    /// @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).
    /// @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be
    ///                      NULL).
    ///
    /// @returns A pointer to the string buffer.
    pub fn otSrpClientBuffersGetServiceEntryServiceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Gets the string buffer for service instance name from a service entry.
    ///
    /// @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).
    /// @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be
    ///                      NULL).
    ///
    /// @returns A pointer to the string buffer.
    pub fn otSrpClientBuffersGetServiceEntryInstanceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    /// Gets the buffer for TXT record from a service entry.
    ///
    /// @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).
    /// @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the buffer (MUST NOT be NULL).
    ///
    /// @returns A pointer to the buffer.
    pub fn otSrpClientBuffersGetServiceEntryTxtBuffer(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut u8;
}
unsafe extern "C" {
    /// Gets the array for service subtype labels from the service entry.
    ///
    /// @param[in]  aEntry          A pointer to a previously allocated service entry (MUST NOT be NULL).
    /// @param[out] aArrayLength    A pointer to a variable to return the array length (MUST NOT be NULL).
    ///
    /// @returns A pointer to the array.
    pub fn otSrpClientBuffersGetSubTypeLabelsArray(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aArrayLength: *mut u16,
    ) -> *mut *const ::core::ffi::c_char;
}
pub type __builtin_va_list = *mut ::core::ffi::c_void;
